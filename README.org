#+TITLE: Emacs Config
#+STARTUP: content
#+TODO: TODO TEST | DONE

Welcome to my emacs configuration.

* Initial Setup
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

I want to be able to potentially load separate emacs configurations so set the
base emacs directory to where the currently loading configuration is.
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory load-file-name))
#+END_SRC

I also want to keep my =user-emacs-directory= somewhat clean, so let's define a
few sub directories that we'll try to keep the plethora of emacs files in:
- =user-cache-directory= :: files that contain transient data (history, projectile, etc).
- =user-data-directory= :: files that contain version controlled data (snippets, etc)

#+BEGIN_SRC emacs-lisp
  (defvar user-cache-directory (concat user-emacs-directory "cache/"))
  (defvar user-data-directory (concat user-emacs-directory "data/"))
#+END_SRC

* Bootstrap
** Native compilation
I want to make use of the native compilation system introduced in emacs 28.
#+BEGIN_SRC emacs-lisp
  ;; do we have native compilation available?
  (defconst have-native-compilation
    (and (fboundp 'native-comp-available-p)
         (native-comp-available-p)))

  (when have-native-compilation
    (setq comp-async-jobs-number 4))
#+END_SRC
** init.el
On checking out this repo =init.el= will have temporary code in it to tangle /
load this org file (=README.org=), overwriting itself. On this initial run we will
have loaded both core =org-mode= and melpa =org-mode= so emit a warning that a
restart is needed.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; load core emacs `org-mode', but don't native compile it
  (let ((comp-deferred-compilation nil))
    (require 'org))

  ;; tangle/load our init file
  (let* ((base-dir (file-name-directory load-file-name))
         (org-file (concat base-dir "README.org"))
         (el-file (concat base-dir "init.el")))
    (org-babel-tangle-file org-file el-file)
    ;; on first load we shadow the core emacs org-mode and when trying to quit
    ;; emacs calls the non-existent function `org-clocking-buffer'. Define a dummy
    ;; to allow us to exit cleanly on initial run
    (defun org-clocking-buffer (&rest _))
    (load-file el-file)
    (warn "This is the first load of init.el so core emacs `org-mode' is loaded.
   Restart emacs to use newest version."))
#+END_SRC

We also need to tell =git= to ignore changes to =init.el= so the following command
was run:
#+BEGIN_SRC shell :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

This file (=README.org=) should be tangled into the startup config file (=init.el=)
along with compiling (either native or byte). I want that to happen automatically.
#+BEGIN_SRC emacs-lisp
  (defun ic-maybe-tangle-init-file ()
    "Tangle/compile my emacs configuration."
    (let ((org-file (concat user-emacs-directory "README.org"))
          (init-file (concat user-emacs-directory "init.el")))
      (when (equal (buffer-file-name) org-file)
        (org-babel-tangle nil init-file)
        (byte-compile init-file)
        (when have-native-compilation
          (native-compile init-file)))))

  (add-hook 'after-save-hook 'ic-maybe-tangle-init-file)
#+END_SRC

Let's also tell emacs where =init.el= lives so packages can find it. =straight.el= requires it for updating packages.
#+BEGIN_SRC emacs-lisp
  (setq user-init-file (concat user-emacs-directory "init.el"))
#+END_SRC

** straight.el
I use =straight.el= for package management so install this early.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integrate =straight.el= with =use-package=.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
#+END_SRC

I want to check in my packages to git so store the version file under =user-data-directory=.
#+BEGIN_SRC emacs-lisp
  (setq straight-profiles `((nil . ,(concat user-data-directory "straight-default.el"))))
#+END_SRC

** Theme
Load my custom theme early so if we have errors emacs still looks pretty.

#+BEGIN_SRC emacs-lisp
  (straight-use-package '(themian :type git :host github :repo "turbana/themian"))
  (load-theme 'themian-dark t)
#+END_SRC

** Debugging
*** Tracing
Some functions to trace the changing of variables.

#+BEGIN_SRC emacs-lisp
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
    (ic/watch-variable-call-func symbol 'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (sym value operation buffer)
      (let ((msg (ic//watch-variable-format sym buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol 'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol 'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (sym value operation buffer)
        (when (member operation ops)
          (apply func (list sym value operation buffer))))
      (add-variable-watcher symbol 'watch-change)
      (push (cons symbol 'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC

*** Profiling
Some profiler keybindings.

#+BEGIN_SRC emacs-lisp
  (require 'profiler)

  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))
#+END_SRC

** Keybinds
I like the spacemacs idea of having both a leader key (=SPC=) and a (mode-specific)
local leader key (=,=). The leader key being how all the major functions are
accessed, such as buffers/files/windows/etc. Where the local leader is how
mode-specific functions are accessed, such as =org-mode= bindings or =mu4e=, etc.

There are a few things I don't care for though: I don't need emacs bindings, nor
do I want access to the local leader map from the leader map (=SPC m=). So I want
a dual leader key system without the cruft.

The package =general.el= makes all of the above rather simple. Here we ensure it's
installed and activated with =:demand t=. We then setup two =definers=, one for the
leader key (=leader-keys=) and one for the local leader key (=local-leader-keys=).
Both =definers= define their keys in the =general-override-mode-map= keymap. This
keymap has a high priority, but only when =general-override-mode= is active so
ensure it is with =(general-override-mode 1)=.

#+BEGIN_SRC emacs-lisp
  (use-package general
      :demand t
      :config
      ;; ensure `general-override-mode-map' is active
      (general-override-mode 1)

      ;; create leader (SPC) definer
      (general-create-definer leader-keys
        :states '(normal insert emacs)
        :keymaps 'general-override-mode-map
        :prefix "SPC"
        :non-normal-prefix "C-SPC")

      ;; create local leader (,) definer
      (general-create-definer local-leader-keys
        :states '(normal insert emacs)
        :keymaps 'general-override-mode-map
        :prefix ","
        :non-normal-prefix "C-,"))
#+END_SRC

* Packages
** all-the-icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** auto-dim-other-buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't
dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for
color customization.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
      :config
      (setq auto-dim-other-buffers-dim-on-focus-out t)
      (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
      (auto-dim-other-buffers-mode t))
#+END_SRC

** evil
*** use-package
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package evil
      :ensure evil
      :init
      <<evil-init>>
      :config
      <<evil-config>>
      )
#+END_SRC

*** Init
:PROPERTIES:
:header-args: :noweb-ref evil-init :tangle no
:END:

The following are needed for =evil-collection=:
#+BEGIN_SRC emacs-lisp
  ;; needed for evil-collection
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
#+END_SRC

Misc setup
#+BEGIN_SRC emacs-lisp
  ;; don't bind anything under C-g
  (setq evil-want-C-g-bindings nil)

  ;; C-u/d should scroll up/down
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-d-scroll t)

  ;; C-w should backwards delete work in insert mode
  (setq evil-want-C-w-delete t)

  ;; Y should only yank from point to eol
  (setq evil-want-Y-yank-to-eol t)

  ;; movement commands should respect `visual-line-mode'
  (setq evil-respect-visual-line-mode t)
#+END_SRC

*** Config
:PROPERTIES:
:header-args: :noweb-ref evil-config :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

** evil-collection
Some basic community =evil-mode= bindings for various modes. See
=evil-collection--supported-modes= for a list.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
      :after evil
      :config
      (evil-collection-init))
#+END_SRC

** evil-org-mode
Some basic community =evil-mode= key bindings for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
      :demand t
      :after (evil org)
      :hook (org-mode . (lambda () evil-org-mode))
      :config
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
#+END_SRC

** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
      :config
      (helm-mode 1)

      ;; bring up helm full width below other windows
      (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))

      ;; short window by default
      (setq helm-display-buffer-default-height 15)

      :general
      (general-define-key
       :keymaps 'helm-map
       ;; I'm too used to C-w killing a word backwards
       "C-w" 'backward-kill-word
       ;; TAB should be more useful than bringing up actions
       "<tab>" 'helm-execute-persistent-action
       "C-i" 'helm-execute-persistent-action
       ;; C-, should start actions
       "C-," 'helm-select-action
       ;; C-. to paste into buffer
       "C-." 'helm-copy-to-buffer
       )

      (general-define-key
       "M-x" 'helm-M-x)

      (general-define-key
       :states '(normal)
       "gi" 'helm-semantic-or-imenu)
      )
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    ;; don't use magit's default key bindings
    (setq magit-define-global-key-bindings nil)

    :general
    (general-define-key
     :keymaps 'magit-status-mode-map
     "<up>" 'magit-section-backward
     "<down>" 'magit-section-forward))
#+END_SRC

** org
=org-mode= is a large part of my daily emacs usage so it takes a large amount of
my configuration as well. Let's go...

*** use-package
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
      :mode (("\\.org$" . org-mode))
      :ensure org-plus-contrib
      :after (all-the-icons yasnippet)
      :config
      <<org-config>>
      :general
      <<org-keybinds>>
      )
#+END_SRC

*** config
:PROPERTIES:
:header-args: :noweb-ref org-config :tangle no
:END:

**** Basic Setup
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/org" "~/org/home"))
  (setq org-default-notes-file "~/org/refile.org")
  (setq org-archive-location "%s_archive::")
  (setq ic/org-capture-template-dir "~/.etc/spacemacs/org-capture-templates/")
#+END_SRC

**** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp
  (defun ic/org-jump ()
    "Jump to an `org-refile-targets' heading."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-refile)))

  (defun ic/org-jump-in-buffer ()
    "Jump to a heading in the current buffer."
    (interactive)
    ;; `org-refile-targets' needs to be dynamically bound
    (defvar org-refile-targets)
    (let ((org-refile-targets '((nil :maxlevel . 999))))
      (ic/org-jump)))
#+END_SRC

**** Normal mode navigation
#+BEGIN_SRC emacs-lisp
  (defun ic/outline-current-heading-or-up ()
    "When point is on an org-mode heading: move to parent heading;
  otherwise: move to current heading."
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'outline-up-heading
                          'outline-previous-heading)))

  (defun ic/outline-current-heading-or-backward ()
    "when point is on an org-mode heading: move to previous heading;
  otherwise: move to previous heading"
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'org-backward-heading-same-level
                          'outline-previous-heading)))
#+END_SRC

**** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation t)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: E \equal{} \gamma{}mc^2
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]].
#+BEGIN_SRC emacs-lisp
  ;; ⚫•⦾⦿—⬎⌄⌵
  (setq org-ellipsis " ⌵")
  (setq ic/org-list-icon "—")
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 ()
           (compose-region (match-beginning 1)
                           (match-end 1)
                           ic/org-list-icon))))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

**** org-src
Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

When editing an =org-src= block =:w= should save the parent buffer.
#+BEGIN_SRC emacs-lisp
  (evil-define-operator ic/evil-write (&rest args)
    "When editing an org-src block `:w' should call `(org-edit-src-save)'."
    :motion nil
    :move-point nil
    :type line
    :repeat nil
    (interactive "<R><fsh><!>")
    (if (bound-and-true-p org-src-mode)
        (org-edit-src-save)
      (call-interactively 'evil-write args)))

  (evil-ex-define-cmd "w" 'ic/evil-write)
#+END_SRC

**** Agenda
***** Setup
#+BEGIN_SRC emacs-lisp
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(
          ;; work agenda
          ("w" "Work Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile/"
            ;;       ((org-agenda-overriding-header "Archive tasks:")
            ;;        (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            )
           ((org-agenda-tag-filter-preset '("-HOME"))))

          ;; home agenda
          ("h" "Home agenda"
           ((agenda ""
                    ((org-agenda-skip-function 'ic/skip-old-meal-plans)))
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile"
            ;;       ((org-agenda-overriding-header "\nArchive tasks:")
            ;;        (org-agenda-skip-function 'ic/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores-PRIORITY=\"A\"|jobs-PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))
                        ))
            (tags "+HOME"
                  ((org-agenda-overriding-header "\nStuck Projects")
                   (org-agenda-skip-function 'ic/org-skip-nonstuck-projects
                    )))
            )
           ((org-agenda-tag-filter-preset '("+HOME"))))

          ;; archives
          ("a" . "Archiving")
          ("ah" "Home archive"
           ((tags "+HOME-noarchive/DONE|CANCELLED|APPLIED"
                  ((org-agenda-overriding-header "Archive Tasks (*B$ to archive all):")))))
          ("aw" "Work archive"
           ((tags "-HOME-noarchive+TIMESTAMP_IA<=\"<-2w>\"/DONE|CANCELLED"
                  ((org-agenda-overriding-header "Archive Tasks (*B$ to archive all):")))))
          ))
#+END_SRC

***** Appearance
#+BEGIN_SRC emacs-lisp
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)

  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)

  ;; show weekly agenda by default
  (setq org-agenda-span 'week)

  ;; don't have a separator between agenda sections
  (setq org-agenda-compact-blocks t)

  ;; show agenda icons
  (setq org-agenda-prefix-format "  %i %?-2 t%s")
#+END_SRC

***** Test icons (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disable
  ;;; DISABLED ;;;

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (setq tab-width 2)
  ;;                                         ; (setq tab-stop-list '(2 3 5))
  ;;             ))

  (require 'all-the-icons)

  ;; (let ((font (find-font (font-spec :name "FontAwesome"))))
  ;;   (font-put font :spacing 100)
  ;;   (font-get font :spacing)
  ;;   )

  (defun ic/org-agenda-icon (family icon-name)
    (let* ((icon-func (cdr (assoc family
                                  '((ati . all-the-icons-alltheicon)
                                    (faicon . all-the-icons-faicon)
                                    (fileicon . all-the-icons-fileicon)
                                    (octicon . all-the-icons-octicon)
                                    (wicon . all-the-icons-wicon)))))
           (face-func (cdr (assoc family
                                  '((ati . all-the-icons-icon-family)
                                    (faicon . all-the-icons-faicon-family)
                                    (fileicon . all-the-icons-fileicon-family)
                                    (octicon . all-the-icons-octicon-family)
                                    (wicon . all-the-icons-wicon-family)))))
           (all-the-icons-scale-factor 1.0)
           ;; (font (concat (apply face-func nil) ":spacing=monospace"))
           (font "FontAwesomeMono:spacing=100")
           ;; (font (apply face-func nil))
           (face `(:family ,font :height 1.0))
           ;; (icon (apply icon-func (list icon-name :face 'default)))
           (icon (cdr (assoc icon-name all-the-icons-data/fa-icon-alist)))
           )
      (propertize icon
                  'face face
                  'font-lock-face face
                  ;; 'display '(space :width (50) :height 7)
                  ;; 'display '(space-width 5)
                  'rear-nonsticky t
                  )
      ))

  ;; (ic/org-agenda-icon 'faicon "calendar")

  ;; (let ((icon (all-the-icons-faicon "calendar")))
  ;;   (string-to-char icon))

  ;; setup agenda icons
  (setq org-agenda-category-icon-alist
        (let ((icon-mapping
               '(
                 ("annivers" faicon "calendar")
                 ("birthdays" faicon "birthday-cake")
                 ("chores" faicon "home")
                 ("computer" faicon "keyboard-o")
                 ("cpu" faicon "fax")
                 ("holidays" faicon "calendar-o")
                 ("cooking" faicon "cutlery")
                 ("health" faicon "heartbeat")
                 ("jobs" faicon "building-o")
                 ("life" faicon "male")
                 )))
          (mapcar (lambda (config)
                    ;; `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)) :width (50)) nil nil :ascent center :mask heuristic))
                    `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)))))
                  icon-mapping
                  )))

  (defun blaenk/set-char-widths (alist)
    (while (char-table-parent char-width-table)
      (setq char-width-table (char-table-parent char-width-table)))
    (dolist (pair alist)
      (let ((width (car pair))
            (chars (cdr pair))
            (table (make-char-table nil)))
        (dolist (char chars)
          (set-char-table-range table char width))
        (optimize-char-table table)
        (set-char-table-parent table char-width-table)
        (setq char-width-table table))))

  (defconst old-char-width-table char-width-table)

  ;; argument is an alist of width and list of RANGEs,
  ;; which is the same as the RANGE that set-char-table-range accepts
  ;; (blaenk/set-char-widths
  ;;  `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;           ,(string-to-char (all-the-icons-faicon "home"))
  ;;           ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;           ))))

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (message "set-char-widths")
  ;;             (blaenk/set-char-widths
  ;;              `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;                       ,(string-to-char (all-the-icons-faicon "home"))
  ;;                       ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;                       ))))
  ;;                            ))




  ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping
  ;;              '(
  ;;                ("annivers" (all-the-icons-faicon "calendar"))
  ;;                ("birthdays" (all-the-icons-faicon "birthday-cake"))
  ;;                ("chores" (all-the-icons-faicon "home"))
  ;;                ("computer" (all-the-icons-faicon "keyboard-o"))
  ;;                ("cpu" (all-the-icons-faicon "fax"))
  ;;                ("holidays" (all-the-icons-faicon "calendar-o"))
  ;;                ("cooking" (all-the-icons-faicon "cutlery"))
  ;;                ("health" (all-the-icons-faicon "heartbeat"))
  ;;                ("jobs" (all-the-icons-faicon "building-o"))
  ;;                ("life" (all-the-icons-faicon "male"))
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (car config))
  ;;                         (icon (apply (caadr config) (cdadr config))))
  ;;                     `(,category (list ,icon :width (100)) nil nil :ascent center :mask heuristic :width (100))))
  ;;                 icon-mapping)))



  ;; ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping-alist
  ;;              '(
  ;;                ("annivers" 'faicon "calendar")
  ;;                ("birthdays" 'faicon "birthday-cake")
  ;;                ("chores" 'faicon "home")
  ;;                ("computer" 'faicon "keyboard-o")
  ;;                ("cpu" 'faicon "fax")
  ;;                ("holidays" 'faicon "calendar-o")
  ;;                ("cooking" 'faicon "cutlery")
  ;;                ("health" 'faicon "heartbeat")
  ;;                ("jobs" 'faicon "building-o")
  ;;                ("life" 'faicon "male")
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (first config))
  ;;                         (icon-family (second config))
  ;;                         (icon-name (third config))
  ;;                         (ati-family-alist
  ;;                          '(('ati . all-the-icons-alltheicon)
  ;;                            ('faicon . all-the-icons-faicon)
  ;;                            ('fileicon . all-the-icons-fileicon)
  ;;                            ('octicon . all-the-icons-octicon)
  ;;                            ('wicon . all-the-icons-wicon))))
  ;;                 `(,category (list ,(apply (cdr (assoc icon-family ati-family-alist)) (list icon-name :height 0.9 :v-adjust 0))) nil nil :ascent center :mask heuristic)))
  ;;                   icon-mapping-alist)))
#+END_SRC

***** Functions
****** Stuck Projects (disabled)
An org heading is considered a stuck project if it satisfies all the following:

- It has a todo state and it's parent does not
- It has one or more immediate children with todo state
- It has no descendants with a NEXT todo state

#+BEGIN_SRC emacs-lisp :noweb-ref disable
  (defun ic/org-is-active-task-p ()
    "Returns `t' if the current task is a member of `org-not-done-keywords'."
    (member (org-get-todo-state) org-not-done-keywords))


  (defun ic/org-any-active-parent-p ()
    "Return `t' if any parent task is an active task."
    (save-excursion)
    (widen)
    (let (active-parent)
      (while (org-up-heading-safe)
        (when (ic/org-is-active-task-p)
          (setq active-parent t)))
      active-parent))

  (defun ic/org-stuck-project-p ()
    (save-excursion
      (let (
            ;; (parent-is-active (save-excursion
            ;;                     (when (org-up-heading-safe)
            ;;                       (ic/org-is-active-task-p))))
            (has-next-children
             (save-excursion
               (let ((subtree-end (save-excursion (org-end-of-subtree t))))
                 (re-search-forward "^\\*+ NEXT " subtree-end t)))))
        ;; (message (concat (org-get-heading) " :: " (org-get-todo-state) " " (prin1-to-string org-not-done-keywords)))
        ;; (prin1 (ic/org-is-active-task-p))
        ;; (prin1 (not parent-is-active))
        ;; (prin1 has-next-children)
        (and (ic/org-is-active-task-p)
             (not (ic/org-any-active-parent-p))
             (not has-next-children))
        )))


  (defun ic/test (args)
    (interactive "P")
    (message (if (ic/org-stuck-project-p)
                 "stuck"
               "non-stuck")))
  (define-key org-mode-map (kbd "C-=") 'ic/test)


  (defun ic/org-skip-nonstuck-projects ()
    (let ((debug-on-error t))
      (save-excursion
        (widen)
        (unless (ic/org-stuck-project-p)
          (or (outline-next-heading) (point-max))))
      ))
#+END_SRC

****** TODO Test stuck
******* TODO child task
******* NEXT next task

**** Habits
#+BEGIN_SRC emacs-lisp
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 2)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today t)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC

**** Todo
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(a@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC

**** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC

**** Capture
***** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("r" "reply" entry (file org-default-notes-file)
           "* TODO Reply to %:from on %:subject\nSCHEDULED: %t\n%u\n%a\n"
           :immediate-finish t
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")
          ("P" "meal plan" entry (file+datetree ic/recipes-plan-file)
           (file ,(concat ic/org-capture-template-dir "meal-plan.org"))
           :immediate-finish t
           :time-prompt t
           :tree-type week)
          ))
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

***** Full Frame
The standard =org-capture= behavior is to split the window before capturing a
task. When this is started from outside emacs a random buffer occupies half the
frame. What I want is the capture buffer to take the full frame when starting
the capture from outside emacs. My window manager will start the capture task
with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook
where it splits the frame we'll need to advise it to ~(delete-other-windows)~
when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC

**** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disabled
  (require 'org-clock)

  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  ;; persist open clocks
  (setq org-clock-persist-file (concat user-cache-directory "org-clock-save.el"))
  (org-clock-persistence-insinuate)

  (defun ic/org-clock-jump-to-current-clock ()
    "Jump to the currently active clock."
    (interactive)
    ;; why isn't this (interactive) already, ugh
    (org-clock-jump-to-current-clock))
#+END_SRC

**** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
  ;; save id locations in a nicer place
  (setq org-id-locations-file (concat user-cache-directory "org-id-locations"))
#+END_SRC

**** Code Execution
Don't prompt for code execution if we're in a file in certain locations.

#+BEGIN_SRC emacs-lisp
  (defvar ic/allow-babel-evaluate-directories
        '("~/org" "~/.etc"))

  (defun ic/org-confirm-babel-evaluate (_lang _body)
    (let ((filename (buffer-file-name))
          match)
      (dolist (path ic/allow-babel-evaluate-directories (not match))
        (when (string-prefix-p (expand-file-name path) filename)
          (setq match t)))))

  (setq org-confirm-babel-evaluate #'ic/org-confirm-babel-evaluate)
#+END_SRC

**** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want
to see most everything else.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC

**** Snippets
By convention I title most of my snippets ={snippet}>= so I would like the =>= key
to try and expand snippets automatically. When no snippet is found a regular =>=
should be entered.
#+BEGIN_SRC emacs-lisp
  (defun ic/yas-expand-> ()
    (interactive)
    (insert ">")
    (yas-expand))
#+END_SRC

Based on [[https://emacs.stackexchange.com/questions/29758/yasnippets-and-org-mode-yas-next-field-or-maybe-expand-does-not-expand][this]] stackexchange post =org-mode= binds the tab key in such a way that
=yas-snippets= can't use it. So we need the following to allow =TAB= to expand
snippets while in =org-mode=.
#+BEGIN_SRC emacs-lisp
  (defun ic/set-org-mode-tab-key ()
    (add-to-list 'org-tab-first-hook 'yas-expand)
    ;; XXX is this needed?
    ;; (general-define-key yas-keymap
    ;;   "<tab>" 'yas-next-field)
    )

  (add-hook 'org-mode-hook 'ic/set-org-mode-tab-key)
#+END_SRC

**** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/skip-non-archivable-tasks ()
    "Skip tasks that I don't want to archive"
    (or (ic/skip-old-meal-plans)
        (bh/skip-non-archivable-tasks)))


  (defun ic/skip-old-meal-plans ()
    "Skip over a task if it's 1) a meal plan and 2) scheduled before today."
    (save-restriction
      (widen)
      (let* ((tags (org-get-tags))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (scheduled (org-get-scheduled-time (point)))
             (yesterday (* 60 60 24 1))
             ;; HACK we check 24 hours ago rather than previous midnight
             (now (time-subtract (current-time) (seconds-to-time yesterday))))
        (if (and (member "cooking" tags)
                 (member "plan" tags)
                 scheduled
                 (time-less-p scheduled now))
            subtree-end
          nil))))


  (defun ic/org-recipe-publish-to-html (_plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC

*** keybinds
:PROPERTIES:
:header-args: :noweb-ref org-keybinds :tangle no
:END:

**** local-leader
Main =local-leader= key binds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "'" 'org-edit-special
    ":" 'org-set-tags
    "^" 'org-sort
    "A" 'org-archive-subtree
    "D" 'org-insert-drawer
    "d" 'org-deadline
    "f" 'org-set-effort
    "H" 'org-shiftleft
    "J" 'org-shiftdown
    "K" 'org-shiftup
    "L" 'org-shiftright
    "l" 'org-open-at-point
    "N" 'widen
    "n" 'org-narrow-to-subtree
    "P" 'org-set-property
    "r" 'org-refile
    "s" 'org-schedule
    "t" 'org-todo
    )
#+END_SRC

=,c= clocks keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "c"
    "" '(nil :which-key "clocks")
    "i" 'org-clock-in
    "j" 'ic/org-clock-jump-to-current-clock
    "o" 'org-clock-out
    "q" 'org-clock-cancel)
#+END_SRC

=,e= export keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "e"
    "" '(nil :which-key "export")
    "e" 'org-export-dispatch
    "T" 'org-babel-tangle-file
    "t" 'org-babel-tangle)
#+END_SRC

=,i= insert keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "i"
    "" '(nil :which-key "insert")
    "a" 'org-attach
    "f" 'org-footnote-new
    "l" 'org-insert-link
    "t" 'org-time-stamp
    "T" 'org-time-stamp-inactive
    "s" 'org-download-screenshot
    "y" 'org-download-yank
    )
#+END_SRC

TODO =,T= tables keybinds
#+BEGIN_SRC emacs-lisp

#+END_SRC

**** org-src
=org-src-mode= bindings:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
      :definer 'minor-mode
      :states 'normal
      :keymaps 'org-src-mode
      ;; ,c has which-key information from "clocks"
      "c" '(org-edit-src-exit :which-key "org-edit-src-exit")
      "k" 'org-edit-src-abort
      )
#+END_SRC

**** leader-key
=leader-key= keybinds:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   "oj" 'ic/org-jump-in-buffer
   "oJ" 'ic/org-jump)
#+END_SRC

**** global
global keybinds:
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<f12>" 'org-agenda
   "M-<f12>" 'org-clock-goto)
#+END_SRC

**** normal mode
Here I have some custom normal mode navigation.
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states 'normal
    :keymaps 'org-mode-map

    "<left>"      'ic/outline-current-heading-or-up
    "<up>"        'ic/outline-current-heading-or-backward
    "<down>"      'org-forward-heading-same-level
    "<right>"     'outline-next-visible-heading

    "S-<left>"    'org-promote-subtree
    "S-<up>"      'org-move-subtree-up
    "S-<down>"    'org-move-subtree-down
    "S-<right>"   'org-demote-subtree

    "C-S-<left>"  'org-do-promote
    "C-S-<right>" 'org-do-demote
    )
#+END_SRC

**** insert mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
      :states 'insert
      :keymaps 'org-mode-map
      ">" 'ic/yas-expand->)
#+END_SRC

** org-bullets
Let's have some fancy heading bullets.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("•"))
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** smartparens
Keep my toe-nail clippings in balance.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
      :config
      (require 'smartparens-config)
      (smartparens-global-strict-mode 1)
      ;; don't run smartparens in the minibuffer
      (add-hook 'minibuffer-mode-hook 'turn-off-smartparens-strict-mode)
      )
#+END_SRC

** spaceline
I want a pretty mode-line. Note: most of the configuration happens in the
=spaceline-all-the-icons= package.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
      :config
      ;; use a custom mode-line while in helm
      (spaceline-helm-mode 1)

      ;; use pretty separators
      (setq powerline-default-separator 'contour)

      ;; change face based on evil state
      (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)
      )
#+END_SRC

** spaceline-all-the-icons
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package spaceline-all-the-icons
      :after (all-the-icons spaceline)
      :config
      <<spaceline-ati-config>>
      )
#+END_SRC

*** config
:PROPERTIES:
:header-args: :noweb-ref spaceline-ati-config :tangle no
:END:

By default =all-the-icons= returns an object without an =:inherit= property. You can
pass a face to inherit from, but can't specify a bare =:inherit=. This has the
issue where an icon has the wrong background color based on which section of the
modeline it occupies. So we need a function that will both apply a bare =:inherit=
property along with some default scaling values.
#+BEGIN_SRC emacs-lisp
  (defun ic/icon (name &optional group)
    (setf group (or group 'alltheicon))
    (let* ((icon (funcall (intern (format "all-the-icons-%s" group))
                          name))
           (family (plist-get (plist-get (text-properties-at 0 icon)
                                         'face)
                              :family))
           (face `(:family ,family :inherit)))
      (propertize icon 'face face 'font-lock-face face 'display '(raise 0.1))))
#+END_SRC

For the version control segment I would like the see the git icon along with the
current file's status if we're in the master branch. If we're in a non-master
branch I want to see the git branch icon along with the branch name and current
file's status.
#+BEGIN_SRC emacs-lisp
  (defun ic//vc-icon-git ()
    (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
           ;; (project-name (second (nreverse (split-string (projectile-project-root) "/"))))
           (vc-state-icon (pcase (vc-state (buffer-file-name))
                            ('up-to-date "-")
                            ('edited "*")
                            ('added "^")
                            ('removed' "v")
                            ('conflict "!")
                            ('missing "m")
                            ('ignored "i")
                            ('unregistered "x")
                            (_ "?")))
           (branch-icon (if (string= branch "master")
                            (ic/icon "git")
                          (concat
                           (ic/icon "git-branch" 'octicon)
                           " "
                           branch))))
      (concat vc-state-icon " " branch-icon)))

  (spaceline-define-segment
      ic-vc-icon "A segment for the Version Control icon"
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode) (ic//vc-icon-git))
              (t (propertize (format "%s" vc-mode))))))
#+END_SRC

Set the mode line.
#+BEGIN_SRC emacs-lisp
  ;; bring in bundled segments
  (require 'spaceline-segments)

  ;; and define our custom mode-line
  (spaceline-compile
   'main
   ;; left side
   '((window-number
      :priority 100
      :fallback evil-state
      :face highlight-face)
     ((buffer-modified
       all-the-icons-mode-icon
       remote-host)
      :priority 95)
     ((buffer-id)
       :priority 96)
     ((anzu
       selection-info)
      :priority 90)
     ((flycheck-error
       flycheck-warning
       flycheck-info)
      :priority 85)
     ((ic-vc-icon)
      :priority 87)
     all-the-icons-git-status
     process)

   ;; right side
   '(((buffer-encoding-abbrev buffer-size
       input-method)
      :priority 5)
     (buffer-position
      :priority 91)))


  ;; and enable it
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
#+END_SRC

=mode-line-format= is buffer-local and there are some buffers that have set it
prior to us generating the mode-line, so we need to reset their values:
#+BEGIN_SRC emacs-lisp
  (save-excursion
    (dolist (name '("*Messages*" "*scratch*" "*straight-process*"))
      (if-let ((buffer (get-buffer name)))
          (with-current-buffer buffer
            (setq mode-line-format (default-toplevel-value 'mode-line-format))))))
#+END_SRC

** variable-pitch
=org-mode= should be mostly variable pitch with only code and =company-mode= being
fixed width.

#+BEGIN_SRC emacs-lisp
  (defvar ic/org-faces-fixed-pitch
    '(company-echo
      company-echo-common
      company-preview
      ;; keep this variable pitched as it's used on the same line as the input
      ;; text (which is variable).
      ;; company-preview-common
      company-preview-search
      company-scrollbar-bg
      company-scrollbar-fg
      company-template-field
      company-tooltip
      company-tooltip-annotation
      company-tooltip-annotation-selection
      company-tooltip-common
      company-tooltip-common-selection
      company-tooltip-mouse
      company-tooltip-search
      company-tooltip-search-selection
      company-tooltip-selection
      linum
      org-block
      org-block-begin-line
      org-block-end-line
      org-checkbox
      org-code
      org-date
      org-document-info-keyword
      org-hide
      org-indent
      org-link
      org-meta-line
      org-special-keyword
      org-table
      whitespace-space
      )
    "A list of faces that should remain fixed width when enabling
  `variable-pitch-mode'.")

  (defun ic//variable-pitch-add-inherit (attrs parent)
    "Add `:inherit PARENT' to ATTRS unless already present. Handles cases where :inherit is already specified."
    (let ((current-parent (plist-get attrs :inherit)))
      (unless (or (eq parent current-parent)
                  (and (listp current-parent) (member parent current-parent)))
        (plist-put attrs :inherit (if current-parent
                                      (list current-parent parent)
                                    parent)))))

  (defun ic/variable-pitch-mode ()
    (variable-pitch-mode 1)
    (mapc
     (lambda (face)
       (when (facep face)
         (apply 'set-face-attribute
                face nil (ic//variable-pitch-add-inherit
                          (face-attr-construct face)
                          'fixed-pitch))))
     ic/org-faces-fixed-pitch))

  (add-hook 'org-mode-hook #'ic/variable-pitch-mode)
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
      :config
      (which-key-mode 1))
#+END_SRC

** winum
For numbering and jumping to windows.
#+BEGIN_SRC emacs-lisp
  (use-package winum
      :demand t
      :config
      ;; I want frames numbered only within a frame, not globally
      (setq winum-scope 'frame-local)
      ;; spaceline handles window numbers
      (setq winum-auto-setup-mode-line nil)
      (winum-mode)

      (defun ic/winum-delete-window-0-or-10 (&optional _arg)
        "Delete window 0 if assigned or 10 if exists."
        (interactive "P")
        (winum-select-window-0-or-10 '(4)))

      (defmacro defun-ic--winum-delete-window-num (n)
        "Create function for calling `winum-select-window-by-number'
  so that it kills window N."
        `(defun ,(intern (format "ic/winum-delete-window-%d" n)) (&optional _arg)
           ,(format "Delete window %d." n)
           (interactive "P")
           (winum-select-window-by-number ,(- n))))

      (defun-ic--winum-delete-window-num 1)
      (defun-ic--winum-delete-window-num 2)
      (defun-ic--winum-delete-window-num 3)
      (defun-ic--winum-delete-window-num 4)
      (defun-ic--winum-delete-window-num 5)
      (defun-ic--winum-delete-window-num 6)
      (defun-ic--winum-delete-window-num 7)
      (defun-ic--winum-delete-window-num 8)
      (defun-ic--winum-delete-window-num 9)

      :general
      (leader-keys
       "0" '(winum-select-window-0-or-10 :which-key ("0..9" . "winum-window 0..9"))
       "1" '(winum-select-window-1 :which-key t)
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t)
       "C-0" '(ic/winum-delete-window-0-or-10 :which-key ("C-0..9" . "ic/winum-delete-window 0..9"))
       "C-1" '(ic/winum-delete-window-1 :which-key t)
       "C-2" '(ic/winum-delete-window-2 :which-key t)
       "C-3" '(ic/winum-delete-window-3 :which-key t)
       "C-4" '(ic/winum-delete-window-4 :which-key t)
       "C-5" '(ic/winum-delete-window-5 :which-key t)
       "C-6" '(ic/winum-delete-window-6 :which-key t)
       "C-7" '(ic/winum-delete-window-7 :which-key t)
       "C-8" '(ic/winum-delete-window-8 :which-key t)
       "C-9" '(ic/winum-delete-window-9 :which-key t)
       )
      )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :init
      ;; XXX
      (setq yas-snippet-dirs '("~/.etc/spacemacs/snippets"))
      (yas-global-mode 1))
#+END_SRC

* Modes
** info-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

** lisp-mode
Setup tab width.
#+BEGIN_SRC emacs-lisp
  (defun ic/lisp-mode-setup ()
    (setq indent-tabs-mode nil)
    (setq tab-width 8)
    (setq lisp-indent-function 'common-lisp-indent-function))

  (add-hook 'lisp-mode-hook #'ic/lisp-mode-setup)
#+END_SRC

** prog-mode
#+BEGIN_SRC emacs-lisp
  (defun ic/prog-mode-setup ()
    (flyspell-prog-mode)
    (setq indent-tabs-mode nil)
    (setq tab-width 4))
  (add-hook 'prog-mode-hook #'ic/prog-mode-setup)
#+END_SRC

** python-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'python))

  (defun ic/python-mode-setup ()
    (setq python-indent-offset tab-width))

  (add-hook 'python-mode-hook #'ic/python-mode-setup)
#+END_SRC

** text-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

** winner-mode
I like being able to undo/redo window changes.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

* Misc
** Misc cruft
Turn off some default emacs settings I don't like, such as the menu bar, scroll
bar, etc.

#+BEGIN_SRC emacs-lisp
  ;; disable unwanted UI elements
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  ;; static cursor
  (blink-cursor-mode -1)

  ;; don't show the initial emacs screen
  (setq inhibit-startup-screen t)
  ;; start in the *Messages* buffer
  (setq initial-buffer-choice (lambda () (get-buffer "*Messages*")))
  ;; let me use y/n in prompts
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** user-emacs-directory
Try and keep the =user-emacs-directory= somewhat clean.
#+BEGIN_SRC emacs-lisp
  ;; cache/ directory
  (setq recentf-save-file (concat user-cache-directory "recentf"))
  (setq transient-history-file (concat user-cache-directory "transient-history.el"))
  (setq bookmark-default-file (concat user-cache-directory "bookmarks"))
  (setq tramp-persistency-file-name (concat user-cache-directory "tramp"))

  ;; cache/{backups,auto-saves}
  (let ((backup-dir (concat user-cache-directory "backups/"))
        (autosave-dir (concat user-cache-directory "auto-saves/")))
    ;; create directories if needed
    (dolist (path (list backup-dir autosave-dir))
      (unless (file-directory-p path)
        (make-directory path t)))
    (setq backup-directory-alist `((".*" . ,backup-dir)))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq auto-save-list-file-prefix (concat autosave-dir "saves-"))
    (setq tramp-backup-directory-alist `((".*" ,backup-dir)))
    (setq tramp-auto-save-directory autosave-dir))

  ;; data/ directory
  (setq abbrev-file-name (concat user-data-directory "abbrev"))
#+END_SRC

** Buffers
Some useful buffer related functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/yank-buffer-to-clipboard ()
    "Yank contents of current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun ic/paste-clipboard-to-buffer ()
    "Overwrite the current buffer with the clipboard contents."
    (interactive)
    (when (yes-or-no-p "Overwrite current buffer with clipboard?")
      (widen)
      (erase-buffer)
      (clipboard-yank)))

  (defun ic/yank-current-filename ()
    "Yank the full filename of the currently active buffer. Return
  `nil' if no underlying file."
    (interactive)
    (let ((filename (or (buffer-file-name) "nil")))
      (kill-new filename)
      (message filename)))

  (defun ic/switch-to-scratch-buffer ()
    "Switch to the `*scratch*' buffer."
    (interactive)
    (switch-to-buffer (startup--get-buffer-create-scratch)))
#+END_SRC

** display-buffer configuration
#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
          ;; display help windows on the right
          ("^\\*Help"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . right)
           (slot . 1)
           (window-width . 80)
           (reusable-frames . nil))

          ;; display compile errors on the bottom
          ("^\\*\\(Compile\\|Backtrace\\)"
           (display-buffer-reuse-window display-buffer-at-bottom)
           (window-width . 0.5)
           (window-height . 15)
           (reusable-frames . nil))

          ;; display magit windows on the left
          ("^magit:"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . left)
           (slot . 1)
           (window-width . 80)
           (window-height . 1.0)
           (reusable-frames . nil))
          ))
#+END_SRC

** Secrets
I keep certain information out of source control: email addresses, account
information, etc. I have a small python program called =secret= that I use to
retrieve these secrets, let's expose that to emacs.

#+BEGIN_SRC emacs-lisp
  (defvar ic/secret-cmd "secret")

  (defun ic/get-secret (secret)
    "Retrieve `secret' using the `ic/secret-cmd' program."
    (nth 0 (process-lines ic/secret-cmd secret)))
#+END_SRC

** Customize
I don't like =customize= so discard all settings.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat (temporary-file-directory) "emacs-customize-settings"))
#+END_SRC

** Tab Width
Use 4 spaces by default for tabs. Note: these are commonly overwritten in mode
hooks.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Font setup
Setup both monospaced and non-monospaced fonts.

Some good variable spaced fonts:
- Century Schoolbook L
- TeX Gyre Pagella
- Utopia
- Caladea
- Gentium
- Gillius ADF
- URW Palladio L

#+BEGIN_SRC emacs-lisp
  (defvar ic/fixed-pitch-font '("DejaVu Sans Mono" . 11.0))
  (defvar ic/variable-pitch-font '("Gillius ADF" . 13.0))

  (defun ic/setup-fonts (fixed-pitch-font variable-pitch-font)
    (let ((fixed-family (car fixed-pitch-font))
          (fixed-height (truncate (* 10 (cdr fixed-pitch-font))))
          (variable-family (car variable-pitch-font))
          (variable-height (truncate (* 10 (cdr variable-pitch-font)))))
      (custom-theme-set-faces
       'user
       `(default ((t (:family ,fixed-family :height ,fixed-height))))
       `(fixed-pitch ((t (:family ,fixed-family :height ,fixed-height))))
       `(variable-pitch ((t (:family ,variable-family :height ,variable-height)))))))
  (ic/setup-fonts ic/fixed-pitch-font ic/variable-pitch-font)
#+END_SRC

** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to
use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].

#+BEGIN_SRC emacs-lisp
  (defun ic/save-and-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (save-buffer)
    (ic/kill-buffer-and-window))

  (defun ic/maybe-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (save-buffers-kill-emacs)))

  (defun ic/kill-buffer-and-window ()
    "Destroy the current buffer and window, if it was the sole window also delete
  the frame."
    (interactive)
    (condition-case-unless-debug nil
        (kill-buffer-and-window)
      (error
       (spacemacs/frame-killer))))

  ;; from spacemacs
  (defun spacemacs/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error
       (make-frame-invisible nil 1))))
#+END_SRC

Set evil ex commands:
#+BEGIN_SRC emacs-lisp
  (evil-ex-define-cmd "q[uit]" 'ic/kill-buffer-and-window)
  (evil-ex-define-cmd "wq" 'ic/save-and-kill-buffer-and-window)
#+END_SRC

And some =leader-key= bindings:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "q"
   "" '(nil :which-key "quit")
   "q" 'spacemacs/frame-killer
   "Q" 'ic/maybe-kill-emacs)
#+END_SRC

** Frame title
Set the frame title to something meaningful.

#+BEGIN_SRC emacs-lisp
  (defun ic/short-persp-name ()
    "Return a shortened name for currently active perspective. Returns `nil'
  when `persp-mode' not enabled."
    ;; we guard calls to `get-frame-persp' and `safe-persp-name' behind a
    ;; check for `\'persp-mode' so shutup the compiler about unknown functions.
    (eval-when-compile
      (unless (fboundp 'get-frame-persp)
        (defun get-frame-persp ()))
      (unless (fboundp 'safe-persp-name)
        (defun safe-persp-name (_))))
    (when (and (boundp 'persp-mode) (get-frame-persp))
      (let ((name (safe-persp-name (get-frame-persp))))
        (concat " <"
                (if (file-directory-p name)
                    (file-name-nondirectory (directory-file-name name))
                  name)
                "> "))))

  (setq frame-title-format
        '((:eval (buffer-name (window-buffer (minibuffer-selected-window))))
          (:eval (ic/short-persp-name))))

#+END_SRC

** Spelling
When typing in insert mode I want to hit =C-e= to automatically correct the
previous misspelled word.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(insert normal)
   "C-e" #'flyspell-auto-correct-previous-word)
#+END_SRC

** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of
the re-display code so can run only when needed. Lisp implementations such as
=linum= and =nlinum= have to run over an entire window as they can't know which part
of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain
text-heavy modes.
#+BEGIN_SRC emacs-lisp
  (global-linum-mode -1)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also
want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp
  ;; use lines displayed on screen rather than new line characters; so folds work
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 3 ...
  (setq-default display-line-numbers-width 3)
  ;; ... and allow it to shrink :(
  (setq-default display-line-numbers-grow-only nil)
#+END_SRC

I would really like to set =display-line-numbers-grow-only= to =t= so that it only
grows and prevents shrinkage, but it seems there is a significant performance
cost associated with it. I've increased the default width slightly to offset it,
but that will waste a bit more space on small files.

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like
=linum-mode=, instead it uses the =text-area= where the main buffer text is. This
means that anything in the fringe (=display-margin=) now shows up to the left
of the line numbers. I'm not a fan of that, but I guess I'll live with it as
there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of
=display-line-numbers= for more info.

** Web Browser
=firefox=, duh.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program "firefox")
#+END_SRC

** Minibuffer / completion testing (disabled)
:PROPERTIES:
:header-args: :tangle no
:END:

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (defun ic/ignore-marginalia-annotate-binding (&_))
    (advice-add 'marginalia-annotate-binding :override 'ic/ignore-marginalia-annotate-binding)
    (marginalia-mode 1)
    )

#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    ;; (add-to-list 'display-buffer-alist
    ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
    ;;                nil
    ;;                (window-parameters (mode-line-format . none))))

    (add-hook 'embark-post-action-hook #'embark-collect--update-linked)
    ;; (remove-hook 'embark-post-action-hook #'embark-collect--update-linked)

    (add-hook 'minibuffer-setup-hook #'embark-collect-completions)
    ;; (remove-hook 'minibuffer-setup-hook #'embark-collect-completions)

    (defun ic/embark-act-noexit ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'embark-act)))

    :general
    (leader-keys
      "hdb" 'embark-bindings)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-," 'embark-act
     "C-<" 'ic/embark-act-noexit
     "C-." 'embark-become)
    )

#+END_SRC

*** Minibuffer
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'minibuffer-local-map
   "C-w" 'evil-delete-backward-word)

#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :config
    ;; use TAB for previewing
    (setq consult-preview-key (kbd "<tab>"))
    (setq consult-narrow-key "<")

    (defun ic/consult-unfocus-lines ()
      "Reset any current focus from `consult-focus-lines'."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-focus-lines)))

    :general
    (leader-keys
      "bb" 'consult-buffer
      "fb" 'consult-bookmark
      "pi" 'consult-project-imenu
      "ha" 'consult-apropos
      "sf" 'consult-find
      "sL" 'consult-locate
      "sg" 'consult-grep
      "sG" 'consult-git-grep
      "sm" 'consult-multi-occur
      "sr" 'consult-ripgrep
      "su" 'consult-focus-lines
      "sU" 'ic/consult-unfocus-lines
      )

    (general-define-key
     :states '(normal)
     "go" 'consult-outline
     "gh" 'consult-org-heading
     "gi" 'consult-imenu
     "gl" 'consult-line
     )

    )

#+END_SRC

*** Selectrum (not used)
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand nil
    :after (orderless embark)
    :config
    (selectrum-mode 1)

    ;; window should be exactly 20 lines always
    (setq selectrum-max-window-height 20)
    (setq selectrum-fix-vertical-window-height selectrum-max-window-height)

    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (setq selectrum-refine-candidates-function #'orderless-filter)

    ;; when we have an embark collect: only show the current selectrum item
    (defun ic/single-line-selectrum ()
      (when (eq embark-collect--kind :live)
        (with-selected-window (active-minibuffer-window)
          (setq-local selectrum-num-candidates-displayed 1)
          (setq-local selectrum-display-style
                      '(horizontal :before-candidates "[" :after-candidates "]"
                                   :more-candidates "" :candidates-separator "")))))
    (add-hook 'embark-collect-mode-hook #'ic/single-line-selectrum)

    ;; selectrum should have a decoration-less window on the bottom
    (setq selectrum-display-action '(display-buffer-in-side-window
                                     (side . bottom)
                                     (slot . -1)
                                     (window-parameters (mode-line-format . none))))
    )
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t
    :demand t
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :config
    (defun ic/orderless-bang-prefix (pattern _index _total)
      (when (string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))

    (defun ic/orderless-bang-suffix (pattern _index _total)
      (when (string-suffix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 0 -1))))

    (defun ic/orderless-carrot-suffix (pattern _index _total)
      (when (string-suffix-p "^" pattern)
        `(orderless-regexp . ,(concat "^" (substring pattern 0 -1)))))

    (setq completion-styles '(orderless))
    (setq orderless-matching-styles '(orderless-regexp))
    (setq orderless-style-dispatchers '(ic/orderless-bang-prefix
                                        ic/orderless-bang-suffix
                                        ic/orderless-carrot-suffix))
    )
#+END_SRC

** Movement
Some misc functions to support moving around.

#+BEGIN_SRC emacs-lisp
  (defun ic/move-to-outline-dwim ()
    "Prompt for, and move to, an outline heading."
    (interactive)
    (cond ((eq major-mode 'org-mode)
           (ic/org-jump-in-buffer))
          (t
           (message (format "No outline command found for mode `%s'" major-mode)))))
#+END_SRC

* Keybindings
Here we copy the spacemacs keybindings, more or less.

** main
#+BEGIN_SRC emacs-lisp
  (leader-keys
   "TAB" 'evil-switch-to-windows-last-buffer
   "u" 'universal-argument)
#+END_SRC

** normal mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal)
   "go" 'ic/move-to-outline-dwim)
#+END_SRC

** Escape Key
Make  =<escape>= quit as much as possible.

XXX should these go in an override map?

#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map
                 minibuffer-local-must-match-map
                 minibuffer-local-isearch-map)
      "<escape>" 'keyboard-escape-quit)
#+END_SRC

** a :: applications

** b :: buffers
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "b"
   "" '(nil :which-key "buffers")
   "b" 'helm-mini
   "d" 'kill-this-buffer
   "i" 'ibuffer
   "P" 'ic/paste-clipboard-to-buffer
   "R" 'revert-buffer
   "s" 'ic/switch-to-scratch-buffer
   "w" 'read-only-mode
   "Y" 'ic/yank-buffer-to-clipboard)
#+END_SRC

** B :: build

** e :: errors

** E :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys "E" '(nil :which-key "emacs"))
#+END_SRC

** Ep :: Emacs profiler
Profiler bindings.
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "Ep"
   "" '(nil :which-key "emacs profiler")
   "c" #'ic/start-cpu-profiler
   "m" #'ic/start-mem-profiler
   "s" #'profiler-stop
   "r" #'profiler-report)
#+END_SRC

** f :: Files
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "f"
   "" '(nil :which-key "files")
   "b" 'helm-bookmarks
   "c" 'copy-file
   "D" 'delete-current-buffer-file
   "E" 'sudo-edit
   "f" 'helm-find-files
   "L" 'helm-locate-library
   "r" 'helm-recentf
   "R" 'rename-current-buffer-file
   "y" 'ic/yank-current-filename)
#+END_SRC

** fC :: Convert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fC"
   "" '(nil :which-key "convert")
   "d" 'unix-to-dos
   "u" 'dos-to-unix)
#+END_SRC

** fe :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fe"
   "" '(nil :which-key "emacs")
   "i" 'edit-init-file
   "o" 'edit-org-config
   "l" 'helm-locate-library)
#+END_SRC

** g :: git/vc
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "g"
    "" '(nil :which-key "git")
    "i" 'magit-gitignore
    "s" 'magit-status
    "S" 'magit-stage-file
    "U" 'magit-unstage-file
    )
#+END_SRC

** h :: help
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "h"
   "" '(nil :which-key "help")
   "a" 'apropos
   "k" 'which-key-show-top-level
   "i" 'info
   "I" 'helm-info
   "m" 'helm-man-woman)
#+END_SRC

** hd :: help describe
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "hd"
   "" '(nil :which-key "describe")
   "b" 'describe-bindings
   "c" 'describe-char
   "f" 'describe-function
   "K" 'describe-keymap
   "k" 'describe-key
   "l" 'describe-last-keys
   "m" 'describe-mode
   "p" 'describe-package
   "s" 'describe-system-info
   "t" 'describe-theme
   "v" 'describe-variable)
#+END_SRC

** i :: insert

** l :: layouts

** m :: major mode

** p :: projects

** r :: registers

** s :: search

** t :: toggle

** w :: windows
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "w"
   "" '(nil :which-key "windows")
   "=" 'balance-windows
   "d" 'delete-window
   "F" 'make-frame
   "f" 'follow-mode
   "H" 'evil-window-move-far-left
   "h" 'evil-window-left
   "J" 'evil-window-move-very-bottom
   "j" 'evil-window-down
   "K" 'evil-window-move-very-top
   "k" 'evil-window-up
   "L" 'evil-window-move-far-right
   "l" 'evil-window-right
   "m" 'delete-other-windows
   "S" 'split-window-below-and-focus
   "s" 'split-window-below
   "U" 'winner-redo
   "u" 'winner-undo
   "V" 'split-window-right-and-focus
   "v" 'split-window-right
   )
#+END_SRC

** x :: text

