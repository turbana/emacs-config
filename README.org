# -*- lexical-binding: t; -*-
#+TITLE: Emacs Config
#+STARTUP: content

Welcome to my emacs configuration.

* Initial Setup
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

I want to be able to potentially load separate emacs configurations so set the base emacs directory to where the currently loading configuration is.
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory load-file-name))
#+END_SRC

I also want to keep my =user-emacs-directory= somewhat clean, so let's define a few sub directories that we'll try to keep the plethora of emacs files in:
- =user-cache-directory= :: files that contain transient data (history, projectile, etc).
- =user-data-directory= :: files that contain version controlled data (snippets, etc)

#+BEGIN_SRC emacs-lisp
  (defvar user-cache-directory (concat user-emacs-directory "cache/"))
  (defvar user-data-directory (concat user-emacs-directory "data/"))
#+END_SRC

I want my config to be portable between machines. So I'll need some variables to key on for various changes

#+BEGIN_SRC emacs-lisp
  (defconst on-linux (string-equal system-type "gnu/linux"))
  (defconst on-windows (string-equal system-type "windows-nt"))
  (defconst on-mac (string-equal system-type "darwin"))

  ;; at_home/at_work are bash functions defined in ~/.bashrc
  (defconst at-home (= 0 (call-process "bash" nil nil nil "-c" "source ~/.bashrc && at_home")))
  (defconst at-work (= 0 (call-process "bash" nil nil nil "-c" "source ~/.bashrc && at_work")))

  (defun on-host (hostname)
    "Return non-nil when the current system is `hostname'."
    (string-equal (system-name) hostname))

  (defconst on-tablet (on-host "DESKTOP-F6Q3GN2"))
  (defconst on-old-imac (on-host "Michaels-iMac.local"))
  (defconst on-home-windows-desktop (and on-windows (on-host "Fanghorn")))
  (defconst on-home-windows-laptop (on-host "Gladden"))
#+END_SRC

I use emacs server and would prefer all packages to be loaded at once, ahead of time.
#+BEGIN_SRC emacs-lisp
  (setq use-package-always-demand t)
#+END_SRC

* Bootstrap
** Native compilation
I want to make use of the native compilation system introduced in emacs 28.
#+BEGIN_SRC emacs-lisp
  ;; do we have native compilation available?
  (defconst have-native-compilation
    (and (fboundp 'native-comp-available-p)
         (native-comp-available-p)))

  (when have-native-compilation
    ;; don't blast me with (mostly) useless warnings
    (setq native-comp-async-report-warnings-errors nil)
    ;; keep the eln cache tidy
    (setq native-comp-eln-load-path
          (list (concat user-cache-directory "eln-cache/")
                (car (last native-comp-eln-load-path))))
    ;; needed for emacs-29.1
    (setq native-comp-deferred-compilation-deny-list nil))
#+END_SRC
** straight.el
I use =straight.el= for package management so install this early.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integrate =straight.el= with =use-package=.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
#+END_SRC

I want to check in my packages to git so store the version file under =user-data-directory=.
#+BEGIN_SRC emacs-lisp
  (setq straight-profiles `((nil . ,(concat user-data-directory "straight-default.el"))))
#+END_SRC
** org-mode
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org)
#+END_SRC

** async
I use the =async= package in my =init.el= tangling function, so we need to load it early.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC

** init.el
On checking out this repo =init.el= will have temporary code in it to tangle / load this org file (=README.org=), overwriting itself. On this initial run we will have loaded both core =org-mode= and melpa =org-mode= so emit a warning that a restart is needed.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; load core emacs `org-mode', but don't native compile it
  (let ((comp-deferred-compilation nil))
    (require 'org))

  ;; tangle/load our init file
  (let* ((base-dir (file-name-directory load-file-name))
         (org-file (concat base-dir "README.org"))
         (el-file (concat base-dir "init.el")))
    (org-babel-tangle-file org-file el-file)
    ;; on first load we shadow the core emacs org-mode and when trying to quit
    ;; emacs calls the non-existent function `org-clocking-buffer'. Define a dummy
    ;; to allow us to exit cleanly on initial run
    (defun org-clocking-buffer (&rest _))
    (load-file el-file)
    (warn "This is the first load of init.el so core emacs `org-mode' is loaded.
   Restart emacs to use newest version."))
#+END_SRC

We also need to tell =git= to ignore changes to =init.el= so the following command was run:
#+BEGIN_SRC shell :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

Let's also tell emacs where =init.el= lives so packages can find it. =straight.el= requires it for updating packages.
#+BEGIN_SRC emacs-lisp
  (setq user-init-file (concat user-emacs-directory "init.el"))
#+END_SRC

This file (=README.org=) should be tangled into the startup config file (=init.el=) along with compiling (either native or byte). I want that to happen automatically and asynchronously.
#+BEGIN_SRC emacs-lisp
  (defvar ic--tangle-init-async-cookie nil
    "Used to keep track of the async org-tangle process for init.el")

  (defun ic-maybe-tangle-init-file ()
    "Tangle/compile my emacs configuration."
    (let ((org-files (list
                      (expand-file-name "~/src/emacs/README.org")
                      (concat user-emacs-directory "README.org"))))
      (when (member (buffer-file-name) org-files)
        (when (process-live-p ic--tangle-init-async-cookie)
          (kill-process ic--tangle-init-async-cookie))
        (message "Async tangling %s..." (buffer-file-name))
        (setq
         ic--tangle-init-async-cookie
         (async-start
          `(lambda ()
             (require 'ob-tangle)
             (require 'subr-x)
             (let ((start-time (current-time))
                   ;; set to silence messages from `org-babel-tangle-file'.
                   ;; this screws up the async return value on windows :(
                   (inhibit-message t))
               (when-let (ret (org-babel-tangle-file ,(buffer-file-name)
                                                     ,user-init-file))
                 ;; (byte-compile-file ,user-init-file)
                 ;; (when ,have-native-compilation
                 ;;   (native-compile ,user-init-file))
                 (cons ret (float-time (time-since start-time))))))
          `(lambda (ret)
             (unless (consp ret)
               (error "error in org-babel-tangle for %S"
                      ,(buffer-file-name)))
             (message "Tangled %s in %.2f seconds"
                      (caar ret) (cdr ret))))))))

  (add-hook 'after-save-hook 'ic-maybe-tangle-init-file)
#+END_SRC

** meow
Let's give modal editing package a try

*** use-package
#+BEGIN_SRC emacs-lisp
  (use-package meow
    ;; :straight (meow :type git :host github :repo "turbana/meow")
    :ensure t
    :demand t
    :config
    ;; emacs keybind to access local leader map
    (setq emacs-local-leader-prefix "C-?")
    ;; meow keybind alias for local leader map
    (setq meow-local-leader-prefix "/")
    (setq meow-local-leader-insert-prefix "C-/")
    ;; keep the expand hints around a while longer
    (setq meow-expand-hint-remove-delay 3.0)
    ;; start git commits in insert mode
    (add-hook 'git-commit-mode-hook 'meow-insert-mode)
    ;; turn it on, baby
    (meow-global-mode 1))
#+END_SRC
*** Keybinds
**** Core
#+BEGIN_SRC emacs-lisp
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)

  (setq global-leader-map
        (let ((keymap (make-sparse-keymap)))
          (define-key keymap (kbd "c") 'meow-keypad-start)
          (define-key keymap (kbd "g") 'meow-keypad-start)
          (define-key keymap (kbd "h") 'meow-keypad-start)
          (define-key keymap (kbd "m") 'meow-keypad-start)
          (define-key keymap (kbd "x") 'meow-keypad-start)
          keymap))

  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   ;; global leader
   `("SPC" . ,global-leader-map)
   )

  (meow-normal-define-key
   '("1" . meow-1)
   '("2" . meow-2)
   '("3" . meow-3)
   '("4" . meow-4)
   '("5" . meow-5)
   '("6" . meow-6)
   '("7" . meow-7)
   '("8" . meow-8)
   '("9" . meow-9)
   '("0" . meow-0)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   ;; global leader
   `("SPC" . ,global-leader-map)
   ;; local leader
   `(,meow-local-leader-prefix . ,emacs-local-leader-prefix)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . keyboard-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . keyboard-quit))

  ;; local leader in insert mode
  (define-key meow-insert-state-keymap
    (kbd meow-local-leader-insert-prefix)
    (meow--parse-def emacs-local-leader-prefix))
#+END_SRC

**** Digit Keys
I really don't like how the default =meow= bindings put the universal arguments under /SPC/ and the expansion digits are the digits. I want to only hit the digit keys and have a function that just does "the right thing" depending on if we're currently expanding or not.
#+BEGIN_SRC emacs-lisp
  (defmacro def-meow-digit-action (func digit)
    "Create function FUNC that when called will call `meow-expand-DIGIT' when
    expanding, and `meow-digit-argument' otherwise."
    (let ((meow-expand-digit (intern (format "meow-expand-%d" digit))))
      `(defun ,func ()
         (interactive)
         (if (meow-expanding-p)
             (,meow-expand-digit)
           (meow-digit-argument)))))

  (defun meow-expanding-p ()
    "Return non-NIL when `meow' is either expanding or selecting text."
    (meow--selection-type))

  (def-meow-digit-action meow-1 1)
  (def-meow-digit-action meow-2 2)
  (def-meow-digit-action meow-3 3)
  (def-meow-digit-action meow-4 4)
  (def-meow-digit-action meow-5 5)
  (def-meow-digit-action meow-6 6)
  (def-meow-digit-action meow-7 7)
  (def-meow-digit-action meow-8 8)
  (def-meow-digit-action meow-9 9)
  (def-meow-digit-action meow-0 0)

  ;; don't need the macro anymore
  (fmakunbound 'def-meow-digit-action)
#+END_SRC

** Theme
Load my custom theme early so if we have errors emacs still looks pretty.

#+BEGIN_SRC emacs-lisp
  (use-package themian-theme
    :straight (themian :type git :host github :repo "turbana/themian")
    :init
    (setq themian-org-mode-variable-pitch t)
    (setq themian-org-mode-emphasize-todo nil)
    (setq themian--show-unknowns nil)
    (let ((fixed
           (cond (on-old-imac
                  '("Iosevka Extended" 160 ultra-light))
                 (on-home-windows-laptop
                  '("Iosevka Extended" 140 normal))
                 (t
                  '("Iosevka Extended" 110 normal))))
          (variable
           (cond (on-old-imac
                  '("DejaVu Sans ExtraLight" 150 ultra-light))
                 (on-home-windows-laptop
                  '("DejaVu Sans Condensed" 140 normal))
                 (t
                  '("DejaVu Sans Condensed" 120 normal)))))
      (set-face-attribute 'default nil :family (nth 0 fixed)
                          :height (nth 1 fixed) :weight (nth 2 fixed))
      (set-face-attribute 'fixed-pitch nil :family (nth 0 fixed)
                          :height (nth 1 fixed) :weight (nth 2 fixed))
      (set-face-attribute 'variable-pitch nil :family (nth 0 variable)
                          :height (nth 1 variable) :weight (nth 2 variable)))

    (defun themian--reload-dark-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-dark 'dark)
      (load-theme 'themian-dark t))
    (defun themian--reload-light-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-light 'light)
      (load-theme 'themian-light t))

    :config
    (defun themian--load-theme-on-frame-create (frame)
      "Enable default theme on FRAME, but only when graphics are enabled and no
    other theme is loaded."
      (with-selected-frame frame
        (when (and (display-graphic-p)
                   (not custom-enabled-themes))
          (load-theme
           (if (or on-tablet on-old-imac)
               'themian-light
             'themian-dark)
           t))))

    ;; use extra `tree-sitter' faces
    (customize-set-variable 'treesit-font-lock-level 4)
    ;; set initial theme on frame create
    (add-hook 'after-make-frame-functions 'themian--load-theme-on-frame-create)
    ;; try to set initial theme now
    (themian--load-theme-on-frame-create (selected-frame))

    ;; HACK
    ;; something is using quote as a face, not sure where that is, but define it
    ;; here to silence the warnings in *Messages*
    (defface quote nil "not sure what this is")

    ;; don't use `general' to bind keys as it's not loaded yet
    :bind (("M-<f5>" . 'themian--reload-dark-theme)
           ("M-<f6>" . 'themian--reload-light-theme)))
#+END_SRC

** Debugging
*** Tracing
Some functions to trace the changing of variables.

#+BEGIN_SRC emacs-lisp
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
    (ic/watch-variable-call-func symbol 'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (sym value operation buffer)
      (let ((msg (ic//watch-variable-format sym buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol 'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol 'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (sym value operation buffer)
        (when (member operation ops)
          (apply func (list sym value operation buffer))))
      (add-variable-watcher symbol 'watch-change)
      (push (cons symbol 'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC

*** Profiling
Some profiler keybindings.

#+BEGIN_SRC emacs-lisp
  (require 'profiler)

  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))

  (defun ic/start-cpu-mem-profiler ()
    "Start both CPU and memory profiling."
    (interactive)
    (profiler-start 'cpu+mem))
#+END_SRC

** Keybinds
I like the spacemacs idea of having both a leader key (=SPC=) and a (mode-specific) local leader key (=,=). The leader key being how all the major functions are accessed, such as buffers/files/windows/etc. Where the local leader is how mode-specific functions are accessed, such as =org-mode= bindings or =mu4e=, etc.

There are a few things I don't care for though: I don't need emacs bindings, nor do I want access to the local leader map from the leader map (=SPC m=). So I want a dual leader key system without the cruft.

The package =general.el= makes all of the above rather simple. Here we ensure it's installed and activated with =:demand t=. We then setup two =definers=, one for the leader key (=leader-keys=) and one for the local leader key (=local-leader-keys=). Both =definers= define their keys in the =general-override-mode-map= keymap. This keymap has a high priority, but only when =general-override-mode= is active so ensure it is with =(general-override-mode 1)=.

=NOTE=: some of the above is outdated (as of [2021-12-12 Sun]). See [[*meow][meow]] for more details.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    ;; ensure `general-override-mode-map' is active
    (general-override-mode 1)
  
    ;; create leader (SPC) definer
    (general-create-definer leader-keys
      :keymaps 'global-leader-map
      ;; :prefix "SPC"
      )
  
    ;; create local leader (,) definer
    (general-create-definer local-leader-keys
      :keymaps 'general-override-mode-map
      :prefix emacs-local-leader-prefix))
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
      :config
      (which-key-mode 1))
#+END_SRC
** Secrets
I keep certain information out of source control: email addresses, account information, etc. I have a small python program called =secret= that I use to retrieve these secrets, let's expose that to emacs.

#+BEGIN_SRC emacs-lisp
  (defvar ic/secret-cmd "secret")

  (defun ic/get-secret (secret)
    "Retrieve `secret' using the `ic/secret-cmd' program."
    (nth 0 (process-lines ic/secret-cmd secret)))
#+END_SRC

* Packages
** all-the-icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** auto-dim-other-buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for color customization.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
      :config
      (setq auto-dim-other-buffers-dim-on-focus-out t)
      (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
      ;; ensure org-indent face is properly hidden
      (when (boundp 'auto-dim-other-buffers-affected-faces)
        (push '(org-indent . auto-dim-other-buffers-hide-face)
              auto-dim-other-buffers-affected-faces))
      (auto-dim-other-buffers-mode t))
#+END_SRC

** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :config
    (setq company-tooltip-align-annotations t)
    (setq company-abort-on-unique-match t)
    (setq company-tooltip-width-grow-only t)
  
    :general
    (general-define-key
     :keymaps 'company-active-map
     "C-l" 'company-show-location
     "C-h" 'company-show-doc-buffer
     "C-w" 'backward-kill-word
     "C-s" 'company-search-candidates
     "C-f" 'company-filter-candidates
     ))
#+END_SRC

** compat
#+BEGIN_SRC emacs-lisp
  (use-package compat)
  (require 'compat)
#+END_SRC

** emacsql
#+BEGIN_SRC emacs-lisp
    (use-package emacsql)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    )
#+END_SRC

** haskell-mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :demand t)
#+END_SRC

** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :demand t
    :bind (:map global-map
           ([remap describe-function] . #'helpful-callable)
           ([remap describe-variable] . #'helpful-variable)
           ([remap describe-key] . #'helpful-key)))
#+END_SRC

** json
#+BEGIN_SRC emacs-lisp
  (use-package json)
#+END_SRC

** kbd-mode
This is to support editing =KMonad= =.*kbd= files.
#+BEGIN_SRC emacs-lisp
  (use-package kbd-mode
    :straight (kbd-mode type git :host github :repo "kmonad/kbd-mode")
    )
#+END_SRC

** lsp
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :demand t
    :commands lsp

    :init
    ;; keep session file tidy
    (setq lsp-session-file (concat user-cache-directory "lsp-session-v1"))
    ;; don't show the top breadcrumbs by default
    (setq lsp-headerline-breadcrumb-enable nil)
    ;; keep more log data
    (setq lsp-log-max 10000)
    ;; setup c# lsp server
    ;; (setq lsp-csharp-server-path
    ;;       (cond (on-home-windows-desktop-wsl
    ;;              (executable-find "omnisharp"))))

    :hook
    ((lsp-mode . lsp-enable-which-key-integration)
     (csharp-mode . lsp)
     (json-ts-mode . lsp)
     (tsx-ts-mode . lsp)
     (typescript-ts-mode . lsp))

    :general
    (local-leader-keys
      :keymaps 'prog-mode-map
      "l" lsp-command-map))
#+END_SRC

** lsp-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui)
#+END_SRC

** magit
For some reason on the Surface Pro 4 tablet we need to manually load =magit-section= before loading =magit= proper.
#+BEGIN_SRC emacs-lisp
  (when (or on-tablet on-old-imac)
    (use-package magit-section))
#+END_SRC

Main =magit= config.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    ;; don't use magit's default key bindings
    (setq magit-define-global-key-bindings nil)

    ;; I run emacs on my home windows desktop under MSYS2, but magit guesses that
    ;; it's running under CYGWIN, which screws up filename expansion
    (when on-home-windows-desktop
      (defun ic-magit-maybe-override-cygwin-paths (f &rest args)
        "Call `f' with correct binding of `magit-cygwin-mount-points'.

  When running emacs on windows under MSYS2, we need `magit' to rewrite local file
      paths using `magit-cygwin-mount-points', but ignore it for remote paths."
        (let ((magit-cygwin-mount-points
               (and (not (file-remote-p default-directory))
                    magit-cygwin-mount-points)))
          (apply f args)))
      (advice-add 'magit-expand-git-file-name :around
                  #'ic-magit-maybe-override-cygwin-paths)
      (advice-add 'magit-convert-filename-for-git :around
                  #'ic-magit-maybe-override-cygwin-paths))

    :general
    (general-define-key
     "C-x g" 'magit-status)
    (general-define-key
     :keymaps 'magit-section-mode-map
     "<up>" 'magit-section-backward
     "<down>" 'magit-section-forward)
    :bind (:map magit-status-mode-map
           ("x" . #'magit-discard)))
#+END_SRC

** mu4e
#+BEGIN_SRC emacs-lisp :noweb yes :tangle no
  (use-package mu4e
    :after org
    :straight ( :type git :host github :repo "djcb/mu"
		:build "./autogen.sh"
		;; :build nil
		;; :build (("./autogen.sh") ("make"))
		;; :pre-build "./autogen.sh"
		;; :build "make"
		:files (:defaults "build/mu4e/*.el"))
    :config
    <<mu4e-config>>
    )
#+END_SRC

*** config
:PROPERTIES:
:header-args: :noweb-ref mu4e-config :tangle no
:END:

**** Initial setup
First, setup mu.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-maildir "~/mail")
  ;; (setq mu4e-mu-binary (concat user-emacs-directory "straight/repos/mu/build/mu/mu"))
  ;; (setq mu4e-mu-binary (executable-find "mu"))
  (setq mu4e-get-mail-command "offlineimap -o")
#+END_SRC

We can only check our gmail accounts once every 10 minutes or we risk a ban.
#+BEGIN_QUOTE
Make sure your mail app isn't set to check for new email too frequently. If your mail app checks for new messages more than once every 10 minutes, the app‚Äôs access to your account could be blocked.
#+END_QUOTE
More information [[https://support.google.com/mail/answer/7126229?p=BadCredentials&visit_id=636868193607658613-796315695&rd=2#cantsignin][here]].

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mu4e-update-interval 600)
#+END_SRC

Then, some common variables.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; show images inline
  (setq mu4e-view-show-images t)
  (setq mu4e-show-images t)
  ;; show addresses rather than names
  (setq mu4e-view-show-addresses t)
  ;; strip html when viewing emails...
  (setq mu4e-html2text-command "w3m -dump -T text/html")
  ;; ... and allow me to open an email in a browser
  (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser) t)
  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
  ;; quit silently
  (setq mu4e-confirm-quit nil)
#+END_SRC

**** Header view
Have a slightly different layout when showing an inbox.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; different date format
  (setq mu4e-headers-date-format "%Y-%m-%d %H:%M")
  (setq mu4e-headers-time-format "%H:%M")
  ;; set header fields
  (setq mu4e-headers-fields
        '((:maildir    . 12)
          (:flags      . 6)
          (:human-date . 17)
          (:from       . 20)
          (:subject    . nil)))
#+END_SRC

I like having each section of the header view it's own color. The following code was taken from [[https://github.com/djcb/mu/issues/1355][github]] and modified to my taste.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun mu4e~headers-line-apply-flag-face (msg line)
    line)

  (defun mu4e~headers-field-apply-basic-properties (msg field val width)
    (case field
      (:subject
       (propertize
        (concat
         (mu4e~headers-thread-prefix (mu4e-message-field msg :thread))
         (truncate-string-to-width val 600))
        'face
        (let ((flags (mu4e-message-field msg :flags))
              (spam (string-suffix-p "spam" (mu4e-message-field msg :maildir)))
              (trash (string-suffix-p "trash" (mu4e-message-field msg :maildir))))
          (cond
           ((or (memq 'trashed flags) spam trash) 'mu4e-trashed-face)
           ((memq 'draft flags) 'mu4e-draft-face)
           ((or (memq 'unread flags) (memq 'new flags))
            'mu4e-unread-face)
           ((memq 'flagged flags) 'mu4e-flagged-face)
           ((memq 'replied flags) 'mu4e-replied-face)
           ((memq 'passed flags) 'mu4e-forwarded-face)
           (t 'mu4e-header-face)))))
      (:thread-subject
       (propertize
        (mu4e~headers-thread-subject msg)
        'face 'font-lock-doc-face))
      ((:maildir :path :message-id)
       (let* ((parts (split-string val "/")))
         (concat (propertize "/"
                             'face 'mu4e-maildirs-extension-maildir-face)
                 (propertize (cadr parts)
                             'face 'mu4e-maildirs-extension-maildir-hl-face)
                 (propertize (concat "/" (mapconcat #'identity (cddr parts) "/"))
                             'face 'mu4e-maildirs-extension-maildir-face)))
       )
      ((:to :from :cc :bcc)
       (propertize
        (mu4e~headers-contact-str val)
        'face 'mu4e-contact-face))
      (:from-or-to (mu4e~headers-from-or-to msg))
      (:date
       (propertize
        (format-time-string mu4e-headers-date-format val)
        'face 'org-sexp-date))
      (:mailing-list (mu4e~headers-mailing-list val))
      (:human-date
       (propertize
        (mu4e~headers-human-date msg)
        'help-echo (format-time-string
                    mu4e-headers-long-date-format
                    (mu4e-msg-field msg :date))
        'face 'org-sexp-date))
      (:flags
       (propertize (mu4e~headers-flags-str val)
                   'help-echo (format "%S" val)
                   'face 'mu4e-url-number-face))
      (:tags
       (propertize
        (mapconcat 'identity val ", ")
        'face 'font-lock-builtin-face))
      (:size (mu4e-display-size val))
      (t (mu4e~headers-custom-field msg field))))
#+END_SRC

**** Contexts
We need a helper function to determine what context we're in automatically.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; taken from: https://notanumber.io/2016-10-03/better-email-with-mu4e/
  (defun ic//mu4e-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
            ;; If rx is a list, try each one for a match
            (or (ic//mu4e-maildir-matches msg (car rx))
                (ic//mu4e-maildir-matches msg (cdr rx)))
          ;; Not a list, check rx
          (string-match rx (mu4e-message-field msg :maildir)))))
#+END_SRC

Choose the first context when starting =mu4e=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq mu4e-context-policy 'pick-first)
#+END_SRC

Now some account specific setup
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; This sets up my two different context for my personal and work emails.
  (setq mu4e-contexts
        (let ((professional-address (ic/get-secret "email.professional.address"))
              (professional-name (ic/get-secret "email.professional.name"))
              (personal-address (ic/get-secret "email.personal.address"))
              (personal-name (ic/get-secret "email.personal.name")))
          `( ,(make-mu4e-context
               :name "professional-gmail"
               :enter-func `(lambda () (mu4e-message (concat "Switch to " ,professional-address)))
               :match-func (lambda (msg)
                             (when msg
                               (ic//mu4e-maildir-matches msg "^/pro/")))
               :leave-func (lambda () (mu4e-clear-caches))
               :vars `((user-mail-address     . ,professional-address)
                       (user-full-name        . ,professional-name)
                       (mu4e-sent-folder      . "/pro/sent")
                       (mu4e-drafts-folder    . "/pro/drafts")
                       (mu4e-trash-folder     . "/pro/trash")
                       (mu4e-refile-folder    . "/pro/archive")
                       (smtpmail-smtp-user    . ,professional-address)
                       ))
              ,(make-mu4e-context
                :name "home-gmail"
                :enter-func (lambda () `(mu4e-message (concat "Switch to " ,personal-address)))
                :match-func (lambda (msg)
                              (when msg
                                (ic//mu4e-maildir-matches msg "^/per/")))
                :leave-func (lambda () (mu4e-clear-caches))
                :vars `((user-mail-address     . ,personal-address)
                        (user-full-name        . ,personal-name)
                        (mu4e-sent-folder      . "/per/sent")
                        (mu4e-drafts-folder    . "/per/drafts")
                        (mu4e-trash-folder     . "/per/trash")
                        (mu4e-refile-folder    . "/per/archive")
                        (smtpmail-smtp-user    . ,personal-address)
                        )))))
#+END_SRC

**** Sending mail
Some default gmail setup.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq message-send-mail-function 'smtpmail-send-it)
  (setq smtpmail-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-service 587)
#+END_SRC

For each of our gmail accounts we need an application specific password to use to send email. To create one go [[https://security.google.com/settings/u/1/security/apppasswords][here]]. Be sure and insert a line into =~/.authinfo.gpg= for each account with the following format:
#+BEGIN_EXAMPLE
machine smtp.gmail.com port 587 login <user>@gmail.com password <account password>
#+END_EXAMPLE

**** Composing
Message composing should be done in =org-mode= format and sent as html.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; compose under the current context
  (setq mu4e-compose-context-policy nil)

  ;; automatically flow text when sending
  (setq mu4e-compose-format-flowed t)

  ;; enter org-mode when composing
  (add-hook 'message-mode-hook 'org-mu4e-compose-org-mode)

  ;; export org-mode into html when sending
  (setq org-mu4e-convert-to-html t)

  ;; (setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC

**** Bookmarks
Setup some bookmarks
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; clear default bookmarks
  (setq mu4e-bookmarks nil)

  ;; all inboxes
  (mu4e-bookmark-define
   "maildir:/per/inbox or maildir:/pro/inbox"
   "All Inboxes"
   ?i)

  ;; all unread
  (mu4e-bookmark-define
   (concat "flag:unread"
           " and not maildir:/per/spam"
           " and not maildir:/per/trash"
           " and not maildir:/pro/spam"
           " and not maildir:/pro/trash")
   "All Unread"
   ?u)

  ;; sent
  (mu4e-bookmark-define
   "maildir:/per/sent or maildir:/pro/sent"
   "Sent mail"
   ?s)

  ;; spam
  (mu4e-bookmark-define
   "maildir:/per/spam or maildir:/pro/spam"
   "Spam mail"
   ?S)
#+END_SRC

**** Org capture
I want to be able to save a TODO item for the current email and archive in one swoop.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun ic//org-capture-email ()
    "For email at point: call `org-capture' and mark for refile."
    (interactive)
    (org-store-link nil)
    (org-capture nil "r")
    (cond ((eq major-mode 'mu4e-headers-mode)
           (mu4e-headers-mark-for-refile))
          ((eq major-mode 'mu4e-view-mode)
           (mu4e-view-mark-for-refile))))
#+END_SRC

**** Keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key mu4e-headers-mode-map "a" #'mu4e-headers-mark-for-refile)
  (define-key mu4e-headers-mode-map "r" #'ic//org-capture-email)

  (define-key mu4e-view-mode-map "a" #'mu4e-view-mark-for-refile)
  (define-key mu4e-view-mode-map "r" #'ic//org-capture-email)
#+END_SRC
** org-appear
=org-appear= toggles the visibility of hidden =org-mode= elements. I would like them to only be visible while in =meow-mode='s insert mode. =org-appear= lets us manually toggle it's state, so setup a hook to toggle it when we're in an =org-mode= buffer and we enter/exit insert mode.

#+BEGIN_SRC emacs-lisp
  (use-package org-appear
    :after (org)
    :init
    (defun ic//setup-org-appear-hooks ()
      (org-appear-mode 1)
      (add-hook 'meow-insert-enter-hook #'org-appear-manual-start nil t)
      (add-hook 'meow-insert-exit-hook #'org-appear-manual-stop nil t))
    :config
    (setq org-appear-autolinks t)
    (setq org-appear-autoentities t)
    (setq org-appear-trigger 'manual)
    :hook (org-mode . ic//setup-org-appear-hooks))
#+END_SRC

** org-bullets
Let's have some fancy heading bullets.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("‚Ä¢"))
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-caldav
I'd like to keep my google calendar in-sync with =org-mode=.
#+BEGIN_SRC emacs-lisp
  (use-package oauth2)
  ;; (use-package oauth2-auto)

  (use-package org-caldav
    :demand t
    :after (org oauth2 org-roam)
    :config
    ;; setup calendar from secrets file
    ;; (setq org-caldav-url (ic/get-secret "calendar.personal.url"))
    ;; (setq org-caldav-calendar-id (ic/get-secret "calendar.personal.id"))

    ;; new calendar entries should go in the right inbox
    ;; (setq org-caldav-inbox org-default-notes-file)
    ;; use zetian task list for the calendar
    ;; (setq org-caldav-files (list (concat org-roam-directory "special/zetian-tasks.org")))
    ;; (setq org-caldav-files org-id-files)

    ;; testing
    (setq org-caldav-oauth2-client-id (ic/get-secret "email.personal.client-id"))
    (setq org-caldav-oauth2-client-secret (ic/get-secret "email.personal.client-secret"))
    (setq org-caldav-url 'google)
    (setq org-caldav-calendar-id (ic/get-secret "email.personal.calendar-id"))
    (setq org-caldav-inbox "~/org/test.org")
    (setq org-caldav-files nil)


    ;; setup authinfo
    (setq epg-pinentry-mode 'loopback)
    (setq plstore-cache-passphrase-for-symmetric-encryption t)

    ;; work mostly silently, but ask before deleting org entries
    (setq org-caldav-show-sync-results nil)
    (setq org-caldav-delete-org-entries 'ask)
    (setq org-caldav-delete-calendar-entries 'always)

    ;; setup how timestamps are used and silence extra title prefixes
    (setq org-icalendar-use-scheduled
          '(event-if-todo-not-done event-if-not-todo))
    (setq org-icalendar-use-deadline
          '(todo-due event-if-todo-not-done event-if-not-todo))
    (setq org-icalendar-scheduled-summary-prefix "")
    (setq org-icalendar-deadline-summary-prefix "")
    (setq org-icalendar-include-sexps nil)

    ;; `org-id-files' seems to get polluted with both expanded and non-expanded
    ;; file names, so clean it up before calling `org-caldav-sync'.
    (defun ic/calendar-sync ()
      "Sync org calendars with cloud."
      (interactive)
      ;; do not evaluate babel blocks
      (let ((org-export-use-babel nil))
        ;; update roam files
        (org-roam-update-org-id-locations)
        ;; clean up `org-id-files'
        (ic/clean-org-id-locations)
        ;; do the actual sync
        (org-caldav-sync)))
    )

  (defun ic/clean-org-id-locations ()
    "Expand and de-duplicate all entries `org-id-files'."
    (interactive)
    (let ((new-list))
      (dolist (elem org-id-files)
        (add-to-list 'new-list (expand-file-name elem)))
      (setq org-id-files new-list)
      (setq org-caldav-files new-list)))

  (defun ic/org-lint-all-files ()
    "Run `org-lint' across all `org-id-files'."
    (interactive)
    (ic/clean-org-id-locations)
    (save-excursion
      (let ((error-count 0))
        (dolist (file org-id-files)
          (with-current-buffer (find-file-noselect file)
            (when-let (lints (org-lint))
              (setq error-count (1+ error-count))
              (message "Lint error(s) in %s" file)
              (dolist (lint lints)
                (message (nth 2 (append (cadr lint) nil)))))))
        (when (> 0 error-count)
          (message "%d files with lint errors"))
        error-count)))
#+END_SRC

On first run we need to setup authentication.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq epg-pinentry-mode 'loopback)
  (setq plstore-cache-passphrase-for-symmetric-encryption t)

  (setq oauth2-auto-plstore "/home/ian/src/emacs/oauth2.plstore")
  (setq oauth2-auto-google-client-id (ic/get-secret "email.personal.client-id"))
  (setq oauth2-auto-google-client-secret (ic/get-secret "email.personal.client-secret"))
  (oauth2-auto-access-token-sync "turbana@gmail.com" 'google)
#+END_SRC
** org-gcal
I'd like to keep my google calendar in-sync with =org-mode=.
#+BEGIN_SRC emacs-lisp
  (use-package org-gcal
    :init
    (setq org-gcal-client-id (ic/get-secret "email.personal.client-id"))
    (setq org-gcal-client-secret (ic/get-secret "email.personal.client-secret"))
    ;; (org-gcal-reload-client-id-secret)
    (setq org-gcal-fetch-file-alist
          `((,(ic/get-secret "email.personal.calendar-id") . "~/src/roam/special/zetian-calendar.org"
             )))

    ;; auto delete org headings when deleted from gcal
    (setq org-gcal-remove-cancelled-events t)
    (setq org-gcal-remove-cancelled-events t)
  
    ;; don't reprompt for credentials
    (setq epg-pinentry-mode 'loopback)
    (setq plstore-cache-passphrase-for-symmetric-encryption t)
    )
#+END_SRC

** org-mode
=org-mode= is a large part of my daily emacs usage so it takes a large amount of my configuration as well. Let's go...

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
      :mode (("\\.org$" . org-mode))
      :ensure org-plus-contrib
      :after (all-the-icons yasnippet)
      :config
      <<org-config>>
      :general
      <<org-keybinds>>
      )
#+END_SRC

*** org-config
:PROPERTIES:
:header-args: :noweb-ref org-config :tangle no
:END:

**** Basic Setup
#+BEGIN_SRC emacs-lisp
  (defvar org-home-file "~/org/home/home.org"
    "Default org file for home related items.")
  (defvar org-work-file "~/org/work.org"
    "Default org file for work related items.")
  (defvar org-default-file (if at-home org-home-file org-work-file)
    "Default org file.")
  (defvar org-bookmark-file "~/src/roam/special/bookmarks.org")
  (setq org-default-notes-file
        (if at-home "~/org/home/inbox.org" "~/org/inbox.org"))
  (setq org-agenda-files
        (append (list ;;org-default-file
                      org-default-notes-file)
                (if at-home
                    '("~/org/home/mobile/inbox.org"
                      "~/org/home/jobs.org"))
                ;; (directory-files "~/org" t "\\.org$")
                ))
  (setq org-archive-location "%s_archive::")
  (add-hook 'org-mode-hook #'turn-on-auto-revert-mode)
#+END_SRC

**** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp
  (defun ic/org-jump ()
    "Jump to an `org-refile-targets' heading."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-refile)))

  (defun ic/org-jump-in-buffer ()
    "Jump to a heading in the current buffer."
    (interactive)
    ;; `org-refile-targets' needs to be dynamically bound
    (defvar org-refile-targets)
    (let ((org-refile-targets '((nil :maxlevel . 999))))
      (ic/org-jump)))
#+END_SRC

**** Normal mode navigation
#+BEGIN_SRC emacs-lisp
  (defun ic/outline-current-heading-or-up ()
    "When point is on an org-mode heading: move to parent heading;
  otherwise: move to current heading."
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'outline-up-heading
                          'outline-previous-heading)))

  (defun ic/outline-current-heading-or-backward ()
    "when point is on an org-mode heading: move to previous heading;
  otherwise: move to previous heading"
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'org-backward-heading-same-level
                          'outline-previous-heading)))
#+END_SRC

**** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented nil)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation nil)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)

  (defun ic//org-set-fill-column ()
    "Sets `fill-column' for `org-mode' buffers."
    (setq fill-column 100))
  (add-hook 'org-mode-hook 'ic//org-set-fill-column)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: \Delta{}v \ne \pi
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t)
  ;; don't use super/sub-scripts as they mess with headings
  (setq org-pretty-entities-include-sub-superscripts nil)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Because =org-mode= is mostly prose use =buffer-face-mode= (along with setting the face =org-default=) to get variable pitch text. See the variable =themian-force-fixed-faces= for a list of faces that will remain fixed.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'buffer-face-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]]. See [[*org-bullets][org-bullets]] setup as well.

Here are some fancy symbols:
‚ö´‚Ä¢‚¶æ‚¶ø‚Äî‚¨é‚åÑ‚åµ‚Ü¥‚§µ‚Üò‚Üì‚Ü∑ÓèáÓóèÓÉÉÔÑÄÔÑÅÓåõÓåñÓóáÔÉâÔÑÇÔÖÇÔÖâ‚îÖüÖêüÖëüÖí‚åµ

The font matters so here is some in fixed width:
=‚ö´‚Ä¢‚¶æ‚¶ø‚Äî‚¨é‚åÑ‚åµ‚Ü¥‚§µ‚Üò‚Üì‚Ü∑ÓèáÓóèÓÉÉÔÑÄÔÑÅÓåõÓåñÓóáÔÉâÔÑÇÔÖÇÔÖâ‚îÖüÖêüÖëüÖí‚åµ=

#+BEGIN_SRC emacs-lisp
  (defun ic/first-displayable-char (chars)
    "Return the first displayable char from CHARS, `nil' otherwise. This function
  ignores the terminal coding system."
    ;; Because the terminal coding system is used with `char-displayable-p' it
    ;; might return non-nil when there is no (graphical) font that can display the
    ;; char. So first disable the terminal coding system and re-enable after we
    ;; check the char.
    (let ((current-coding-system (terminal-coding-system)))
      (set-terminal-coding-system nil)
      (unwind-protect
          (-first 'char-displayable-p chars)
        (set-terminal-coding-system current-coding-system))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defvar ic/org-list-icon ?-)

  (defun ic//setup-org-mode-icons ()
    "Setup pretty org-mode icons.
  Should be run as part of `server-after-make-frame-hook' as the frame needs to be
    loaded for some of the icons to be loaded."
    (setq org-ellipsis
          (concat " "
                  (char-to-string
                   (ic/first-displayable-char
                    '(?ÔÑá ?‚Ä¶ ?v)))))
    (setq ic/org-list-icon
          (ic/first-displayable-char `(?‚Äî ,ic/org-list-icon))))
  (add-hook 'server-after-make-frame-hook #'ic//setup-org-mode-icons)

  (defvar ic/org-mode-symbol-mapping
    '(
      ;; priority cookies are nice, but *very* inconsistent
      ("[#A]" ?ÔÇ™ ?‚í∂)
      ("[#B]" ?ÔÑπ ?‚í∑)
      ("[#C]" ?ÔÅñ ?‚í∏)
      ("[#D]" ?ÔÑ∫ ??)
      ("[#E]" ?ÔÇ´ ??)
      ("[ ]" ?ÔÉà)
      ("[X]" ?ÔÖä)
      ("[x]" ?ÔÖä)
      ("[-]" ?ÔÖÜ)
      ("#+BEGIN_SRC" ?Œª)
      ("#+END_SRC"   ?∆õ)
      ("CLOSED:"    ?Ôâ¥)
      ("SCHEDULED:" ?ÔÑ≥)
      ("DEADLINE:"  ?Ôâ≥)
      ("TODO"      ?ÔÉ≥ ?ÔÉà)
      ("NEXT"      ?ÔÄÖ ?ÔÉæ)
      ("DONE"      ?Ôá∂ ?ÔÖä)
      ("WAIT"      ?ÔÄó)
      ("CANCELLED" ?Ôá∏)
      ))

  ;; replace certain org-mode text with symbols
  (defun ic/org-mode-pretty-symbols ()
    "Enable `prettify-symbols-mode' and set `prettify-symbols-alist' for certain
  `org-mode' symbols."
    ;; skip over symbol when editing as these should rarely be manually edited
    (setq prettify-symbols-unprettify-at-point nil)
    (setq prettify-symbols-alist
          (mapcar (lambda (m)
                    (cons (car m)
                          (funcall #'ic/first-displayable-char (cdr m))))
                  ic/org-mode-symbol-mapping))
    (prettify-symbols-mode 1))

  (add-hook 'org-mode-hook #'ic/org-mode-pretty-symbols)
  (add-hook 'org-agenda-mode-hook #'ic/org-mode-pretty-symbols)
#+END_SRC

Change list items to symbol. Code inspired by [[https://emacs.stackexchange.com/questions/59882/how-to-change-color-of-font-lock-add-keywords][this]] stack exchange question.
#+BEGIN_SRC emacs-lisp
  (require 'org-element)

  (defun ic/org-match-unordered-list (bound)
    "Match an `org-mode' unordered list item."
    (and
     (re-search-forward "^ *\\(-\\|\\+\\) " bound t)
     (save-match-data
       (save-excursion
         (goto-char (match-end 1))
         (eq (org-element-type (org-element-at-point)) 'item)))))

  (defun ic/org-match-ordered-list (bound)
    "Match an `org-mode' ordered list item."
    (and
     (re-search-forward (rx bol (zero-or-more " ")
                            (group (one-or-more (any digit))
                                   (or "." ")"))
                            " ")
                        bound t)
     (save-match-data
       (save-excursion
         (goto-char (match-end 1))
         (eq (org-element-type (org-element-at-point)) 'item)))))

  (defun ic/org-match-check-boxes (bound)
    "Math an `org-mode' check box item."
    (re-search-forward
     (rx bol (* space) "- "
         (group "[" (any " xX-") "]"))
     bound t))

  (defun ic/setup-org-mode-pretties ()
    "Add some special font locking to display "
    (let ((list-display-str
           (propertize (char-to-string ic/org-list-icon)
                       'face 'themian-weak)))
      (font-lock-add-keywords
       nil
       `(;; change list dashes
         (ic/org-match-unordered-list
          (1 '(face default display ,list-display-str)))
         ;; change ordered lists
         (ic/org-match-ordered-list
          (1 '(face themian-weak)))
         ;; change check boxes
         (ic/org-match-check-boxes
          (1 '(face themian-weak) append))
         )
       t)))

  (add-hook 'org-mode-hook #'ic/setup-org-mode-pretties)
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

**** Priorities
I like to have 5 priorities (A-E) with (C) being the default
#+BEGIN_SRC emacs-lisp
  (setq org-priority-highest ?A)
  (setq org-priority-lowest ?E)
  (setq org-priority-default ?C)
#+END_SRC

Color priorities based on how important they are.
#+BEGIN_SRC emacs-lisp
  (setq org-priority-faces '((?A . '(:inherit (themian-error org-priority)))
                             (?B . '(:inherit (themian-warning org-priority)))
                             (?C . 'org-priority)
                             (?D . '(:inherit (themian-item org-priority)))
                             (?E . '(:inherit (themian-weak org-priority)))))
#+END_SRC

**** org-src
Use current window to edit =org-src= blocks. Indent the source blocks with 2 spaces.
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

**** org-babel
Allow us to execute various languages in =org-src= blocks.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (shell . t)))
#+END_SRC

**** org-persist
Not sure what this is exactly, but let's ensure it keeps it's data files tidy.
#+BEGIN_SRC emacs-lisp
  (setq org-persist-directory (concat user-cache-directory "org-persist/"))
#+END_SRC

**** Agenda
***** Setup
#+BEGIN_SRC emacs-lisp
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(
          ;; work agenda
          ("w" "Work Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil))))
           ((org-agenda-tag-filter-preset '("-HOME" "-archive"))))

          ("W" "Work agenda today"
           ((agenda "" ((org-agenda-span 'week))))
           ((org-agenda-tag-filter-preset '("-HOME" "-archive"))))

          ;; home agenda
          ;; ("h" "Home agenda"
          ;;  (
          ;;   (tags "PRIORITY=\"A\""
          ;;         ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
          ;;          (org-agenda-overriding-header
          ;;           (concat (ic/life-goals-formatted)
          ;;                   "\nToday's Tasks:"))))
          ;;   (agenda "" nil)
          ;;   (tags "refile"
          ;;         ((org-agenda-overriding-header "\nRefile Tasks:")
          ;;          (org-tags-match-list-sublevels nil)))
          ;;   )
          ;;  ((org-agenda-tag-filter-preset '("+HOME" "-archive")))
          ;;  ("~/test.html"))

          ("H" "Home agenda today"
           ((agenda "" ((org-agenda-span 'day))))
           ((org-agenda-tag-filter-preset '("+HOME" "-archive"))))

          ("d" "Deadlines"
           ((todo ""
                  ((org-agenda-overriding-header "")
                   (org-agenda-tag-filter-preset '("-archive"))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'notdeadline))
                   (org-agenda-sorting-strategy
                    '((agenda scheduled-up priority-down effort-down)))
                   (org-super-agenda-date-format "%Y-%m-%d %A")
                   (org-super-agenda-groups
                    '((:name "Overdue" :deadline past)
                      (:name "Today" :deadline today)
                      ;; NOTE: I should be able to use :transformer to
                      ;; change the group title string, but it doesn't seem
                      ;; to work
                      (:auto-map (lambda (item)
                                   (format-time-string
                                    org-super-agenda-date-format
                                    (org-time-string-to-time
                                     (org-entry-get nil "DEADLINE")))))))))))

          ;; archives
          ("a" . "Archiving")
          ("ah" "Home archive"
           ((tags "+HOME-noarchive/DONE|CANCELLED|APPLIED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ("aw" "Work archive"
           ((tags "-HOME-noarchive+TIMESTAMP_IA<=\"<-2w>\"/DONE|CANCELLED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))

          ;; test org-super-agenda
          ("h" "super test (home)"
           ((todo ""
                  ((org-agenda-overriding-header "")
                   (org-super-agenda-groups
                    '((:name "Refile"
                             :tag "refile")
                      (:name "Overdue"
                             :deadline past
                             :scheduled past)
                      (:name "Needs deadline"
                             :and (:priority "A" :deadline nil))
                      (:name "Needs scheduling"
                             :and (:priority "A" :scheduled nil)
                             :and (:priority "B" :scheduled nil))
                      (:name "Due Today"
                             :deadline today)
                      ;; (:name "Scheduled Today"
                      ;;        :date today
                      ;;        :scheduled today
                      ;;        :deadline today)
                      (:discard (:anything t))))))
            (agenda ""
                    ((org-agenda-overriding-header "")
                     (org-agenda-span 'week)))
            ;; (todo ""
            ;;       ((org-agenda-overriding-header "")
            ;;        (org-super-agenda-groups
            ;;         '(
            ;;           (:name "Scheduled Today"
            ;;                  :date today
            ;;                  :scheduled today
            ;;                  :deadline today)
            ;;           (:name "Upcoming"
            ;;                  :auto-planning t)
            ;;           (:discard (:anything t))))))
            )
           ((org-agenda-tag-filter-preset '("+HOME" "-archive"))))
          ))
#+END_SRC

***** Appearance
#+BEGIN_SRC emacs-lisp
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)

  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)

  ;; show weekly agenda by default
  (setq org-agenda-span 'week)

  ;; don't have a separator between agenda sections
  (setq org-agenda-compact-blocks t)

  ;; setup format
  (setq org-agenda-prefix-format " %i %4e %?-12t% s")
  (setq org-super-agenda-date-format "%A, %e %B %Y")

  (setq org-agenda-sorting-strategy
        '((agenda habit-down time-up priority-down category-keep)
          (todo tag-up priority-down alpha-up)
          (tags priority-down category-keep)
          (search category-keep)))

  ;; highlight the current line
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)

  ;; hide some tags I mostly use for filtering only
  (setq org-agenda-hide-tags-regexp "\\(HOME\\|WORK\\|agenda\\|_type_task\\|_type_event\\)")

  ;; show all future repeating entries
  (setq org-agenda-show-future-repeats nil)
#+END_SRC

***** Test icons (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disable
  ;;; DISABLED ;;;

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (setq tab-width 2)
  ;;                                         ; (setq tab-stop-list '(2 3 5))
  ;;             ))

  (require 'all-the-icons)

  ;; (let ((font (find-font (font-spec :name "FontAwesome"))))
  ;;   (font-put font :spacing 100)
  ;;   (font-get font :spacing)
  ;;   )

  (defun ic/org-agenda-icon (family icon-name)
    (let* ((icon-func (cdr (assoc family
                                  '((ati . all-the-icons-alltheicon)
                                    (faicon . all-the-icons-faicon)
                                    (fileicon . all-the-icons-fileicon)
                                    (octicon . all-the-icons-octicon)
                                    (wicon . all-the-icons-wicon)))))
           (face-func (cdr (assoc family
                                  '((ati . all-the-icons-icon-family)
                                    (faicon . all-the-icons-faicon-family)
                                    (fileicon . all-the-icons-fileicon-family)
                                    (octicon . all-the-icons-octicon-family)
                                    (wicon . all-the-icons-wicon-family)))))
           (all-the-icons-scale-factor 1.0)
           ;; (font (concat (apply face-func nil) ":spacing=monospace"))
           (font "FontAwesomeMono:spacing=100")
           ;; (font (apply face-func nil))
           (face `(:family ,font :height 1.0))
           ;; (icon (apply icon-func (list icon-name :face 'default)))
           (icon (cdr (assoc icon-name all-the-icons-data/fa-icon-alist)))
           )
      (propertize icon
                  'face face
                  'font-lock-face face
                  ;; 'display '(space :width (50) :height 7)
                  ;; 'display '(space-width 5)
                  'rear-nonsticky t
                  )
      ))

  ;; (ic/org-agenda-icon 'faicon "calendar")

  ;; (let ((icon (all-the-icons-faicon "calendar")))
  ;;   (string-to-char icon))

  ;; setup agenda icons
  (setq org-agenda-category-icon-alist
        (let ((icon-mapping
               '(
                 ("annivers" faicon "calendar")
                 ("birthdays" faicon "birthday-cake")
                 ("chores" faicon "home")
                 ("computer" faicon "keyboard-o")
                 ("cpu" faicon "fax")
                 ("holidays" faicon "calendar-o")
                 ("cooking" faicon "cutlery")
                 ("health" faicon "heartbeat")
                 ("jobs" faicon "building-o")
                 ("life" faicon "male")
                 )))
          (mapcar (lambda (config)
                    ;; `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)) :width (50)) nil nil :ascent center :mask heuristic))
                    `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)))))
                  icon-mapping
                  )))

  (defun blaenk/set-char-widths (alist)
    (while (char-table-parent char-width-table)
      (setq char-width-table (char-table-parent char-width-table)))
    (dolist (pair alist)
      (let ((width (car pair))
            (chars (cdr pair))
            (table (make-char-table nil)))
        (dolist (char chars)
          (set-char-table-range table char width))
        (optimize-char-table table)
        (set-char-table-parent table char-width-table)
        (setq char-width-table table))))

  (defconst old-char-width-table char-width-table)

  ;; argument is an alist of width and list of RANGEs,
  ;; which is the same as the RANGE that set-char-table-range accepts
  ;; (blaenk/set-char-widths
  ;;  `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;           ,(string-to-char (all-the-icons-faicon "home"))
  ;;           ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;           ))))

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (message "set-char-widths")
  ;;             (blaenk/set-char-widths
  ;;              `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;                       ,(string-to-char (all-the-icons-faicon "home"))
  ;;                       ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;                       ))))
  ;;                            ))




  ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping
  ;;              '(
  ;;                ("annivers" (all-the-icons-faicon "calendar"))
  ;;                ("birthdays" (all-the-icons-faicon "birthday-cake"))
  ;;                ("chores" (all-the-icons-faicon "home"))
  ;;                ("computer" (all-the-icons-faicon "keyboard-o"))
  ;;                ("cpu" (all-the-icons-faicon "fax"))
  ;;                ("holidays" (all-the-icons-faicon "calendar-o"))
  ;;                ("cooking" (all-the-icons-faicon "cutlery"))
  ;;                ("health" (all-the-icons-faicon "heartbeat"))
  ;;                ("jobs" (all-the-icons-faicon "building-o"))
  ;;                ("life" (all-the-icons-faicon "male"))
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (car config))
  ;;                         (icon (apply (caadr config) (cdadr config))))
  ;;                     `(,category (list ,icon :width (100)) nil nil :ascent center :mask heuristic :width (100))))
  ;;                 icon-mapping)))



  ;; ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping-alist
  ;;              '(
  ;;                ("annivers" 'faicon "calendar")
  ;;                ("birthdays" 'faicon "birthday-cake")
  ;;                ("chores" 'faicon "home")
  ;;                ("computer" 'faicon "keyboard-o")
  ;;                ("cpu" 'faicon "fax")
  ;;                ("holidays" 'faicon "calendar-o")
  ;;                ("cooking" 'faicon "cutlery")
  ;;                ("health" 'faicon "heartbeat")
  ;;                ("jobs" 'faicon "building-o")
  ;;                ("life" 'faicon "male")
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (first config))
  ;;                         (icon-family (second config))
  ;;                         (icon-name (third config))
  ;;                         (ati-family-alist
  ;;                          '(('ati . all-the-icons-alltheicon)
  ;;                            ('faicon . all-the-icons-faicon)
  ;;                            ('fileicon . all-the-icons-fileicon)
  ;;                            ('octicon . all-the-icons-octicon)
  ;;                            ('wicon . all-the-icons-wicon))))
  ;;                 `(,category (list ,(apply (cdr (assoc icon-family ati-family-alist)) (list icon-name :height 0.9 :v-adjust 0))) nil nil :ascent center :mask heuristic)))
  ;;                   icon-mapping-alist)))
#+END_SRC

***** Functions
****** Open agenda
I want to open the correct agenda (home/work) automatically.
#+BEGIN_SRC emacs-lisp
  (defun ic-open-org-agenda ()
    "Open the correct org agenda based on location (home/work)."
    (interactive)
    (cond (at-home (org-agenda nil "h"))
          (at-work (org-agenda nil "w"))
          (t (org-agenda))))
#+END_SRC

****** Stuck Projects
I have a somewhat loose definition of what constitutes a project. I consider any org heading a project if:
- It has a todo state and none of it's ancestors do
- It has one or more immediate children with todo states

Furthermore I consider a stuck project:
- A project with no descendants having a NEXT todo state

#+BEGIN_SRC emacs-lisp
  (defun ic/org-is-active-task-p (&optional state)
    "Returns `t' if the current task is a member of
  `org-not-done-keywords'. When specified, use STATE as the active
  state, defaulting to `org-not-done-keywords'."
    (member (org-get-todo-state)
            (if state (list state) org-not-done-keywords)))

  (defun ic/org-any-active-parent-p ()
    "Return `t' if any parent task is an active task."
    (save-excursion
      (widen)
      (let (active-parent)
        (while (and (not active-parent)
                    (org-up-heading-safe))
          (when (ic/org-is-active-task-p)
            (setq active-parent t)))
        active-parent)))

  (defun ic/org-any-active-children-p (&optional state)
    "Return `t' when any descendant is an active task. When
    specified, use STATE as the active state, defaulting to
    `org-not-done-keywords'."
    (save-excursion
      (let ((subtree-end (save-excursion
                           (org-end-of-subtree t)))
            (child-regex (format "^\\*\\{%d,\\} "
                                 (+ 1 (org-current-level))))
            active-child)
        (while (and (not active-child)
                    (re-search-forward child-regex
                                       subtree-end t))
          (when (ic/org-is-active-task-p state)
            (setq active-child t)))
        active-child)))

  (defun ic/org-is-project-p ()
    "Return `t' when the current task is considered a project."
    (and (ic/org-is-active-task-p)
         (not (ic/org-any-active-parent-p))
         (ic/org-any-active-children-p)))

  (defun ic/org-is-stuck-project-p ()
    "Return `t' when the current task is considered a stuck
  project."
    (and (ic/org-is-project-p)
         (not (ic/org-any-active-children-p "NEXT"))))

  (defun ic/org-skip-nonstuck-projects ()
    (let ((debug-on-error t))
      (save-excursion
        (widen)
        (unless (ic/org-is-stuck-project-p)
          (or (outline-next-heading) (point-max))))))
#+END_SRC

**** Habits
#+BEGIN_SRC emacs-lisp
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 4)
  (setq org-habit-graph-column 50)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today nil)
  (setq org-habit-today-glyph ?@)
  (setq org-habit-completed-glyph ?*)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC

**** Todo
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies nil)
#+END_SRC

**** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC

**** Capture
***** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO [#C] %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("T" "test org-protocol" entry (file org-default-notes-file)
           "* TODO %:description\n%U\n\n#+begin_quote\n%:initial\n#+end_quote\n/From: [[%:link][here]]./\n\n%?"
           :immediate-finish t
           )
          ("r" "reply" entry (file org-default-notes-file)
           "* TODO Reply to %:from on %:subject\nSCHEDULED: %t\n%u\n%a\n"
           :immediate-finish t
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("b" "books")
          ("bp" "pleasure" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bP" "pleasure (already read)" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("be" "enrichment" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bE" "enrichment (already read)" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("bt" "technical" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bT" "technical (already read)" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")
          
          ;; org-protocol handlers
          ;; Note: `ic//captured-*' variables are bound in `zetian-protocol-bookmark'.
          ("B" "bookmark" entry (file org-bookmark-file)
           "* [[%(identity ic//captured-url)][%(identity ic//captured-title)]] :%^g:\n%(concat ic//captured-body \"\n\")"
           :immediate-finish t)
          ))
#+END_SRC

***** Books
I want a system to pull in book information (isbn, authors, etc) based on a search query and generate an =org-mode= item.

****** Open Library
As =Goodreads= is no longer offering API access I had to research where to pull down book information. [[https://openlibrary.org/][OpenLibrary]] seems to be the best option currently. So let's create some functions to query it for book information.

First, we need some variables defined:
#+BEGIN_SRC emacs-lisp
  (defconst ic/openlibrary-base-endpoint
    "http://openlibrary.org")

  (defvar ic/openlibrary-max-results 100
    "Maximum results requested from OpenLibrary.")

  (defvar ic/openlibrary--use-cached-data nil
    "Store results from OpenLibrary in cache?")

  (defvar ic/openlibrary--query-string ""
    "Query string to search OpenLibrary for. Internal use only.")
#+END_SRC

We'll need some functions to query =OpenLibrary= and parse the results. We can get most of the data from the search query, only missing the description found in the =Work=, so we can make that call only when needed (after selecting an item in helm).
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--request (url &optional args)
    (let (result)
      (request
        url
        :params args
        :parser 'json-read
        :sync t
        :timeout 10
        :error (cl-function
                (lambda (&key error-thrown &allow-other-keys)
                  (error "error fetching (%s): %s"
                         url
                         (cdr error-thrown))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (setq result data))))
      result))
#+END_SRC

Now we'll need a function to take the raw data returned from =OpenLibrary= and translate it into a format more useful to us.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-search-results (data)
    "Take DATA in OpenLibrary search.json format and parse it into a list of
  ALISTs."
    (mapcar
     (lambda (doc)
       (cl-flet*
           ((to-list (vec) (append vec nil))
            (get (attr &optional alist) (assoc-default attr (or alist doc)))
            (get-list (attr &optional alist) (to-list (get attr (or alist doc))))
            (get-first (attr &optional alist) (car (get-list attr (or alist doc)))))
         `((title . ,(get 'title))
           (query-title . ,(s-replace-regexp " " "+" (get 'title)))
           (ol-work-id . ,(get 'key))
           (ol-author-ids . ,(get-list 'author_key))
           (edition-count . ,(get 'edition_count))
           (first-year-published . ,(get 'first_publish_year))
           (pages-median . ,(get 'number_of_pages_median))
           (public-scan . ,(not (eq (get 'public_scan_b) ':json-false)))
           (authors . ,(get-list 'author_name))
           (goodreads-id . ,(get-first 'id_goodreads))
           (librarything-id . ,(get-first 'id_librarything)))))
     (assoc-default 'docs data)))
#+END_SRC

Now, make another call to =LibraryThing= and check for =Work= data to add in.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--add-work-data (doc)
    "Query OpenLibrary for the work contained in DOC and add in any needed data."
    (let* ((data (ic/openlibrary--request
                  (concat "http://openlibrary.org"
                          (assoc-default 'ol-work-id doc)
                          ".json")))
           (desc-raw (assoc-default 'description data))
           (desc-value (if (eq (type-of desc-raw) 'cons)
                           (assoc-default 'value desc-raw)
                         desc-raw))
           (desc-clean (if desc-value
                           (replace-regexp-in-string
                            ;; OL links in [title](link format)
                            "\\[\\(.*\\)](\\(.*\\))"
                            ;; replace with org-mode format
                            "[[\\2][\\1]]"
                            ;; remove windows new lines
                            (replace-regexp-in-string "\u000d" "" desc-value))
                         nil)))
      (cons (cons 'description desc-clean)
            doc)))
#+END_SRC

Finally, we can put all that together into one supporting function.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary-search (query)
    "Run QUERY against OpenLibrary and return results as a list of association
  lists."
    (ic/openlibrary--parse-search-results
     (ic/openlibrary--request
      (concat ic/openlibrary-base-endpoint "/search.json")
      `(("q" . ,(split-string query " " t))
        ("limit" . ,ic/openlibrary-max-results)
        ("mode" . "everything")))))
#+END_SRC

****** TODO Helm
/need to rewrite against completing-read/
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary-helm-find-book ()
    "Prompt user for query string to search OpenLibrary, then display helm buffer
  to select book. Returns an ALIST with OpenLibrary data."
    (interactive)
    (error "helm not installed")
    (setq ic/openlibrary--query-string
          (read-from-minibuffer "Search OpenLibrary: "))
    (helm :sources
          (helm-build-sync-source
              (format "OpenLibrary (%s)" ic/openlibrary--query-string)
            :candidates 'ic/openlibrary--helm-candidates
            :candidate-number-limit ic/openlibrary-max-results
            :fuzzy-match t
            :coerce 'ic/openlibrary--add-work-data)
          :buffer "*helm openlibrary*"))
#+END_SRC

Now we need a function to query the search page from =OpenLibrary=. It uses the global variable =ic/openlibrary--query-string= to determine the query.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--helm-candidates ()
    "Searches OpenLibrary for `ic/openlibrary--query-string', returning data in
  `((DISPLAY . DATA) ...)' format for use as a helm source."
    (mapcar 'ic/openlibrary--parse-helm-format
            (ic/openlibrary--parse-search-results
             (ic/openlibrary--request
              (concat ic/openlibrary-base-endpoint "/search.json")
              `(("q" . ,(split-string ic/openlibrary--query-string " " t))
                ("limit" . ,ic/openlibrary-max-results)
                ("mode" . "everything"))))))
#+END_SRC

Finally, we need a function to take the data from =OpenLibrary= and return it in a (pretty) format that =helm= will use to display to the user.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-helm-format (doc)
    "Take data in OpenLibrary format and return in `(DISPLAY . DATA)' format
  needed for helm."
    (cons
     (concat (propertize (assoc-default 'title doc) 'face 'helm-ol-title)
             (propertize " :: " 'face 'helm-ol-separator)
             (propertize (string-join (assoc-default 'authors doc) ", ")
                         'face 'helm-ol-author)
             (propertize " [" 'face 'helm-ol-separator)
             (format "%s" (assoc-default 'first-year-published doc))
             (propertize "] -- " 'face 'helm-ol-separator)
             (propertize (format "%s editions" (assoc-default 'edition-count doc))
                         'face 'helm-ol-editions))
     doc))
#+END_SRC

****** completing-read
Now let's use =completing-read= to lookup a book.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--lookup-work (works olid)
    "Given a list of association lists in WORKS, return the alist with 'ol-word-id
  equal to OLID."
    (when works
      (if (equal (cdr (assoc 'ol-work-id (car works)))
                 olid)
          (car works)
        (ic/openlibrary--lookup-work (cdr works) olid))))

  (defun ic/openlibrary-find-book (&optional query results)
    (interactive)
    (let* ((query (or query (read-from-minibuffer "Search OpenLibrary: ")))
           (results (or results (ic/openlibrary-search query)))
           (titles (mapcar (lambda (work) (alist-get 'title work))
                           results)))
      (ic/openlibrary--lookup-work
       results
       (completing-read
        (format "Search OpenLibrary (%s): " query)
        (lambda (str pred action)
          (if (eq action 'metadata)
              `(metadata
                (annotation-function
                 . ,(lambda (cand)
                      (let ((work
                             (ic/openlibrary--lookup-work
                              results cand)))
                        (format " by %s [%d] %s {%s %s %s}"
                                (alist-get 'authors work)
                                (alist-get 'first-year-published work)
                                (if-let ((editions (alist-get 'edition-count
                                                              work)))
                                    (format "%d editions" editions)
                                  "")
                                (alist-get 'ol-work-id work)
                                (alist-get 'goodreads-id work)
                                (alist-get 'librarything-id work))))))
            (complete-with-action action titles str pred)))))))

  (defun ic/openlibrary-find-book (&optional query results)
    (interactive)
    (let* ((query (or query (read-from-minibuffer "Search OpenLibrary: ")))
           (results (or results (ic/openlibrary-search query)))
           (collection
            (mapcar
             (lambda (work)
               (format "%s by %s [%s] %s"
                       (alist-get 'title work)
                       (or (and (alist-get 'authors work)
                                (string-join (alist-get 'authors work) " & "))
                           "?")
                       (or (alist-get 'first-year-published work) "?")
                       (alist-get 'ol-work-id work)))
             results))
           (selected (completing-read
                      (format "Search OpenLibrary (%s): " query)
                      collection))
           (olid (car (last (split-string selected " ")))))
      (ic/openlibrary--lookup-work results olid)))
#+END_SRC

****** Capture
Now, we need a function that takes the data from =OpenLibrary= and generates an =org-mode= element for us to use.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-capture-book (&optional already-read)
    "`org-capture' task for a new book. Prompts the user for a query string to
  search OpenLibrary against and generate an `org-mode' element from the resulting
    data."
    (let* ((result "")
           (doc (ic/openlibrary-find-book)))
      (cl-flet* ((add (fmt &rest args)
                      (when (-all? 'identity args)
                        (setq result (concat result
                                             (apply 'format fmt args))))))
        (add "* %s %s :: %s [%s]\n"
             (if already-read "DONE" "TODO")
             (assoc-default 'title doc)
             (string-join (assoc-default 'authors doc) ", ")
             (assoc-default 'first-year-published doc))
        (add ":PROPERTIES:\n")
        (add ":TITLE: %s\n" (assoc-default 'title doc))
        (add ":AUTHORS: %S\n" (assoc-default 'authors doc))
        (add ":PAGES_MEDIAN: %s\n" (assoc-default 'pages-median doc))
        (add ":FIRST_YEAR_PUBLISHED: %s\n" (assoc-default 'first-year-published doc))
        (add ":PUBLIC_SCAN: %s\n" (assoc-default 'public-scan doc))
        (add ":OL_AUTHOR_IDS: %S\n" (assoc-default 'ol-author-ids doc))
        (add ":OL_WORK_ID: %s\n" (assoc-default 'ol-work-id doc))
        (add ":GOODREADS_ID: %s\n" (assoc-default 'goodreads-id doc))
        (add ":LIBRARYTHING_ID: %s\n" (assoc-default 'librarything-id doc))
        (add ":END:\n")
        (add "%%u\n\n")
        (add "#+BEGIN_QUOTE\n%s\n#+END_QUOTE\n\n" (assoc-default 'description doc))
        (add "** Links\n")
        (add "- [[http://openlibrary.org%s][OpenLibrary]]\n"
             (assoc-default 'ol-work-id doc))
        (dolist (tuple (-zip-pair (assoc-default 'authors doc)
                                  (assoc-default 'ol-author-ids doc)))
          (add "- [[http://openlibrary.org/authors/%s][OpenLibrary - %s]]\n"
               (cdr tuple) (car tuple)))
        (add (concat "- [[https://librarything.com"
                     (if-let (id (assoc-default 'librarything-id doc))
                         (format "/work/%s" id)
                       (format "/search.php?search=%s"
                               (assoc-default 'query-title doc)))
                     "][LibraryThing]]\n"))
        (when (assoc-default 'public-scan doc)
          (add (concat "- [[https://www.gutenberg.org/ebooks/search/?query=%s]"
                     "[Project Gutenberg]]\n")
             (assoc-default 'query-title doc)))
        (add "- [[https://www.overdrive.com/search?q=%s][Overdrive]]\n"
             (assoc-default 'query-title doc))
        (add (concat "- [[https://goodreads.com"
                     (if-let (id (assoc-default 'goodreads-id doc))
                         (format "/book/show/%s" id)
                       (format "/search?q=%s&search_type=books"
                               (assoc-default 'query-title doc)))
                     "][Goodreads]]\n"))
        (add "- [[https://amazon.com/s?k=%s][Amazon]]\n"
             (assoc-default 'query-title doc))
        (add "\n")
        (add "** Notes\n\n"))
      result))


  (defun ic/org-capture-book-read ()
    "Same as `ic/org-capture-book', but mark entry as DONE instead."
    (ic/org-capture-book t))
#+END_SRC

****** TODO Faces
/does this really need to be tied to helm?/

I like my =helm= searches to be pretty, so let's define some faces to use for that.
#+BEGIN_SRC emacs-lisp
  (defface helm-ol-title nil
    "Face used for OpenLibrary titles in a helm buffer.")

  (defface helm-ol-author nil
    "Face used for OpenLibrary authors in a helm buffer.")

  (defface helm-ol-editions nil
    "Face used for OpenLibrary edition counts in a helm buffer.")

  (defface helm-ol-seperator nil
    "Face used for OpenLibrary seperators in a helm buffer.")
#+END_SRC

***** Full Frame
The standard =org-capture= behavior is to split the window before capturing a task. When this is started from outside emacs a random buffer occupies half the frame. What I want is the capture buffer to take the full frame when starting the capture from outside emacs. My window manager will start the capture task with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook where it splits the frame we'll need to advise it to ~(delete-other-windows)~ when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "Org Capture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC

**** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disabled
  (require 'org-clock)

  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  ;; persist open clocks
  (setq org-clock-persist-file (concat user-cache-directory "org-clock-save.el"))
  (org-clock-persistence-insinuate)

  (defun ic/org-clock-jump-to-current-clock ()
    "Jump to the currently active clock."
    (interactive)
    ;; why isn't this (interactive) already, ugh
    (org-clock-jump-to-current-clock))
#+END_SRC

**** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
#+END_SRC

It would be handy to have a function that would handle =org-mode= style time strings such as =+3d=, =-1w=, etc.
#+BEGIN_SRC emacs-lisp
  (defun ic-parse-org-date-string (time-str &optional next-day-when-no-time)
    "Translate TIME-STR into an emacs encoded time based on `org-read-date-*'
  syntax rules such as: +1d, -3w, etc. When NEXT-DAY-WHEN-NO-TIME is non-nil and
    TIME-STR does not contain a time component then use the next day. Returns nil
    on invalid time string."
    (setq org-time-was-given nil)
    (let* ((org-time (org-read-date-analyze
                      time-str
                      ;; encoded default time
                      (list 0 0 0 0)
                      ;; decoded default time
                      (list 0 0 0 0 0 0 0 0 0)))
           ;; `org-read-date-analyze' will return the default date if it failed to
           ;; parse a valid time string. We check for year 2000 because of the
           ;; following line in `org-read-date-analyze':
           ;;     (when (< year 100) (setq year (+ 2000 year)))
           (bad-time (list 0 0 0 0 0 2000))
           (encoded-time (apply #'encode-time org-time)))
      (cond ((equal org-time bad-time)
             (error "invalid time string: %s" time-str))
            ((or org-time-was-given (not next-day-when-no-time))
             ;; we either specified a time or we don't want to use the following day
             encoded-time)
            (t
             ;; we didn't specify a time and we want to use the *following* day
             (time-add encoded-time (* 24 60 60))))))
#+END_SRC

**** org-id
Keep track of =org-mode= items with a guid. This is required by =zeitan= / =org-roam=.
#+BEGIN_SRC emacs-lisp
  ;; save id locations in a nicer place
  (setq org-id-locations-file (concat user-cache-directory "org-id-locations"))

  (setq org-id-files (append (directory-files "~/org" t "\\.org$")
                             (directory-files "~/org/home" t "\\.org$")
                             (and (boundp 'org-id-files) org-id-files)))
#+END_SRC

**** Code Execution
Don't prompt for code execution if we're in a file in certain locations.

#+BEGIN_SRC emacs-lisp
  (defvar ic/allow-babel-evaluate-directories
        '("~/org" "~/.etc"))

  (defun ic/org-confirm-babel-evaluate (_lang _body)
    (let ((filename (buffer-file-name))
          match)
      (dolist (path ic/allow-babel-evaluate-directories (not match))
        (when (string-prefix-p (expand-file-name path) filename)
          (setq match t)))))

  (setq org-confirm-babel-evaluate #'ic/org-confirm-babel-evaluate)
#+END_SRC

**** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want to see most everything else.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC

**** Snippets
By convention I title most of my snippets ={snippet}>= so I would like the =>= key to try and expand snippets automatically. When no snippet is found a regular =>= should be entered.
#+BEGIN_SRC emacs-lisp
  (defun ic/yas-expand-> ()
    (interactive)
    (insert ">")
    (yas-expand))
#+END_SRC

Based on [[https://emacs.stackexchange.com/questions/29758/yasnippets-and-org-mode-yas-next-field-or-maybe-expand-does-not-expand][this]] stackexchange post =org-mode= binds the tab key in such a way that =yas-snippets= can't use it. So we need the following to allow =TAB= to expand snippets while in =org-mode=.
#+BEGIN_SRC emacs-lisp
  (defun ic/set-org-mode-tab-key ()
    (add-to-list 'org-tab-first-hook 'yas-expand)
    ;; XXX is this needed?
    ;; (general-define-key yas-keymap
    ;;   "<tab>" 'yas-next-field)
    )

  (add-hook 'org-mode-hook 'ic/set-org-mode-tab-key)
#+END_SRC

**** Sorting
I frequently want to sort lists in =org-mode=.

#+BEGIN_SRC emacs-lisp
  (defun ic/org-sort-all-lists (&optional arg)
    "Sort all lists in the current buffer, prompting the user for sort style."
    (interactive "P")
    (save-excursion
      (let ((sorting
             (progn
  		     (message
  		      "Sort plain list: [a]lpha  [n]umeric  [t]ime  [f]unc  [x]checked  A/N/T/F/X means reversed:")
  		     (read-char-exclusive)))
            (with-case (equal arg '(4))))
        (org-element-map (org-element-parse-buffer) '(plain-list)
          (lambda (elem)
            (goto-char (org-element-begin elem))
            (org-sort-list with-case sorting nil nil t))))))
#+END_SRC

**** Insert list item
I want to hit =M-RET= from either insert or normal mode and insert a new list item at the same level as the current item. The new item should also have a checkbox when the current item does.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-insert-item-dwim ()
    "Insert an org item, with optional checkbox, below current item."
    (interactive)
    (cond
     ((org-in-item-p)
      (goto-char (org-in-item-p))
      (org-insert-item (org-at-item-checkbox-p))
      (org-metadown))
     ((org-at-table-p)
      (org-table-insert-row)
      (org-table-move-row-down))))

  (defun ic/org-insert-item-dwim-go-insert-mode ()
    "Call `ic/org-insert-item-dwim' and enter insert mode."
    (interactive)
    (when (ic/org-insert-item-dwim)
      (cond ((fboundp 'meow-insert-mode)
             (meow-insert-mode))
            ((fboundp 'evil-insert)
             (evil-insert 0)))))
#+END_SRC

**** Recurring tasks with checkboxes
When I complete a recurring task that contains checkboxes I want those checkboxes to be reset for the next time.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-todo-repeat-hook #'org-reset-checkbox-state-subtree)
#+END_SRC

**** Weekly Review
#+BEGIN_SRC emacs-lisp
  (defvar ic/weekly-reviews-directory "~/org/home/weekly-reviews")

  (defun ic/org-completed-date (heading)
    "Return the date of completion for HEADING."
    (org-timestamp-format (org-element-property :closed heading)
                          "%s"))

  (defun ic/org-completed-date-< (heading-left heading-right)
    "Return non-nil when the completed date of HEADING-LEFT is earlier than the
  completed date of HEADING-RIGHT."
    (let ((left-ts (ic/org-completed-date heading-left))
          (right-ts (ic/org-completed-date heading-right)))
      (cond ((and left-ts right-ts)
             (string< left-ts right-ts))
            (left-ts t)
            (right-ts nil))))

  (defun ic/org-element-get-link (elem &optional link-title)
    "Get a link (as a string) to the org-element ELEM."
    (let* ((marker (org-element-property :org-marker elem))
           (level (org-element-property :level elem))
           (title (org-element-property :raw-value elem))
           (search (org-with-point-at marker
                     (org-link-heading-search-string)))
           (file (buffer-file-name (marker-buffer marker)))
           (link 
            (format "[[%s][%s]]"
                    (format "file:%s::%s" file search)
                    (or link-title title))))
      (set-text-properties 0 (length link) nil link)
      link))

  (defun ic/weekly-review-items ()
    "Return a string containing all items needed for the weekly review in a form
  for direct insertion into a `yasnippit'."
    (let ((org-files (seq-filter #'file-exists-p
                                 (mapcar #'expand-file-name org-agenda-files)))
          current-date)
      (mapconcat (lambda (heading)
                   (let* ((ts (org-element-property :closed heading))
                          (date (format "%s-%s-%s"
                                        (org-element-property :year-start ts)
                                        (org-element-property :month-start ts)
                                        (org-element-property :day-start ts)))
                          (link (ic/org-element-get-link heading)))
                     (concat
                      (when (not (equal current-date date))
                        (setq current-date date)
                        (format-time-string "%A, %d %B %Y\n"
                                            (org-timestamp-to-time ts)))
                      "- " link)))
                 (org-ql-select org-files
                   '(and (tags "HOME")
                         (not (tags "noarchive"))
                         (todo "DONE" "APPLIED"))
                   :action 'element-with-markers
                   :sort #'ic/org-completed-date-<)
                 "\n")))

  (defun ic/weekly-review ()
    "Create a weekly review `org-mode' buffer with all completed tasks."
    (interactive)
    (let* ((year (format-time-string "%Y"))
           (week (format-time-string "%U"))
           (directory (format "%s/%s" ic/weekly-reviews-directory year))
           (filename (format "%s/weekly-review-%s.org" directory week)))
      (unless (file-directory-p directory)
        (make-directory directory t))
      (when (or (not (file-exists-p filename))
                (yes-or-no-p (format "Weekly review for week %s of %s already exists. Delete and re-create? "
                                     week year)))
        (find-file filename)
        (erase-buffer)
        (org-mode)
        (yas-expand-snippet (yas-lookup-snippet "weekly review"))
        (save-buffer))))
#+END_SRC

**** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/skip-non-archivable-tasks ()
    "Skip tasks that I don't want to archive"
    (or (ic/skip-old-meal-plans)
        (bh/skip-non-archivable-tasks)))


  (defun ic/skip-old-meal-plans ()
    "Skip over a task if it's 1) a meal plan and 2) scheduled before today."
    (save-restriction
      (widen)
      (let* ((tags (org-get-tags))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (scheduled (org-get-scheduled-time (point)))
             (yesterday (* 60 60 24 1))
             ;; HACK we check 24 hours ago rather than previous midnight
             (now (time-subtract (current-time) (seconds-to-time yesterday))))
        (if (and (member "cooking" tags)
                 (member "plan" tags)
                 scheduled
                 (time-less-p scheduled now))
            subtree-end
          nil))))


  (defun ic/org-recipe-publish-to-html (_plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC

*** org-keybinds
:PROPERTIES:
:header-args: :noweb-ref org-keybinds :tangle no
:END:

**** local-leader
Main =local-leader= key binds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "'" 'org-edit-special
    ":" 'org-set-tags-command
    "^" 'org-sort
    "A" 'org-archive-subtree
    "D" 'org-insert-drawer
    "d" 'org-deadline
    "e" 'org-set-effort
    "H" 'org-shiftleft
    "J" 'org-shiftdown
    "K" 'org-shiftup
    "L" 'org-shiftright
    "l" 'org-open-at-point
    "N" 'widen
    "n" 'org-narrow-to-subtree
    "p" 'org-priority
    "P" 'org-set-property
    "r" 'org-refile
    "s" 'org-schedule
    "t" 'org-todo
    "w" 'org-save-all-org-buffers
    )
#+END_SRC

=,C= clocks keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "C"
    "" '(nil :which-key "clocks")
    "i" 'org-clock-in
    "j" 'ic/org-clock-jump-to-current-clock
    "o" 'org-clock-out
    "q" 'org-clock-cancel)
#+END_SRC

=,E= export keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "E"
    "" '(nil :which-key "export")
    "e" 'org-export-dispatch
    "T" 'org-babel-tangle-file
    "t" 'org-babel-tangle)
#+END_SRC

=,S= sort keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "S"
    "" '(nil :which-key "sort")
    "L" 'ic/org-sort-all-lists
    )
#+END_SRC

=,i= insert keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "i"
    "" '(nil :which-key "insert")
    "a" 'org-attach
    "f" 'org-footnote-new
    "l" 'org-insert-link
    "t" 'org-time-stamp-inactive
    "T" 'org-time-stamp
    "s" 'org-download-screenshot
    "y" 'org-download-yank
    )
#+END_SRC

TODO =,T= tables keybinds
#+BEGIN_SRC emacs-lisp

#+END_SRC

**** org-agenda-mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps '(org-agenda-mode-map org-columns-map)
   "e" 'org-agenda-set-effort
   "p" 'org-agenda-priority
   "?" 'org-agenda-filter
   ;; why is is the local leader getting overridden?
   meow-local-leader-prefix (lookup-key org-agenda-mode-map (kbd emacs-local-leader-prefix))
   )

  (local-leader-keys org-agenda-mode-map
    "d" 'org-agenda-deadline
    "e" 'org-agenda-set-effort
    "p" 'org-agenda-priority
    "P" 'org-agenda-set-property
    "r" 'org-agenda-refile
    "s" 'org-agenda-schedule
    "t" 'org-agenda-todo
    )
#+END_SRC

**** org-src
=org-src-mode= bindings:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps 'org-src-mode-map
    "c" '(org-edit-src-exit :which-key "org-edit-src-exit")
    "k" 'org-edit-src-abort
    )
#+END_SRC

**** leader-key
=leader-key= keybinds:
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "o"
    "" '(nil :which-key "org-mode")
    "a" 'org-agenda
    "c" 'org-capture
    "j" 'ic/org-jump-in-buffer
    "J" 'ic/org-jump
    )

  (leader-keys
    :infix "oC"
    "" '(nil :which-key "clocks")
    "f" 'org-clock-modify-effort-estimate
    "i" 'org-clock-in
    "g" 'org-clock-goto
    "o" 'org-clock-out
    "l" 'org-clock-in-last
    "r" 'org-clock-report
    )
#+END_SRC

**** global
global keybinds:
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<f12>" 'ic-open-org-agenda
   "M-<f12>" 'org-clock-goto
   )
#+END_SRC

**** normal mode
Here I have some custom normal mode navigation.
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :keymaps 'org-mode-map

    "<left>"      'ic/outline-current-heading-or-up
    "<up>"        'ic/outline-current-heading-or-backward
    "<down>"      'org-forward-heading-same-level
    "<right>"     'outline-next-visible-heading

    "S-<left>"    'org-promote-subtree
    "S-<up>"      'org-move-subtree-up
    "S-<down>"    'org-move-subtree-down
    "S-<right>"   'org-demote-subtree

    "C-S-<left>"  'org-do-promote
    "C-S-<right>" 'org-do-demote

    "M-<return>" 'ic/org-insert-item-dwim-go-insert-mode
    )
#+END_SRC

**** insert mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps 'org-mode-map
      ">" 'ic/yas-expand->
      "M-<return>" 'ic/org-insert-item-dwim
      )
#+END_SRC

** org-protocol
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

** org-ql
Let's try having a nice search interface for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package org-ql)
#+END_SRC

** org-roam
Most of this config is located under [[*Zetian][Zetian]], but I'll do the initial =use-package= and define the keybinds in here.
#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :demand t
    :requires (org emacsql)
    :init
    (setq org-roam-v2-ack t)
    (setq org-roam-directory (expand-file-name "~/src/roam/"))
    (setq org-roam-db-location
          (concat user-cache-directory "org-roam.db"))
    (setq org-roam-completion-everywhere t)
    (setq org-roam-database-connector 'sqlite-builtin)

    ;; org-id doesn't play well with symlinks, it resolves them by calling
    ;; `file-truename'. This breaks org-roam since files can now live in two
    ;; places: the symlink'd location and the true location. So I want to disable
    ;; following the directory symlinks in `org-id-update-id-locations'. It will
    ;; still resolve file symlinks, but ignore directory symlinks.
    (defun ic/dont-follow-directory-symlinks (fn &rest args)
      "Don't call `file-truename' to resolve symlinks."
      (cl-letf (((symbol-function 'file-truename) #'file-chase-links))
        (apply fn args)))
    (advice-add 'org-id-update-id-locations
                :around #'ic/dont-follow-directory-symlinks)
    
    ;; org-roam closes a database connection prior to emacsql running a finalizer,
    ;; also closing it. This advice will ensure the close only occurs once.
    ;; https://org-roam.discourse.group/t/what-is-responsible-for-this-db-sync-finalizer-failure-message/3567/12
    (defun patch/emacsql-close (connection &rest args)
      "Prevent calling emacsql-close if connection handle is nil."
      (when (oref connection handle)
        t))
    (advice-add 'emacsql-close :before-while #'patch/emacsql-close)
    
    :config
    ;; the org-element cache messes with correct category lookup and seems to
    ;; break org-roam sometimes, so disable it
    (setq org-element-use-cache nil)
    (org-roam-setup)
    (org-roam-db-autosync-mode 1)
    (require 'org-roam-protocol)
    (setq org-id-files
          (seq-uniq (append (org-roam-list-files)
                            (and (boundp 'org-id-files) org-id-files))))

    :bind (("<f2>" . zetian-capture)
           :map global-leader-map
           :prefix "z"
           :prefix-map zetian
           ("b" . org-roam-buffer-toggle)
           ("F" . zetian-select-find)
           ("u" . org-roam-ui-open)
           ("U" . zetian-update-git)
           :prefix "zc"
           :prefix-map zetian-capture-map
           ("c" . zetian-capture)
           :prefix "zcb"
           :prefix-map zetian-capture-books
           ("b" . zetian-capture-book)
           ("p" . zetian-capture-book-pleasure-toread)
           ("P" . zetian-capture-book-pleasure-completed)
           ("e" . zetian-capture-book-enrichment-toread)
           ("E" . zetian-capture-book-enrichment-completed)
           :prefix "zd"
           :prefix-map zetian-database
           ("c" . org-roam-db-clear-all)
           ("d" . org-roam-db-diagnose-node)
           ("s" . org-roam-db-sync)
           :prefix "zf"
           :prefix-map zetian-find
           ("f" . zetian-find-all)
           ("a" . zetian-find-area)
           ("A" . zetian-find-author)
           ("b" . zetian-find-book)
           ("c" . zetian-find-category)
           ("e" . zetian-find-open-event)
           ("g" . zetian-find-random-review)
           ("G" . zetian-find-random-permanent)
           ("l" . zetian-find-link-to)
           ("L" . zetian-find-link-from)
           ;; ("o" . zetian-find-task-open-orphaned)
           ("p" . zetian-find-project)
           ("P" . zetian-find-stuck-project)
           ("r" . zetian-find-review)
           ("s" . zetian-find-state)
           ;; ("S" . zetian-find-strange)
           ("t" . zetian-find-next-task)
           :prefix "zfT"
           :prefix-map zetian-find-tasks
           ("a" . zetian-find-task)
           ;; ("l" . zetian-find-task-open-link)
           ("n" . zetian-find-next-task)
           ("o" . zetian-find-open-task)
           ("p" . zetian-find-next-project-task)
           ("P" . zetian-find-open-project-task)
           ("T" . zetian-find-task)
           :prefix "zi"
           :prefix-map zetian-import
           ("m" . zetian-moonreader-import)
           :prefix "zr"
           :prefix-map zetian-reports
           ("c" . zetian-report-completed-this-week)
           ("C" . zetian-report-completed-last-week)
           ("l" . zetian-lint)
           ("t" . zetian-report-tasks)
           :prefix "zj"
           :prefix-map zetian-journal
           ("j" . zetian-journal-goto-today)
           ("J" . zetian-journal-goto-tomorrow)
           ("m" . zetian-journal-goto-month)
           ("M" . zetian-journal-goto-next-month)
           ("q" . zetian-journal-goto-quarter)
           ("Q" . zetian-journal-goto-next-quarter)
           ("t" . zetian-journal-goto-today)
           ("w" . zetian-journal-goto-week)
           ("W" . zetian-journal-goto-next-week)
           ("y" . zetian-journal-goto-year)
           ("Y" . zetian-journal-goto-next-year)
           ))

  (local-leader-keys 'org-mode-map
    :infix "z"
    "" '(nil :which-key "zetian")
    "c" #'zetian-set-context
    "i" #'zetian-link-insert-immediate
    "I" #'zetian-link-insert-search-immediate
    "l" #'zetian-find-link-to-current
    "L" #'zetian-find-link-from-current
    "R" #'zetian-rename-current
    "s" #'zetian-set-state
    "t" #'zetian-set-tag
    "p" #'zetian-set-project
    )
#+END_SRC

** org-roam-ui
#+BEGIN_SRC emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+END_SRC

** org-super-agenda
#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :config
    ;; start automatically
    (add-hook 'org-agenda-mode-hook 'org-super-agenda-mode)
    ;; don't use a special keymap when over an org-super-agenda header
    (setq org-super-agenda-header-map nil)
    )
#+END_SRC

** org-transclusion
#+BEGIN_SRC emacs-lisp
  (use-package org-transclusion
    :config
    (setq org-transclusion-exclude-elements '(keyword property-drawer))

    ;; (defun ic/org-transclusion-add-background-face (beg end)
    ;;   (put-text-property beg end 'face 'org-block))

    ;; (add-hook 'org-transclusion-after-add-functions
    ;;           #'ic/org-transclusion-add-background-face)
    ;; (remove-hook 'org-transclusion-after-add-functions
    ;;              #'ic/org-transclusion-add-background-face)
    )
#+END_SRC

** projectile
This used to be much more involved, but I found a lot of my project specific code just wasn't all that useful and I'm trying to pare down my config as much as possible, so let's see what a more or less default =projectile= can look like.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand t
    :init
    ;; ensure projectile saves its files in a nice location
    (setq projectile-cache-file
          (concat user-cache-directory "projectile.cache"))
    (setq projectile-known-projects-file
          (concat user-cache-directory "projectile-bookmarks.eld"))

    :config
    (projectile-mode 1)
    (setq projectile-globally-ignored-file-suffixes
          '(
            ;; unity stuff
            ".meta" ".unity" ".asset" ".mat" ".cginc" ".prefab"
            ".renderTexture" ".lighting" ".shadergraph" ".shadersubgraph"
            ".shader" ".sceneWithBuildSettings" ".hlsl" ".vfx"
            ;; images
            ".png" ".xcf" ".jpg" ".jpeg" ".tif"
            ;; fonts
            ".ttf"
            ;; misc
            ".pdf"
            ))
    (setq projectile-indexing-method 'hybrid)

    :general
    (leader-keys
      "p" 'projectile-command-map))
#+END_SRC

** requests
=emacs-request= is a library for making HTTP requests easily.
#+BEGIN_SRC emacs-lisp
  (use-package request)
#+END_SRC

** smartparens
Keep my toe-nail clippings in balance.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :demand t
    :config
    (require 'smartparens-config)
    (smartparens-global-strict-mode 1)
    ;; don't run smartparens in the minibuffer
    (add-hook 'minibuffer-mode-hook 'turn-off-smartparens-strict-mode)

    ;; XXX this is shadowing the insert mode binding for some reason
    ;; :general
    ;; (general-define-key
    ;;  :keymaps 'emacs-lisp-mode-map
    ;;  "^" #'sp-backward-up-sexp)
    )
#+END_SRC

** spaceline
I want a pretty mode-line. Note: most of the configuration happens in the =spaceline-all-the-icons= package.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
      :config
      ;; disable separators
      (setq powerline-default-separator nil)

      ;; change face based on evil state
      ;; TODO add meow state function
      ;; (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)

      ;; ensure the mode-line is re-compiled when switching themes
      (advice-add 'load-theme :after
                  (lambda (&rest args)
                    (spaceline-compile))))
#+END_SRC

** spaceline-all-the-icons
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package spaceline-all-the-icons
      :after (all-the-icons spaceline)
      :config
      <<spaceline-ati-config>>
      )
#+END_SRC

*** spaceline-ati-config
:PROPERTIES:
:header-args: :noweb-ref spaceline-ati-config :tangle no
:END:

By default =all-the-icons= returns an object without an =:inherit= property. You can pass a face to inherit from, but can't specify a bare =:inherit=. This has the issue where an icon has the wrong background color based on which section of the modeline it occupies. So we need a function that will both apply a bare =:inherit= property along with some default scaling values.
#+BEGIN_SRC emacs-lisp
  (defun ic/icon (name &optional group)
    (setf group (or group 'alltheicon))
    (let* ((icon (funcall (intern (format "all-the-icons-%s" group))
                          name))
           (family (plist-get (plist-get (text-properties-at 0 icon)
                                         'face)
                              :family))
           (face `(:family ,family :inherit)))
      (propertize icon 'face face 'font-lock-face face 'display '(raise 0.1))))
#+END_SRC

For the version control segment I would like the see the git icon along with the current file's status if we're in the master branch. If we're in a non-master branch I want to see the git branch icon along with the branch name and current file's status.
#+BEGIN_SRC emacs-lisp
  (defun ic//vc-icon-git ()
    (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
           ;; (project-name (second (nreverse (split-string (projectile-project-root) "/"))))
           (vc-state-icon (pcase (vc-state (buffer-file-name))
                            ('up-to-date "-")
                            ('edited "*")
                            ('added "^")
                            ('removed' "v")
                            ('conflict "!")
                            ('missing "m")
                            ('ignored "i")
                            ('unregistered "x")
                            (_ "?")))
           (branch-icon (if (string= branch "master")
                            (ic/icon "git")
                          (concat
                           (ic/icon "git-branch" 'octicon)
                           " "
                           branch))))
      (concat vc-state-icon " " branch-icon)))

  (spaceline-define-segment
      ic-vc-icon "A segment for the Version Control icon"
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode) (ic//vc-icon-git))
              (t (propertize (format "%s" vc-mode))))))
#+END_SRC

I want to see when our current =projectile= differs from the active =persp-mode= perspective. This shouldn't happen, but I am seeing it when first getting the two to work together.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-project-name "A segment for the active projectile project."
      (let ((project (projectile-project-name))
            (persp (safe-persp-name (get-frame-persp))))
        (if (equal project persp)
            project
          (concat project "|" persp))))
#+END_SRC

Sometimes I use an older Surface Pro 4 tablet. This has a nasty habit of screen flickering when it gets hot. It seems to be alievated when the screen refreshes. So I hack around it by ensuring the modeline displays alternating =,= and =.= every second. I then need a timer to force the modeline to update, causing emacs to do a screen repaint, "fixing" the screen flickering. Simply calling =(redisplay t)= is not sufficient it seems.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-tablet-fix "A segment to hack around the screen flickering on the Surface
      Pro 4."
      (let ((seconds (% (floor (time-to-seconds)) 2)))
        (if (= seconds 0) "‚ò≥" "‚ò∑")))

  (when on-tablet
    (setq ic//tablet-fix-timer (run-at-time nil 1 #'force-mode-line-update))
    ;; (cancel-timer ic//tablet-fix-timer)
    )
#+END_SRC

I want to try having some extra vertical space on the mode-line. Just setting the =:height= property on the =mode-line= face will scale all the text on the line as well, which isn't what I want. [[https://github.com/seagle0128/doom-modeline][doom-modeline]] handles this by making an image scaled to the desired size and displaying that in the mode line.

I made one change: to ignore if we running on graphics or not. I'm always in GUI emacs and the mode-line is set prior to the graphics system being initialized, so we need to generate the image even if we don't have =(display-graphic-p)=.
#+BEGIN_SRC emacs-lisp
  ;; taken from: https://github.com/seagle0128/doom-modeline/blob/master/doom-modeline-core.el
  (defun doom-modeline--create-bar-image (face width height)
    "Create the bar image.
  Use FACE1 for the bar, FACE2 for the background.
  WIDTH and HEIGHT are the image size in pixels."
    (when (and ;;(display-graphic-p)
               (image-type-available-p 'pbm))
      (propertize
       " " 'display
       (let ((color (or (face-background face nil t) "None")))
         (ignore-errors
           (create-image
            (concat (format "P1\n%i %i\n" width height)
                    (make-string (* width height) ?1)
                    "\n")
            'pbm t :foreground color :ascent 'center))))))
#+END_SRC

Set the mode line.
#+BEGIN_SRC emacs-lisp
  ;; bring in bundled segments
  (require 'spaceline-segments)

  ;; and define our custom mode-line
  (spaceline-compile
    'main
    ;; left side
    '((window-number
       :priority 100
       ;; :fallback evil-state
       :face highlight-face)
      ((buffer-modified
        all-the-icons-mode-icon
        remote-host)
       :priority 95)
      ((buffer-id)
       :priority 96)
      ((anzu
        selection-info)
       :priority 90)
      ((flycheck-error
        flycheck-warning
        flycheck-info)
       :priority 85)
      process)

    ;; right side
    '(((org-clock) :when active)
      ((ic-vc-icon)
       :priority 87)
      all-the-icons-git-status
      ;; XXX (projectile-root) is really slow outside a project
      ;; (projectile-root)
      ;; ((buffer-encoding-abbrev buffer-size
      ;;   input-method)
      ;;  :priority 5)
      (((ic-tablet-fix :when (and active on-tablet))
        buffer-position)
       :priority 91)))

  ;; and enable it
  (let ((spacing-image (doom-modeline--create-bar-image
                        'powerline-active1 1 30)))
    (setq-default mode-line-format `(,(concat spacing-image "%e")
                                     (:eval (spaceline-ml-main)))))

#+END_SRC

=mode-line-format= is buffer-local and there are some buffers that have set it prior to us generating the mode-line, so we need to reset their values:
#+BEGIN_SRC emacs-lisp
  (save-excursion
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (setq mode-line-format (default-toplevel-value 'mode-line-format)))))
#+END_SRC

Add icons to any custom modes we've defined
#+BEGIN_SRC emacs-lisp
  (add-to-list 'all-the-icons-mode-icon-alist
               '(zetian-mode all-the-icons-material "local_florist"
                             :height 1.0 :v-adjust -0.1))
#+END_SRC

** visual-fill-column
I want emacs to wrap long lines automatically and refill when modifying text. =visual-fill-column= does just that.
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :init (setq-default fill-column 80)
    :hook (visual-line-mode . visual-fill-column-mode))
#+END_SRC

** web-mode
This should make editing javascript/typescript/JSX more pleasant.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :init
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
    (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode))
    )
#+END_SRC

** wgrep
=wgrep= is a package that let's us live edit a =helm-occur= buffer.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    ;; :init
    ;; (add-hook 'helm-occur-mode-hook #'wgrep-change-to-wgrep-mode)
    )
#+END_SRC

** winum
For numbering and jumping to windows.
#+BEGIN_SRC emacs-lisp
  (use-package winum
      :demand t
      :config
      ;; I want frames numbered only within a frame, not globally
      (setq winum-scope 'frame-local)
      ;; spaceline handles window numbers
      (setq winum-auto-setup-mode-line nil)
      (winum-mode)

      (defun ic/winum-delete-window-0-or-10 (&optional _arg)
        "Delete window 0 if assigned or 10 if exists."
        (interactive "P")
        (winum-select-window-0-or-10 '(4)))

      (defmacro defun-ic--winum-delete-window-num (n)
        "Create function for calling `winum-select-window-by-number'
  so that it kills window N."
        `(defun ,(intern (format "ic/winum-delete-window-%d" n)) (&optional _arg)
           ,(format "Delete window %d." n)
           (interactive "P")
           (winum-select-window-by-number ,(- n))))

      (defun-ic--winum-delete-window-num 1)
      (defun-ic--winum-delete-window-num 2)
      (defun-ic--winum-delete-window-num 3)
      (defun-ic--winum-delete-window-num 4)
      (defun-ic--winum-delete-window-num 5)
      (defun-ic--winum-delete-window-num 6)
      (defun-ic--winum-delete-window-num 7)
      (defun-ic--winum-delete-window-num 8)
      (defun-ic--winum-delete-window-num 9)

      :general
      (leader-keys
       "0" '(winum-select-window-0-or-10 :which-key ("0..9" . "winum-window 0..9"))
       "1" '(winum-select-window-1 :which-key t)
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t)
       "C-0" '(ic/winum-delete-window-0-or-10 :which-key ("C-0..9" . "ic/winum-delete-window 0..9"))
       "C-1" '(ic/winum-delete-window-1 :which-key t)
       "C-2" '(ic/winum-delete-window-2 :which-key t)
       "C-3" '(ic/winum-delete-window-3 :which-key t)
       "C-4" '(ic/winum-delete-window-4 :which-key t)
       "C-5" '(ic/winum-delete-window-5 :which-key t)
       "C-6" '(ic/winum-delete-window-6 :which-key t)
       "C-7" '(ic/winum-delete-window-7 :which-key t)
       "C-8" '(ic/winum-delete-window-8 :which-key t)
       "C-9" '(ic/winum-delete-window-9 :which-key t)
       )
      )
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :demand t
    :config
    (add-to-list 'auto-mode-alist '("\\.ya?ml\\.j2\\'" . yaml-mode))
    )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :init
      (setq ic/snippet-dir (concat user-data-directory "snippets/"))
      (setq yas-snippet-dirs (list ic/snippet-dir))
      (yas-global-mode 1)
      :config
      (defun ic/expand-snippet (snippet &optional mode env)
        "Load the `yas-snippet' SNIPPET found in MODE mode, with the ENV
      environment and return as a string."
        (with-temp-buffer
          (unless (yas-minor-mode 1)
            (error "failed to load yas-minor-mode"))
          (yas-expand-snippet
           (yas-lookup-snippet snippet mode)
           nil
           nil
           env)
          (buffer-string))))
#+END_SRC

*** csharp snippets
#+BEGIN_SRC emacs-lisp
  (defun ic/csharp-authoring-base-filename ()
    "Return base part of '*.cs' filename."
    (string-remove-suffix
     ".cs"
     (file-name-nondirectory (buffer-file-name))))

  (defun ic/csharp-authoring-base ()
    "Return base part of '*Authoring.cs' filename"
    (string-remove-suffix "Authoring" (ic/csharp-authoring-base-filename)))

  (defun ic/csharp-authoring-component-menu ()
    "Return a string suitable for C# `AddComponentMenu'"
    (let ((case-fold-search nil))
      (concat (s-replace "." "/" (or (yas-field-value 1) ""))
              "/"
              (string-trim-left
               (s-replace-regexp (rx upper)
                                 (lambda (m) (concat " " m))
                                 (concat (ic/csharp-authoring-base)
                                         (yas-field-value 2)))
               " "))))

  (defun ic/csharp-authoring-variables ()
    "Return a list of defined variable names"
    (when (yas-text)
      (mapcar (lambda (s)
                (car (reverse (split-string s " "))))
              (split-string (yas-text) ";" t " \n"))))

  (defun ic/csharp-authoring-assign-variables ()
    "Return a string where each variable is assigned from the authoring class"
    (let ((indent (s-repeat 24 " ")))
      (string-join (mapcar (lambda (v)
                             (format "%s = auth.%s" v v))
                           (ic/csharp-authoring-variables))
                   (concat ",\n" indent))))
#+END_SRC

* Modes
** info-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

** dired-mode
#+BEGIN_SRC emacs-lisp
  ;; when viewing multiple directories (with `i') movement should be over the dead
  ;; heading lines
  (setq dired-movement-style 'bounded)
#+END_SRC

** lisp-mode
Setup tab width.
#+BEGIN_SRC emacs-lisp
  (defun ic/lisp-mode-setup ()
    (setq indent-tabs-mode nil)
    (setq tab-width 8)
    (setq lisp-indent-function 'common-lisp-indent-function))

  (add-hook 'lisp-mode-hook #'ic/lisp-mode-setup)
#+END_SRC

Some useful functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/eval-outer-sexp-dwim ()
    "Evaluate the outermost sexp at POINT, stopping at any (def*) found."
    (interactive)
    (save-excursion
      (condition-case nil
          ;; move up as much as possible
          (while (not (looking-at "(def"))
            (up-list -1 t))
        (error nil))
      ;; are we on a left paren?
      (if (eq ?\( (following-char))
          (progn
            ;; move to the end
            (forward-sexp)
            ;; and evaluate
            (call-interactively 'eval-last-sexp))
        (message "Cannot evaluate: not inside an sexp"))))

  (defun ic/eval-enclosing-sexp ()
    "Evaluate the sexp enclosing POINT."
    (interactive)
    (save-excursion
      (condition-case nil
          (progn
            (up-list -1 t)
            (forward-sexp)
            (backward-char))
        (error
         (message "Cannot evaluate: not inside an sexp"))
        (:success
         (call-interactively 'eval-last-sexp)))))
#+END_SRC

Setup keybinds
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps 'emacs-lisp-mode-map
    "e" '(ic/eval-enclosing-sexp :which-key "ic/eval-enclosing-sexp")
    "E" 'ic/eval-outer-sexp-dwim
    "B" 'eval-buffer
    "M" 'emacs-lisp-macroexpand
    )
#+END_SRC

** prog-mode
#+BEGIN_SRC emacs-lisp
  (defun ic/prog-mode-setup ()
    (flyspell-prog-mode)
    (auto-fill-mode)
    (company-mode 1)
    (setq indent-tabs-mode nil)
    (setq tab-width 4))
  (add-hook 'prog-mode-hook #'ic/prog-mode-setup)
#+END_SRC

** python-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'python))

  (defun ic/python-mode-setup ()
    (setq python-indent-offset tab-width)
    (lsp))

  (add-hook 'python-mode-hook #'ic/python-mode-setup)
#+END_SRC

** text-mode
Let's have automatic spell checking for text heavy buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

** winner-mode
I like being able to undo/redo window changes.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

* Misc
** Misc cruft
Turn off some default emacs settings I don't like, such as the menu bar, scroll
bar, etc.

#+BEGIN_SRC emacs-lisp
  ;; disable unwanted UI elements
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  ;; static cursor
  (blink-cursor-mode -1)

  ;; don't show the initial emacs screen
  (setq inhibit-startup-screen t)
  ;; start in the *Messages* buffer
  (setq initial-buffer-choice (lambda () (get-buffer "*Messages*")))
  ;; let me use y/n in prompts
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Encoding
I do most of my work in =UTF-8= with =unix= line endings, so set that as the default coding system. Emacs seems to still Do The Right Thing on windows with this set. When it's not set =tramp= from windows into a linux system does not work properly.
#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8-unix)
#+END_SRC
** Ediff
#+BEGIN_SRC emacs-lisp
  ;; don't open ediff controls in a new frame
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; use a more comfortable window split
  (setq ediff-split-window-function 'split-window-horizontally)

  ;; restore old window configuration on exit
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** Diff current buffer with disk version
Sometimes I want to see what differences emacs has in a buffer over the contents on disk.
#+BEGIN_SRC emacs-lisp
  (defvar ic//ediff-buffer-A)
  (defvar ic//ediff-buffer-B)

  (defun ic/ediff-current-buffer-with-disk ()
    "Run `ediff' against the current buffer and the file on disk."
    (interactive)
    (unless (buffer-file-name)
      (user-error "Current buffer not visiting a file."))
    (let* ((fn (buffer-file-name))
           (disk-buf-name (format " *disk version of %s*"
                                  (file-name-nondirectory fn)))
           (disk-buf (with-current-buffer (get-buffer-create disk-buf-name)
                       (erase-buffer)
                       (insert-file-contents-literally fn)
                       (current-buffer)))
           (emacs-contents (save-restriction
                             (widen)
                             (buffer-substring-no-properties (point-min) (point-max))))
           (emacs-buf-name (format " *emacs version of %s*"
                                   (file-name-nondirectory fn)))
           (emacs-buf (with-current-buffer (get-buffer-create emacs-buf-name)
                        (erase-buffer)
                        (insert emacs-contents)
                        (current-buffer))))
      (setq ic//ediff-buffer-A disk-buf)
      (setq ic//ediff-buffer-B emacs-buf)
      (add-hook 'ediff-quit-hook #'ic//ediff-cleanup)
      (ediff-buffers disk-buf emacs-buf)))

  (defun ic//ediff-cleanup ()
    "Clean up the old buffers after calling `ic/ediff-current-buffer-with-disk'."
    (dolist (buf (list ic//ediff-buffer-A ic//ediff-buffer-B))
      (when (buffer-live-p buf)
        (kill-buffer buf)))
    (remove-hook 'ediff-quit-hook #'ic//ediff-cleanup))
#+END_SRC

** user-emacs-directory
Try and keep the =user-emacs-directory= somewhat clean.
#+BEGIN_SRC emacs-lisp
  ;; cache/ directory
  (setq recentf-save-file (concat user-cache-directory "recentf"))
  (setq eshell-history-file-name (concat user-cache-directory "eshell-history"))
  (setq savehist-file (concat user-cache-directory "savehist-history"))
  (setq request-storage-directory (concat user-cache-directory "request"))
  (setq transient-history-file (concat user-cache-directory "transient-history.el"))
  (setq transient-values-file (concat user-cache-directory "transient-values.el"))
  (setq transient-levels-file (concat user-cache-directory "transient-levels.el"))
  (setq bookmark-default-file (concat user-cache-directory "bookmarks"))
  (setq tramp-persistency-file-name (concat user-cache-directory "tramp"))
  (setq ic/treesit-install-path (concat user-cache-directory "tree-sitter"))
  (setq treesit-extra-load-path (list ic/treesit-install-path))

  ;; cache/{backups,auto-saves}
  (let ((backup-dir (concat user-cache-directory "backups/"))
        (autosave-dir (concat user-cache-directory "auto-saves/")))
    ;; create directories if needed
    (dolist (path (list backup-dir autosave-dir))
      (unless (file-directory-p path)
        (make-directory path t)))
    (setq backup-directory-alist `((".*" . ,backup-dir)))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq auto-save-list-file-prefix (concat autosave-dir "saves-"))
    (setq tramp-backup-directory-alist `((".*" . ,backup-dir)))
    (setq tramp-auto-save-directory autosave-dir))

  ;; data/ directory
  (setq abbrev-file-name (concat user-data-directory "abbrev"))
#+END_SRC

** Buffers
Some useful buffer related functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/yank-buffer-to-clipboard ()
    "Yank contents of current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun ic/paste-clipboard-to-buffer ()
    "Overwrite the current buffer with the clipboard contents."
    (interactive)
    (when (yes-or-no-p "Overwrite current buffer with clipboard?")
      (widen)
      (erase-buffer)
      (clipboard-yank)))

  (defun ic/yank-current-filename ()
    "Yank the full filename of the currently active buffer. Return
  `nil' if no underlying file."
    (interactive)
    (let ((filename (or (buffer-file-name) "nil")))
      (kill-new filename)
      (message filename)))

  (defvar ic//current-scratch nil
    "The most recently created *scratch* buffer.")

  (defun ic/switch-to-scratch-buffer (arg)
    "Switch to (or create) the `*scratch*' buffer."
    (interactive "P")
    (when (or (equal arg '(4))
              (not (buffer-live-p ic//current-scratch)))
      (setq ic//current-scratch (ic//create-scratch-buffer)))
    (pop-to-buffer-same-window (buffer-name ic//current-scratch)))

  (defun ic//create-scratch-buffer ()
    "Create a new *scratch* buffer."
    (let* ((buffers (seq-filter
                     (lambda (buf)
                       (string-prefix-p "*scratch"
                                        (buffer-name buf)))
                     (buffer-list)))
           (number (+ 1 (length buffers)))
           (name (format "*scratch-%d*" number)))
      (with-current-buffer (get-buffer-create name)
        (org-mode)
        (insert (format "#+TITLE: Scratch Buffer %d\n\n" number))
        (current-buffer))))
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("zetian" (or
                      (mode . zetian-mode)
                      (name . "^zetian:")
                      (name . "^\\*zetian")
                      (filename . "org/home/roam")))
           ("org" (or
                   (mode . org-mode)
                   (name . "^\\*Org Src")
                   (name . "^\\*Org Agenda\\*$")))
           ("tramp" (name . "^\\*tramp.*"))
           ("magit" (or
                     (mode . magit-mode)
                     (mode . magit-diff-mode)
                     (mode . magit-process-mode)
                     (name . "^magit.*")))
           ("emacs" (or
                     (name . "^\\*scratch\\*$")
                     (name . "^\\*Messages\\*$")
                     (name . "^\\*Warnings\\*$")
                     (name . "^\\*Shell Command Output\\*$")
                     (name . "^\\*Async-native-compile-log\\*$")
                     (name . "^\\*straight-")))
           ("ediff" (or
                     (name . "^\\*ediff.*")
                     (name . "^\\*Ediff.*")))
           ("dired" (mode . dired-mode))
           ("terminal" (or
                         (mode . term-mode)
                         (mode . shell-mode)
                         (mode . eshell-mode)))
           ("help" (or
                    (name . "^\\*Help\\*$")
                    (name . "^\\*info\\*$")
                    (name . "^\\*helpful"))))))

  ;; use our custom groupings by default
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  ;; don't show empty groups
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

** Files
Some useful file related functions.

First, some shortcuts to my configuration files.
#+BEGIN_SRC emacs-lisp
  (defun ic/edit-init-file ()
    "Open the `init. l' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))

  (defun ic/edit-early-init-file ()
    "Open the `early-init.el' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "early-init.el")))

  (defun ic/edit-org-config-file ()
    "Open the `README.org' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "README.org")))
#+END_SRC

Some functions to manipulate underlying files.
#+BEGIN_SRC emacs-lisp
  (defun ic/delete-current-buffer-file ()
    "Delete the currently visited file."
    (interactive)
    (if-let (filename (buffer-file-name))
        (when (yes-or-no-p (format "Delete file %S? " filename))
          (delete-file filename)
          (kill-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache filename))
          (message (format "Deleted file %S." filename)))))


  (defun ic/rename-current-buffer-file ()
    "Rename the currently visited file."
    (interactive)
    (if-let (cur-filename (buffer-file-name))
        (let ((new-filename (read-file-name
                             (format "Rename %S to: "
                                     (file-name-nondirectory cur-filename))))
              (cur-buffer (buffer-name)))
          (rename-file cur-filename new-filename)
          (find-file new-filename)
          (kill-buffer cur-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache cur-filename)
            (call-interactively 'projectile-cache-current-file))
          (message (format "Renamed %S to %S." cur-filename new-filename)))))
#+END_SRC

** display-buffer configuration
#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
          ;; display help windows on the right
          ("^\\*\\(Help\\|info\\)"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . right)
           (slot . 1)
           (window-width . 80)
           (reusable-frames . nil))

          ;; display compile errors on the bottom
          ("^\\*\\(Compile\\|Backtrace\\)"
           (display-buffer-reuse-window display-buffer-at-bottom)
           (window-width . 0.5)
           (window-height . 15)
           (reusable-frames . nil))

          ;; display magit windows on the left
          ("^magit:"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . left)
           (slot . 1)
           (window-width . 80)
           (window-height . 1.0)
           (reusable-frames . nil))
          ))
#+END_SRC

** Customize
I don't like =customize= so discard all settings.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat (temporary-file-directory) "emacs-customize-settings"))
#+END_SRC

** Tab Width
Use 4 spaces by default for tabs. Note: these are commonly overwritten in mode hooks.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].

#+BEGIN_SRC emacs-lisp
  (defun ic/save-and-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (save-buffer)
    (ic/kill-buffer-and-window))

  (defun ic/maybe-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (save-buffers-kill-emacs)))

  (defun ic/kill-buffer-and-window ()
    "Destroy the current buffer and window, if it was the sole window also delete
  the frame."
    (interactive)
    (condition-case-unless-debug nil
        (kill-buffer-and-window)
      (error
       (spacemacs/frame-killer))))

  ;; from spacemacs
  (defun spacemacs/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error
       (make-frame-invisible nil 1))))
#+END_SRC

And some =leader-key= bindings:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "q"
   "" '(nil :which-key "quit")
   "q" 'spacemacs/frame-killer
   "Q" 'ic/maybe-kill-emacs)
#+END_SRC

** Frame title
Set the frame title to something meaningful.

#+BEGIN_SRC emacs-lisp
  (defun ic/short-persp-name ()
    "Return a shortened name for currently active perspective. Returns `nil'
  when `persp-mode' not enabled."
    ;; we guard calls to `get-frame-persp' and `safe-persp-name' behind a
    ;; check for `\'persp-mode' so shutup the compiler about unknown functions.
    (eval-when-compile
      (unless (fboundp 'get-frame-persp)
        (defun get-frame-persp ()))
      (unless (fboundp 'safe-persp-name)
        (defun safe-persp-name (_))))
    (when (and (boundp 'persp-mode) (get-frame-persp))
      (let ((name (safe-persp-name (get-frame-persp))))
        (concat " <"
                (if (file-directory-p name)
                    (file-name-nondirectory (directory-file-name name))
                  name)
                "> "))))

  (setq frame-title-format
        '((:eval (buffer-name (window-buffer (minibuffer-selected-window))))
          (:eval (ic/short-persp-name))))
#+END_SRC

** Spelling
When typing in insert mode I want to hit =C-e= to automatically correct the previous misspelled word.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   "C-e" #'flyspell-auto-correct-previous-word)
#+END_SRC

** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of the re-display code so can run only when needed. Lisp implementations such as =linum= and =nlinum= have to run over an entire window as they can't know which part of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain text-heavy modes.
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp
  ;; use lines displayed on screen rather than new line characters; so folds work
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 3 ...
  (setq-default display-line-numbers-width 3)
  ;; ... and allow it to shrink :(
  (setq-default display-line-numbers-grow-only nil)
#+END_SRC

I would really like to set =display-line-numbers-grow-only= to =t= so that it only grows and prevents shrinkage, but it seems there is a significant performance cost associated with it. I've increased the default width slightly to offset it, but that will waste a bit more space on small files.

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like =linum-mode=, instead it uses the =text-area= where the main buffer text is. This means that anything in the fringe (=display-margin=) now shows up to the left of the line numbers. I'm not a fan of that, but I guess I'll live with it as there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of =display-line-numbers= for more info.

** Web Browser
=firefox=, duh.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program
        (cond
         (on-windows
          "c:/Program Files/Mozilla Firefox/firefox.exe")
         (on-old-imac
          "/Applications/Firefox.app/Contents/MacOS/firefox")
         (t
          "firefox")))
#+END_SRC

** Minibuffer / completion testing (disabled)
:PROPERTIES:
:header-args: :tangle no
:END:

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (defun ic/ignore-marginalia-annotate-binding (&_))
    (advice-add 'marginalia-annotate-binding :override 'ic/ignore-marginalia-annotate-binding)
    (marginalia-mode 1)
    )

#+END_SRC

*** Embark-Consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult)
#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    ;; (add-to-list 'display-buffer-alist
    ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
    ;;                nil
    ;;                (window-parameters (mode-line-format . none))))

    (add-hook 'embark-post-action-hook #'embark-collect--update-linked)
    ;; (remove-hook 'embark-post-action-hook #'embark-collect--update-linked)

    (add-hook 'minibuffer-setup-hook #'embark-collect-completions)
    ;; (remove-hook 'minibuffer-setup-hook #'embark-collect-completions)

    (defun ic/embark-act-noexit ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'embark-act)))

    :general
    (leader-keys
      "hdb" 'embark-bindings)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-," 'embark-act
     "C-<" 'ic/embark-act-noexit
     "C-." 'embark-become)
    )

#+END_SRC

*** Minibuffer
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'minibuffer-local-map
   "C-w" 'backward-kill-word)

#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :config
    ;; use TAB for previewing
    (setq consult-preview-key (kbd "<tab>"))
    (setq consult-narrow-key "<")

    (defun ic/consult-unfocus-lines ()
      "Reset any current focus from `consult-focus-lines'."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-focus-lines)))

    :general
    (leader-keys
      "bb" 'consult-buffer
      "fb" 'consult-bookmark
      "pi" 'consult-project-imenu
      "ha" 'consult-apropos
      "sf" 'consult-find
      "sL" 'consult-locate
      "sg" 'consult-grep
      "sG" 'consult-git-grep
      "sm" 'consult-multi-occur
      "sr" 'consult-ripgrep
      "su" 'consult-focus-lines
      "sU" 'ic/consult-unfocus-lines
      )

    (general-define-key
     "go" 'consult-outline
     "gh" 'consult-org-heading
     "gi" 'consult-imenu
     "gl" 'consult-line
     )

    )

#+END_SRC

*** Selectrum (not used)
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand nil
    :after (orderless embark)
    :config
    (selectrum-mode 1)

    ;; window should be exactly 20 lines always
    (setq selectrum-max-window-height 20)
    (setq selectrum-fix-vertical-window-height selectrum-max-window-height)

    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (setq selectrum-refine-candidates-function #'orderless-filter)

    ;; when we have an embark collect: only show the current selectrum item
    (defun ic/single-line-selectrum ()
      (when (eq embark-collect--kind :live)
        (with-selected-window (active-minibuffer-window)
          (setq-local selectrum-num-candidates-displayed 1)
          (setq-local selectrum-display-style
                      '(horizontal :before-candidates "[" :after-candidates "]"
                                   :more-candidates "" :candidates-separator "")))))
    (add-hook 'embark-collect-mode-hook #'ic/single-line-selectrum)

    ;; selectrum should have a decoration-less window on the bottom
    (setq selectrum-display-action '(display-buffer-in-side-window
                                     (side . bottom)
                                     (slot . -1)
                                     (window-parameters (mode-line-format . none))))
    )
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t
    :demand t
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :config
    (defun ic/orderless-bang-prefix (pattern _index _total)
      (when (string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))

    (defun ic/orderless-bang-suffix (pattern _index _total)
      (when (string-suffix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 0 -1))))

    (defun ic/orderless-carrot-suffix (pattern _index _total)
      (when (string-suffix-p "^" pattern)
        `(orderless-regexp . ,(concat "^" (substring pattern 0 -1)))))

    (setq completion-styles '(orderless))
    (setq orderless-matching-styles '(orderless-regexp))
    (setq orderless-style-dispatchers '(ic/orderless-bang-prefix
                                        ic/orderless-bang-suffix
                                        ic/orderless-carrot-suffix))
    )
#+END_SRC

** Second completion testing

*** Selectrum
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :init
    ;; always show a certain amount of candidates
    (setq selectrum-max-window-height 15)
    (setq selectrum-fix-vertical-window-height t)
    ;; selection face should extend to the screen edge
    (setq selectrum-extend-current-candidate-highlight t)
  
    :config
    (selectrum-mode 1)
  
    :general
    (leader-keys
      "R" 'selectrum-repeat))
#+END_SRC

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode 1))
#+END_SRC

*** Orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless))
    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)

    :config
    ;; persist history
    (savehist-mode)
    )
#+END_SRC

*** Prescient
#+BEGIN_SRC emacs-lisp
  (use-package selectrum-prescient
    :demand t
    :init
    (setq selectrum-prescient-enable-filtering nil)
    (setq prescient-save-file (concat user-cache-directory "prescient-save.el"))
    :config
    (selectrum-prescient-mode 1)
    (prescient-persist-mode 1))
#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :demand t
    :config
    ;; always use completing-read for selecting actions, rather than keybinds
    (setq embark-prompter 'embark-completing-read-prompter)
  
    ;; setup initial action keybind
    (meow-normal-define-key
     '("C-." . embark-act))
  
    (defun consult-outline-or-org-heading (&optional match scope)
      "Call `consult-org-heading' when in an `org-mode' buffer, otherwise call
    `consult-outline'."
      (interactive)
      (if (eq major-mode 'org-mode)
          (consult-org-heading match scope)
        (consult-outline)))

    (defun ic-consult-bookmark ()
      "Call `consult-bookmark' without automatic buffer preview.
  This is to prevent possible `tramp' calls."
      (interactive)
      (let ((consult-preview-key 'nil))
        (call-interactively #'consult-bookmark)))

    :bind (:map minibuffer-local-map
           ("C-." . embark-act)))
#+END_SRC

*** consult-lsp
#+BEGIN_SRC emacs-lisp
  (use-package consult-lsp
    :after emacsql
    :bind (:map lsp-mode-map
           ([remap consult-imenu-multi] . #'consult-lsp-symbols)
           :map lsp-command-map
           ("GD" . #'consult-lsp-diagnostics)))
#+END_SRC

** Movement
Some misc functions to support moving around.

#+BEGIN_SRC emacs-lisp
  (defun ic/move-to-outline-dwim ()
    "Prompt for, and move to, an outline heading."
    (interactive)
    (cond ((eq major-mode 'org-mode)
           (ic/org-jump-in-buffer))
          (t
           (message (format "No outline command found for mode `%s'" major-mode)))))
#+END_SRC

** Garbage Collection
I have problems typing in =org-mode= documents with the default garbage collector settings. So let's give the GC 100mb to work with and call it when emacs is idle.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 (expt 2 20)))
  (setq gc-cons-percentage 0.5)
  (run-with-idle-timer 5 t #'garbage-collect)
  (setq garbage-collection-messages nil)
#+END_SRC

** Shell replace
I'd like a way to call =shell-command-on-region= and have it replace the current region without using a prefix arg.

#+BEGIN_SRC emacs-lisp
  (defun ic/shell-command-on-region-replace ()
    "Call `shell-command-on-region' with prefix arg set."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'shell-command-on-region)))
#+END_SRC

** Windows fixes
For some reason on windows emacs doesn't associate =FontAwesome= code points with the font, so specifiy that manually. Taken from [[https://www.reddit.com/r/emacs/comments/34ttb8/get_fontawesome_to_display_correctly_under_windows/?][here]].

Note: =f2b4= was chosen as the ending codepoint by inspecting =data-faicons.el= from =all-the-icons= package. This might change on updates.
#+BEGIN_SRC emacs-lisp
  (when on-windows
    (set-fontset-font "fontset-default" '(#xf000 . #xf2b4) "FontAwesome"))
#+END_SRC

When I'm on =Chetwood= I'm running inside =MSYS2= which has a =/dev/null= device, so use that over the windows =NUL= device. This helps when remoting into a linux machine.
#+BEGIN_SRC emacs-lisp
  (when on-home-windows-desktop
    (setq null-device "/dev/null"))
#+END_SRC

** Mac Fixes
For some (stupid) reason =/usr/local/bin= isn't included in the =PATH= on mac. I've ensured it's loaded in =~/.bashrc=, =~/.bash_profile= and =~/.profile=. I've also added it under =/etc/paths.d/= as well as ensured it's part of =/etc/paths=. I've checked permissions (I can run programs from it) and since I know it's added correctly in a shell (with code I've been using for a decade now) let's just add it manually for emacs. Ugh
#+BEGIN_SRC emacs-lisp
  (when on-old-imac
    (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    (add-to-list 'exec-path "/usr/local/bin"))
#+END_SRC

Ensure =emacs= takes up as much of the screen as possible when maximizing.
#+BEGIN_SRC emacs-lisp
  (when on-mac
    (setq frame-resize-pixelwise t))
#+END_SRC

When we're on a mac and we have GNU =ls= installed (=gls=): use that as our =dired= listing program. Both because it supports  the =--dired= flag, but we can also get some marginally better collating from the GNU version.
#+BEGIN_SRC emacs-lisp
  (when (and on-mac
             (executable-find "gls"))
    (setq insert-directory-program "gls")
    (setq dired-listing-switches "-alU"))
#+END_SRC

** Start maximized 
I want every frame to start maximized by default. The problem is I used to set =default-frame-alist= to do so, but I also want to pop up capture windows using =org-protocol= and I /don't/ want those frame maximized. =default-frame-alist= works on all frames.

To get around this I'll use a hook to check the name of the newly created frame and maximize any non-capture frames. Note: the frame title is set in either the =.desktop= file (on linux) or =org-protocol-windows.reg= (on windows).

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-maximize-frame (frame)
    "Maximize any non-capture frames."
    (unless (equal "Org Capture" (frame-parameter frame 'name))
      (toggle-frame-maximized frame)))

  (add-hook 'after-make-frame-functions #'ic/maybe-maximize-frame)
  (ic/maybe-maximize-frame (selected-frame))
#+END_SRC

** Tree Sitter
Most of this config was taken liberally from [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][Mastering Emacs]].

First we need to setup some grammar sources.
#+BEGIN_SRC emacs-lisp
  (setq treesit-language-source-alist
    '((css . ("https://github.com/tree-sitter/tree-sitter-css"))
      (bash "https://github.com/tree-sitter/tree-sitter-bash")
      (html . ("https://github.com/tree-sitter/tree-sitter-html"))
      (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
      (json . ("https://github.com/tree-sitter/tree-sitter-json"))
      (python . ("https://github.com/tree-sitter/tree-sitter-python"))
      (markdown "https://github.com/ikatyang/tree-sitter-markdown")
      (make "https://github.com/alemuller/tree-sitter-make")
      (elisp "https://github.com/Wilfred/tree-sitter-elisp")
      (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" nil "tsx/src"))
      (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" nil "typescript/src"))
      (yaml . ("https://github.com/ikatyang/tree-sitter-yaml"))
      ))
#+END_SRC

Then we need to install any un-installed grammars and setup a function to update them all.
#+BEGIN_SRC emacs-lisp
  (defun ic/treesit-install-grammars ()
    "Install any un-installed `tree-sitter' grammars."
    (interactive)
    (dolist (def treesit-language-source-alist)
      (unless (treesit-language-available-p (car def))
        (treesit-install-language-grammar (car def) ic/treesit-install-path))))

  (defun ic/treesit-update-grammars ()
    "Install or update all `tree-sitter' grammars."
    (interactive)
    (dolist (def treesit-language-source-alist)
      (treesit-install-language-grammar (car def) ic/treesit-install-path)))

  (ic/treesit-install-grammars)
#+END_SRC

Next we need to make the non-ts major-modes to their treesitter equivalent. Just in case we load the non-ts mode.
#+BEGIN_SRC emacs-lisp
  (dolist (mapping
           '((css-mode . css-ts-mode)
             (js-json-mode . json-ts-mode)
             (js-mode . typescript-ts-mode)
             (js2-mode . typescript-ts-mode)
             (json-mode . json-ts-mode)
             (python-mode . python-ts-mode)
             (typescript-mode . typescript-ts-mode)
             (yaml-mode . yaml-ts-mode)
             ))
    (add-to-list 'major-mode-remap-alist mapping))
#+END_SRC

** File Extension to Major Mode Mapping
I want to add some custom file mappings, mostly for =tree-sitter= modes.

#+BEGIN_SRC emacs-lisp
  (dolist (mapping '(("\\.tsx\\'" . tsx-ts-mode)
                     ("\\.jsx\\'" . tsx-ts-mode)
                     ("\\.js\\'"  . typescript-ts-mode)
                     ("\\.mjs\\'" . typescript-ts-mode)
                     ("\\.mts\\'" . typescript-ts-mode)
                     ("\\.cjs\\'" . typescript-ts-mode)
                     ("\\.ts\\'"  . typescript-ts-mode)
                     ("\\.json\\'" . json-ts-mode)))
    (add-to-list 'auto-mode-alist mapping))
#+END_SRC

** Zetian
My personal 2nd brain implemented in =org-roam=.

*** Initial Config
#+BEGIN_SRC emacs-lisp
  (setq zetian-special-dir (concat org-roam-directory "special/"))
  (setq zetian-journal-dir (concat org-roam-directory "journal/"))
  (setq zetian-refnote-dir (concat org-roam-directory "ref/"))
  (setq zetian-archive-dir (concat org-roam-directory "archive/"))

  (setq zetian-tasks-file (concat zetian-special-dir "zetian-tasks.org"))
  (setq zetian-people-file (concat zetian-special-dir "zetian-people.org"))
  (setq zetian-tasks-archive-file-fmt
        (concat zetian-special-dir "task-archive-%Y.org"))

  (defconst zetian--type-cookie "_type_"
    "The prefix used for org-mode tags denoting a zetian type.")
#+END_SRC

*** zetian-mode
I'd like to have a custom mode to make things a little prettier. I really want using zetian to be a pleasant experience, that should help me make better use of it.

#+BEGIN_SRC emacs-lisp
  (defvar-local zetian-mode--header-overlay nil)
  (defvar-local zetian-mode-inhibit-header-update nil)

  (defun zetian-mode--update-header ()
    "Update the overlay `zetian-mode--header-overlay' with header information."
    (unless zetian-mode-inhibit-header-update
      (unless zetian-mode--header-overlay
        (zetian-mode--create-header))
      (org-roam-db-update-file)
      (org-set-regexps-and-options)
      (zetian-mode--update-header-1)))

  (defun zetian-mode--update-header-1 ()
    (let*
        ((type (zetian-get-type))
         (states (zetian-get-states))
         (title (zetian-get-title))
         (context (zetian-get-context))
         (project (zetian-get-project))
         (tags (zetian-get-tags))
         (modified (or (zetian-get-last-modified) "?"))
         ;; NOTE: both of these queries are noticeably slow
         ;; (num-outbound-links
         ;;  (length (zetian-query `(links-from ,(org-roam-node-at-point)))))
         ;; (num-inbound-links
         ;;  (length (zetian-query `(links-to ,(org-roam-node-at-point)))))
         (header
          (concat
           (propertize title 'face 'org-document-title)
           (when type
             (concat (propertize " [" 'face 'org-drawer)
                     type
                     (propertize "]" 'face 'org-drawer)))
           (when states
             (concat
              (propertize " {" 'face 'org-drawer)
              (s-join (propertize ", " 'face 'org-drawer)
                      (mapcar (lambda (s)
                                (propertize s 'face 'org-special-keyword))
                              states))
              (propertize "}" 'face 'org-drawer)))
           "\n"
           (propertize "Mod:" 'face 'org-drawer)
           (propertize modified 'face 'org-date)
           ;; NOTE: both of these queries are noticeably slow
           ;; (propertize " Out:" 'face 'org-drawer)
           ;; (propertize (format "%d" num-outbound-links)
           ;;             'face 'org-special-keyword)
           ;; (propertize " In:" 'face 'org-drawer)
           ;; (propertize (format "%d" num-inbound-links)
           ;;             'face 'org-special-keyword)
           (when (or context project tags)
             "\n")
           (zetian-mode--header-list-maybe "Context:" context)
           (zetian-mode--header-list-maybe "Project:" (and project (list project)))
           (zetian-mode--header-list-maybe "Tags:" tags)
           "\n"
           (propertize "\n" 'face '(:inherit default :extend t)))))
      (overlay-put zetian-mode--header-overlay 'face 'header-line)
      (overlay-put zetian-mode--header-overlay 'display header)
      (overlay-put zetian-mode--header-overlay 'cursor (length header))))

  (defun zetian-mode--header-list-maybe (label nodes)
    (when nodes
      (concat
       (propertize label 'face 'org-drawer)
       (s-join (propertize "," 'face 'org-drawer)
               (mapcar (lambda (n)
                         (propertize
                          (substring-no-properties (org-roam-node-title n))
                          'face 'org-link))
                       nodes))
       "  ")))

  (defvar-local zetian-mode--modification-hook-save nil)
  (defvar-local zetian-mode--modification-hook-save-state nil)
  (defun zetian-mode--modification-hook
      (ov after beg end &optional replaced-length)
    ;; (message "%s: (%d %d) %S %S"
    ;;          (if after "after" "begin") beg end replaced-length
    ;;          zetian-mode--modification-hook-save-pos)
    (if after
        (progn
          (if (not (equal end (overlay-end ov)))
              (when (get-buffer-window (current-buffer))
                (add-hook 'post-command-hook #'zetian--post-command-hook))
            (insert zetian-mode--modification-hook-save)
            (move-overlay ov
                          (overlay-start zetian-mode--header-overlay)
                          (+ end (length zetian-mode--modification-hook-save)))
            (set-buffer-modified-p zetian-mode--modification-hook-save-state)))
      (setq zetian-mode--modification-hook-save (buffer-substring beg end))
      (setq zetian-mode--modification-hook-save-state (buffer-modified-p))))

  (defun zetian--post-command-hook ()
    "update zetian header once after a command completes"
    (remove-hook 'post-command-hook #'zetian--post-command-hook)
    (zetian-mode--update-header))

  (defun zetian-mode--move-cursor-out-of-header (window old-pos action)
    (when (eq action 'entered)
      (goto-char (overlay-end zetian-mode--header-overlay))))

  (defun zetian-mode--create-header ()
    "Create the overlay `zetian-mode' uses to display information."
    (unless zetian-mode--header-overlay
      (save-excursion
        (goto-char (point-min))
        (let* ((beg (point))
               (end (re-search-forward "^$"))
               (ov (make-overlay beg (+ 1 end))))
          (overlay-put ov 'cursor-sensor-functions
                       (list #'zetian-mode--move-cursor-out-of-header))
          (overlay-put ov 'modification-hooks
                       (list #'zetian-mode--modification-hook))
          (setq zetian-mode--header-overlay ov)))))

  (defun zetian-mode--remove-header ()
    "Removes the overlay and any text properties created."
    (when-let ((ov zetian-mode--header-overlay))
      (delete-overlay ov)))

  (defun zetian-mode--before-save-h ()
    (let ((zetian-mode-inhibit-header-update t))
      (zetian-set-last-modified)))

  (defun zetian-mode--after-save-h ()
    (zetian-mode--update-header))

  (defun zetian-mode--cmmh ()
    "Destroy any changes `zetian-mode' makes to a buffer. Should be run in
  `change-major-mode-hook'."
    (zetian-mode--remove-header)
    (remove-hook 'after-save-hook #'zetian-mode--after-save-h)
    (remove-hook 'before-save-hook #'zetian-mode--before-save-h)
    (remove-hook 'post-command-hook #'zetian--post-command-hook)
    (remove-hook 'change-major-mode-hook #'zetian-mode--cmmh))

  (define-derived-mode zetian-mode org-mode "zetian-mode"
    "A variant of org-mode designed to be used with zetian."
    (add-hook 'after-save-hook #'zetian-mode--after-save-h 0 t)
    (add-hook 'before-save-hook #'zetian-mode--before-save-h 0 t)
    ;; (add-hook 'kill-buffer-hook #'zetian-mode--remove-header)
    (add-hook 'change-major-mode-hook #'zetian-mode--cmmh 0 t)
    (cursor-sensor-mode 1)
    (zetian-mode--update-header)
    (let ((ov-end (overlay-end zetian-mode--header-overlay)))
      (when (< (point) ov-end)
        (goto-char ov-end))))
#+END_SRC

*** Effort
I want a way to track how much effort each task could take.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-global-properties
               (cons "Effort_ALL" "0 0:10 0:30 1:00 2:00 4:00 8:00"))
#+END_SRC

*** Column View
Setup how things will look when viewing a list of tasks.

#+BEGIN_SRC emacs-lisp
  (setq org-columns-default-format-for-agenda
        "%TODO %1Priority %4Effort(Efft){:} %40ITEM(Task) %33SCHEDULED %33DEADLINE %20TAGS")
#+END_SRC

*** Utility functions
#+BEGIN_SRC emacs-lisp
  (defvar zetian--node-marker nil
    "Internal value to mark a node's position in a (changing) buffer.")

  (defmacro with-zetian-node (node &rest body)
    "Evaluate BODY with NODE open and the view restricted to the note."
    (declare (indent 1))
    (let ((sym (gensym)))
      `(let ((,sym ,node))
         (if (not (org-roam-node-p ,sym))
             (error "Wrong type argument: org-roam-node, %S" ,sym)
           (save-excursion
             (with-current-buffer
                 (find-file-noselect (org-roam-node-file ,sym))
               (save-restriction
                 (widen)
                 (goto-char (or zetian--node-marker
                                (org-roam-node-point ,sym)))
                 (when (org-at-heading-p)
                   (org-narrow-to-subtree))
                 ,@body)))))))

  (defun map-zetian (func nodes)
    "Call FUNC for each zetian node in NODES.
  The node is opened, and narrowed before FUNC is called."
    (mapcar (lambda (x)
              (let ((zetian--node-marker (car x)))
                (with-zetian-node (cdr x)
                  (funcall func (cdr x)))))
            (mapcar (lambda (n)
                      (cons (org-roam-node-marker n) n))
                    nodes)))
#+END_SRC

*** Capture Templates
=org-roam= defines its own syntax for capture templates separate from =org-mode= so we'll define them here.
#+BEGIN_SRC emacs-lisp
  (setq zetian-capture-default-filename "%<%Y%m%d%H%M%S>-${id}.org")

  (cl-defun zetian--capture-template
      (&key file-name title file-tags file-cat type prop-id other is-element
            todo suppress-prop-drawer tail priority)
    (unless is-element
      (setq file-tags (concat (format ":_type_%s" type)
                              (or file-tags ":"))))
    (let ((body
           (concat
            (when is-element
              (concat "* "
                      (when todo (concat todo " "))
                      (when priority (format "[#%s] " priority))
                      (or title "${title}")
                      (format " :_type_%s:" type)
                      "\n"))
            (unless suppress-prop-drawer
              (concat
               ":PROPERTIES:\n"
               ":DATE_CREATED: %U\n"
               ":LAST_MODIFIED: %U\n"
               ;; XXX for some reason org-roam is inserting the file's id for
               ;; "${id}" when capturing an element (task, event, etc) rather than
               ;; creating a new id.
               (format ":ID: %s\n" (or prop-id
                                       (if is-element
                                           "%(org-id-new)"
                                         "${id}")))
               ":END:\n"))
            (when file-cat (format "#+category: %s\n" file-cat))
            (when file-tags (format "#+filetags: %s\n" file-tags))
            (when other (concat other "\n"))
            (unless is-element
              (format "#+title: %s" (or title "${title}")))
            tail)))
      (if is-element
          body
        `(file+head ,(or file-name zetian-capture-default-filename)
                    ,body))))

  (let* ((zetian-tasks-file "special/zetian-tasks.org")
         (zetian-people-file "special/zetian-people.org")
         (default-template "\n%?")
         (task-target
          (zetian--capture-template
           :file-name zetian-tasks-file :title "All My Tasks"
           :type "task" :other "#+startup: contents"
           :suppress-prop-drawer t
           :file-tags ":%(if at-home \"HOME\" \"WORK\"):agenda:"))
         (people-target
          (zetian--capture-template
           :file-name zetian-people-file :title "All My Contacts"
           :type "person" :other "#+startup: contents"
           :suppress-prop-drawer t
           :file-tags ":%(if at-home \"HOME\" \"WORK\"):agenda:")))
    (setq org-roam-capture-templates
        `(("p" "permanent note" plain ,default-template
           :target ,(zetian--capture-template
                     :type "perm" :file-tags ":review:")
           :unnarrowed t)

          ("i" "idea" plain ,default-template
           :target ,(zetian--capture-template
                     :type "idea" :file-tags ":review:")
           :unnarrowed t)

          ("t" "task" entry
           ,(concat (zetian--capture-template
                     :is-element t :todo "TODO" :type "task"
                     :priority (char-to-string org-default-priority))
                    default-template)
           :target ,task-target
           :empty-lines-before 1)

          ("e" "event" entry
           ,(concat (zetian--capture-template
                     :is-element t :todo "TODO" :type "event"
                     :priority (char-to-string org-default-priority))
                    default-template)
           :target ,task-target
           :empty-lines-before 1)

          ("P" "person" entry
           ,(zetian--capture-template
             :is-element t :type "person"
             :other (concat
                     "%U\n\n"
                     "- organization ::\n"
                     "- birthday ::\n"
                     "%% FIXME(org-anniversary yyyy mm dd) "
                     "${title}'s %d%s birthday\n"
                     "- phone ::\n"
                     "- address ::\n"
                     "\n%?"))
           :target ,people-target
           :empty-lines-before 1)

          ;; NOTE: `ic//captured-url' is bound in `zetian-protocol-ref'.
          ("R" "reference note" plain ""
           :target ,(zetian--capture-template
                     :type "ref" :file-tags ":review:"
                     :tail "\n\n[[%(identity ic//captured-url)][Source]]\n\n")
           :immediate-finish t)
          )))

  (defun zetian-capture-select-template ()
    "Return selected template key as a string, NIL otherwise."
    (let* ((org-capture-templates org-roam-capture-templates)
           (selected (org-capture-select-template)))
      (when (consp selected)
        (car selected))))
#+END_SRC

These templates are used from =org-capture-protocol=.
#+BEGIN_SRC emacs-lisp
  (setq org-roam-capture-ref-templates
        `(("W" "web zettel (org-protocol)" plain
           ,(concat
             "* %<%Y-%m-%d %H:%M:%S>\n"
             "#+begin_quote\n${body}\n#+end_quote\n\n%?")
           :target ,(zetian--capture-template
                     :file-name (concat zetian-refnote-dir
                                        "%(secure-hash 'sha1 \"${ref}\").org")
                     :file-cat "ref" :title "refnote ${title}"
                     :tail "\n\nsource: [[%:link][${title}]]\n\n")
           :unnarrowed t)))
#+END_SRC

I have a link setup in =firefox= with the following href to integrate into =org-roam-protocol=.
#+BEGIN_SRC javascript :tangle no
  javascript:location.href='org-protocol://roam-ref?'+ new URLSearchParams({template: "W", ref: location.href, title: document.title, body: window.getSelection()})
#+END_SRC

*** Opening notes
When I call =org-roam-node-find= and the node is an =org-mode= element rather than a file. I want my view narrowed to that specific element.
#+BEGIN_SRC emacs-lisp
  (defun zetian-node-find (&optional node)
    "Act like `org-roam-node-find', but create a narrowed indirect buffer when
    visiting an element (as opposed to a file)."
    (interactive)
    (when-let (node (or node (zetian-search nil "Find or create note" t)))
      (if-let ((guid (org-roam-node-id node))
               (title (org-roam-node-title node))
               (buf-name (format "zetian: %s" title)))
          (let ((buf (get-buffer buf-name))
                (loc (org-id-find guid)))
            (cond
             ((buffer-live-p buf)
              (pop-to-buffer-same-window buf))
             (loc
              (find-file (car loc))
              (widen)
              (goto-char (cdr loc))
              (if (not (org-at-heading-p))
                  ;; we're in a file based node
                  (progn
                    (rename-buffer buf-name)
                    (zetian-mode))
                ;; or we're in a heading based node
                (pop-to-buffer-same-window
                 (make-indirect-buffer (current-buffer) buf-name t))
                ;; jit-lock-mode isn't supported in indirect buffers, so disable
                ;; it.
                (make-local-variable 'font-lock-support-mode)
                (setq font-lock-support-mode nil)
                (goto-char (cdr loc))
                (org-narrow-to-subtree)))
             (t
              (find-file (org-roam-node-file node))
              (rename-buffer buf-name)
              (zetian-mode))))
        (error "could not lookup zetian node: %s" (org-id-find (org-roam-node-id node))))))
#+END_SRC

*** Bulk org-roam node searching and creation
=org-roam= does not expose a way to create multiple nodes at once. As most of zetian's search functions return a list of nodes I need an efficient way to create those nodes. I've tried calling =org-roam-node-populate= for each node: that "works", but is getting to be too slow to use. I'll use a modified version of =org-roam-node-list= to base it off of.

#+BEGIN_SRC emacs-lisp
  (setq zetian-sql-query-all
        "SELECT
    id,
    file,
    filetitle,
    \"level\",
    todo,
    pos,
    priority ,
    scheduled ,
    deadline ,
    title,
    properties ,
    olp,
    atime,
    mtime,
    '(' || group_concat(tags, ' ') || ')' as tags,
    aliases,
    refs
  FROM
    (
    SELECT
      id,
      file,
      filetitle,
      \"level\",
      todo,
      pos,
      priority ,
      scheduled ,
      deadline ,
      title,
      properties ,
      olp,
      atime,
      mtime,
      tags,
      '(' || group_concat(aliases, ' ') || ')' as aliases,
      refs
    FROM
      (
      SELECT
        nodes.id as id,
        nodes.file as file,
        nodes.\"level\" as \"level\",
        nodes.todo as todo,
        nodes.pos as pos,
        nodes.priority as priority,
        nodes.scheduled as scheduled,
        nodes.deadline as deadline,
        nodes.title as title,
        nodes.properties as properties,
        nodes.olp as olp,
        files.atime as atime,
        files.mtime as mtime,
        files.title as filetitle,
        tags.tag as tags,
        aliases.alias as aliases,
        '(' || group_concat(RTRIM (refs.\"type\", '\"') || ':' || LTRIM(refs.ref, '\"'), ' ') || ')' as refs
      FROM nodes
      LEFT JOIN files ON files.file = nodes.file
      LEFT JOIN tags ON tags.node_id = nodes.id
      LEFT JOIN aliases ON aliases.node_id = nodes.id
      LEFT JOIN refs ON refs.node_id = nodes.id
      GROUP BY nodes.id, tags.tag, aliases.alias )
    GROUP BY id, tags )
  GROUP BY id")

  (defun zetian--bulk-node-query (&optional ids)
    (cond
     ;; no ids: run bare query
     ((null ids)
      zetian-sql-query-all)
     ;; list of ids: filter based on bare ids
     ((listp ids)
      (emacsql-format
       (emacsql-prepare
        (format "SELECT * FROM (%s) WHERE id IN $v1"
                zetian-sql-query-all))
       (apply #'vector ids)))
     ;; vector found: filter based on sub-query
     ((vectorp ids)
      (emacsql-format
       (emacsql-prepare
        (format "SELECT * FROM (%s) WHERE id IN (%s)"
                zetian-sql-query-all
                (replace-regexp-in-string
                 "%" "%%"
                 (emacsql-format
                  (emacsql-prepare ids)))))))))

  (defun zetian-bulk-node-populate (&optional ids)
    "Return a list of org-roam-nodes that match IDS.
  IDS can either be an `emacsql' query selecting a list of ids or a vector of
    string ids or NIL to return the entire database."
    (let ((rows (org-roam-db-query (zetian--bulk-node-query ids))))
      (cl-loop for row in rows
               append (pcase-let* ((`(,id ,file ,file-title ,level ,todo ,pos ,priority ,scheduled ,deadline
                                          ,title ,properties ,olp ,atime ,mtime ,tags ,aliases ,refs)
                                    row)
                                   (all-titles (cons title aliases)))
                        (mapcar (lambda (temp-title)
                                  (org-roam-node-create :id id
                                                        :file file
                                                        :file-title file-title
                                                        :file-atime atime
                                                        :file-mtime mtime
                                                        :level level
                                                        :point pos
                                                        :todo todo
                                                        :priority priority
                                                        :scheduled scheduled
                                                        :deadline deadline
                                                        :title temp-title
                                                        :aliases aliases
                                                        :properties properties
                                                        :olp olp
                                                        :tags tags
                                                        :refs refs))
                                all-titles)))))
#+END_SRC

*** Searching
I want a way to search through =zetian= in a fast, easy, and general manor.
#+BEGIN_SRC emacs-lisp
  (defvar zetian--readline-histories nil
    "An ALIST of histories to use with `completing-read'.")

  (defun zetian-search-find (&optional query prompt create)
    "Search zetian for QUERY and navigate to chosen buffer. When CREATE is
  non-nil allow user to create a new node."
    (interactive)
    (when-let ((node (zetian-search query create prompt)))
      (zetian-node-find node)))

  (defun ic/org-roam-node-body (node)
    "Return the text contents of NODE"
    (save-excursion
      (with-temp-buffer
        (insert-file-contents-literally (org-roam-node-file node))
        (when (< 0 (org-roam-node-level node))
          (org-mode)
          (widen)
          (goto-char (org-roam-node-point node))
          (org-narrow-to-subtree))
        (buffer-string))))

  (defun zetian-query (&optional query)
    "Run QUERY against `org-roam' database."
    (zetian-bulk-node-populate
     (and query (zetian--unroll-query query))))

  (defun zetian-query-1 (query)
    "Run QUERY against zetian and return the first result. Signal an error when
    receiving zero or more than one result."
    (let* ((results (zetian-query query))
           (count (length results)))
      (if (not (= count 1))
          (error "zetian-query-1 received %s results from: %S"
                 count query)
        (car results))))

  (defun zetian--unroll-query (query)
    "Translate QUERY into a suitable `emacsql' query."
    `[:select [nodes:id]
      :from nodes
      :where ,(zetian--unroll-query-impl query)])

  (defun zetian--unroll-query-impl (query)
    (cl-flet ((parse #'zetian--unroll-query-impl)
              (parse-like #'zetian--query-quote-like)
              (parse-date #'zetian--query-parse-date)
              (parse-id #'zetian--query-parse-id))
      (let ((atom (and (consp query) (car query)))
            (args (and (consp query) (cdr query)))
            (first (and (consp query) (cadr query)))
            (second (and (consp query) (caddr query))))
        (pcase (type-of query)
          ('string
           query)
          ('org-roam-node
           (org-roam-node-id query))
          ('cons
           (pcase atom
             ('and
              `(and ,@(mapcar #'parse args)))
             ('or
              `(or ,@(mapcar #'parse args)))
             ('not
              `(not ,(parse first)))
             ('tag
              `(in nodes:id [:select [tags:node-id]
                             :from tags
                             :where (= tags:node-id nodes:id)
                             :and (= tags:tag ,(parse first))]))
             ('title
              `(like title ,(parse-like t (parse first))))
             ('title-like
              `(like title ,(parse-like nil (parse first))))
             ('todo
              `(like todo ,(parse-like t (parse first))))
             ('type
              (parse `(tag ,(concat zetian--type-cookie (parse first)))))
             ('priority
              `(= priority ,(string-to-char (upcase (parse first)))))
             ((or 'scheduled 'deadline)
              (let ((col (make-symbol (format "nodes:%s" atom))))
                (pcase first
                  ('after
                   `(> ,col ,(parse-date (parse second))))
                  ('before
                   `(< ,col ,(parse-date (parse second))))
                  ;; ('on-or-after
                  ;;  `(>= ,col ,(zetian--query-parse-date (caddr query))))
                  ;; ('on-or-before
                  ;;  `(<= ,col ,(zetian--query-parse-date (caddr query))))
                  ('on
                   (let ((date (parse-date (parse second))))
                     `(<= ,date ,col ,date)))
                  ('between
                   `(<= ,(parse-date (parse second))
                        ,col
                        ,(parse-date (parse (cadddr query)) t)))
                  ('none
                   `(is ,col nil))
                  (_
                   (error "invalid operation for %S: %S" atom first)))))
             ('level
              ;; '(level < 42) becomes '(< "level" 42)
              `(,first nodes:level ,second))
             ('prop
              `(like
                nodes:properties
                ,(parse-like nil (cons (parse first) (parse second)))))
             ('category
              (parse `(prop "CATEGORY" ,first)))
             ('created-on
              `(like
                nodes:properties
                ,(parse-like nil (cons "DATE_CREATED"
                                       (zetian--query-parse-date-like
                                        (parse first))))))
             ('last-modified-on
              `(like
                nodes:properties
                ,(parse-like nil (cons "LAST_MODIFIED"
                                       (zetian--query-parse-date-like
                                        (parse first))))))
             ((or 'links-to 'links-from)
              (let ((col1 (if (eq 'links-to atom) 'links:source 'links:dest))
                    (col2 (if (eq 'links-to atom) 'links:dest 'links:source)))
                `(in nodes:id [:select [,col1]
                               :from links
                               :where (= ,col1 nodes:id)
                               :and (= links:type "id")
                               :and (= ,col2 ,(parse-id (parse first)))])))
             ('has
              (let* ((col (cond ((eq 'links-to first)
                                 'links:dest)
                                ((eq 'links-from first)
                                 'links:source)
                                (_
                                 (error "invalid option for 'has: %S" first)))))
                `(in nodes:id [:select [,col]
                               :from links
                               :where (= links:type "id")])))
             ('eval
              (parse (eval first)))
             (_
              (error "invalid search key: %S" atom))))
          (_
           (error "invalid query: %S" query))))))

  (defun zetian--query-quote-like (exact obj)
    "Return quoted OBJ in a form for `emacsql' query: (like column
  ,(zetian--query-quote-like (cons 'a 'b)))"
    (let ((double-quote "\"")
          (maybe-percent (unless exact "%%")))
      `(quote ,(if (stringp obj)
                   (concat double-quote maybe-percent
                           obj
                           maybe-percent double-quote)
                 (concat maybe-percent
                         (prin1-to-string obj)
                         maybe-percent)))))

  (defun zetian--query-parse-date (date &optional next-day-when-no-time)
    (format-time-string "%Y-%m-%dT%H:%M:%S%z"
                        (ic-parse-org-date-string
                         date
                         next-day-when-no-time)))

  (defun zetian--query-parse-date-like (date &optional next-day-when-no-time)
    (format-time-string "[%Y-%m-%d%%%%]"
                        (ic-parse-org-date-string
                         date
                         next-day-when-no-time)))

  (defun zetian--query-parse-id (obj)
    (cond
     ((org-roam-node-p obj)
      (org-roam-node-id obj))
     ((stringp obj)
      (org-roam-node-id
       (or (org-roam-node-from-id obj)
           (org-roam-node-from-title-or-alias obj))))
     (t
      (error "invalid zetian id: %S" obj))))
#+END_SRC

*** Saved Searches
#+BEGIN_SRC emacs-lisp
  (defmacro def-zetian-query (sym query &optional form skip-completing-read)
    (declare (indent 1))
    (let* ((name (symbol-name sym))
           (pretty-name (replace-regexp-in-string "-" " " name))
           (q-sym (intern (format "zetian-query-%s" name)))
           (f-sym (intern (format "zetian-find-%s" name)))
           (s-sym (intern (format "zetian-search-%s" name))))
      `(progn
         ,(when query
            `(setq ,q-sym ,query))
         (defun ,q-sym (&optional include-archive)
           ,(format
             (concat "Return a list of all %s zetian nodes.\nIgnore archive notes "
                     "unless INCLUDE-ARCHIVE is non-nil.")
             pretty-name)
           ,(if query
                `(zetian-query (if include-archive
                                   ,q-sym
                                 `(and ,,q-sym (not ,zetian-query-archive))))
              form))
         (defun ,s-sym (&optional arg)
           ,(format
             (concat "Search zetian for any %s note, return user selected node.\n"
                     "Ignore archive notes unless universal argument given.")
             pretty-name)
           (interactive "P")
           ,(if skip-completing-read
                `(,q-sym (equal arg '(4)))
              `(zetian-completing-read (,q-sym (equal arg '(4)))
                                       (concat ,pretty-name " notes"
                                               (when (equal arg '(4))
                                                 " (include archive)")))))
         (defun ,f-sym (&optional arg)
           ,(format
             (concat "Search zetian for any %s note, prompt user for selection and "
                     "navigate to the buffer.\nIgnore archive tags unless"
                     "universal argument given.")
             pretty-name)
           (interactive "P")
           (when-let ((node (,s-sym arg)))
             (zetian-node-find node))))))

  (defmacro def-zetian-query-function (sym &rest body)
    (declare (indent 1))
    `(def-zetian-query ,sym nil ,@body))

  ;; needs to come first as the macros use it
  (def-zetian-query archive
    '(tag "archive"))

  (defun zetian--fix-archive-query (func &rest _)
    "Fix `zetian-query-archive' filtering out the notes we want to see.
  Zetian filters out archive notes by default, which fails when we want to view
  only archive notes."
    (funcall func t))
  (advice-add 'zetian-query-archive :around #'zetian--fix-archive-query)

  ;; all notes
  (def-zetian-query all
    '(title-like ""))

  (def-zetian-query non-archive
    '(not (tag "archive")))

  ;; things
  (def-zetian-query category
    '(category (eval (completing-read "Category: " (zetian-all-categories)))))

  (def-zetian-query project
    '(type "project"))

  (def-zetian-query area
    '(type "area"))

  (def-zetian-query book
    '(type "book"))

  (def-zetian-query author
    '(type "author"))

  (def-zetian-query task
    '(type "task"))

  (def-zetian-query event
    '(type "event"))

  (def-zetian-query permanent
    '(type "perm"))

  (def-zetian-query refnote
    '(type "ref"))

  (def-zetian-query import
    '(type "import"))

  ;; tasks
  (def-zetian-query open
    '(or (todo "NEXT") (todo "TODO")))

  (def-zetian-query closed
    '(or (todo "DONE") (todo "CANCELLED")))

  (def-zetian-query next-task
    `(and ,zetian-query-task
          (todo "NEXT")))

  (def-zetian-query open-task
    `(and ,zetian-query-task
          ,zetian-query-open))

  (def-zetian-query next-project-task
    `(and ,zetian-query-next-task
          (links-to (eval (zetian-search-project)))))

  (def-zetian-query open-project-task
    `(and ,zetian-query-open-task
          (links-to (eval (zetian-search-project)))))

  (def-zetian-query nodes-with-project
    '(eval `(or ,@(mapcar (lambda (p) `(links-to ,(org-roam-node-id p)))
                          (zetian-query-project)))))

  (def-zetian-query tasks-without-project
    `(and ,zetian-query-task
          (not ,zetian-query-nodes-with-project)))

  (def-zetian-query open-tasks-without-project
    `(and ,zetian-query-open-task
          (not ,zetian-query-nodes-with-project)))

  ;; links
  (def-zetian-query link-to
    '(links-to (eval (zetian-search))))

  (def-zetian-query link-to-current
    '(links-to (eval (org-roam-node-at-point))))

  (def-zetian-query link-from
    '(links-from (eval (zetian-search))))

  (def-zetian-query link-from-current
    '(links-from (eval (org-roam-node-at-point))))

  ;; misc
  (def-zetian-query open-event
    `(and ,zetian-query-event
          ,zetian-query-open))

  (def-zetian-query open-task-or-event
    `(and (or ,zetian-query-task
              ,zetian-query-event)
          ,zetian-query-open))

  (def-zetian-query closed-task-or-event
    `(and (or ,zetian-query-task
              ,zetian-query-event)
          ,zetian-query-closed))

  (def-zetian-query unscheduled-open-task-or-event
    `(and ,zetian-query-open-task-or-event
          (scheduled none)))

  (def-zetian-query state
    '(tag (eval (completing-read "State: " (zetian-all-states)))))

  (def-zetian-query review
    '(tag "review"))

  (def-zetian-query-function random-review
    (seq-random-elt (zetian-query-review))
    'skip-completing-read)

  (def-zetian-query-function random-permanent
    (seq-random-elt (zetian-query-permanent))
    'skip-completing-read)

  ;; linting searches
  (def-zetian-query-function stuck-project
    (seq-filter
     (lambda (project)
       (not (zetian-query
             `(and ,zetian-query-open-task
                   (links-to ,project)))))
     (zetian-query-project)))

  (def-zetian-query-function stuck-area
    (seq-filter
     (lambda (area)
       (not (zetian-query
             `(and ,zetian-query-project
                   (links-to ,area)))))
     (zetian-query-area)))

  (def-zetian-query missing-outbound-links
    `(and ,zetian-query-permanent
          (not ,zetian-query-review)
          (not (has links-from))))

  (def-zetian-query missing-inbound-links
    `(and ,zetian-query-permanent
          (not ,zetian-query-review)
          (not (has links-to))))

  (def-zetian-query isolated
    `(and ,zetian-query-missing-inbound-links
          ,zetian-query-missing-outbound-links))

  (def-zetian-query permanent-created-today
    `(and ,zetian-query-permanent
          (created-on ".")))

  (def-zetian-query permanent-modified-today
    `(and ,zetian-query-permanent
          (last-modified-on ".")))

  ;; chores
  ;; I consider a chore to be any task or event that links to a project that is
  ;; under a specific list of areas.
  (setq zetian--project-chore-ids
        (mapcar 'org-roam-node-id
                (mapcan (lambda (area)
                          (zetian-query `(and ,zetian-query-project
                                              (links-to ,area))))
                        (zetian-query `(and ,zetian-query-area
                                            (or (title "Health")
                                                (title "Chores")
                                                (title "Finances")
                                                (title "social life")))))))

  (def-zetian-query chores
    `(or ,@(mapcar (lambda (proj)
                     `(links-to ,proj))
                   zetian--project-chore-ids)))

  (def-zetian-query open-chores
    `(and ,zetian-query-open-task-or-event
          ,zetian-query-chores))

  (def-zetian-query unscheduled-chores
    `(and ,zetian-query-open-chores
          (scheduled none)))

  (def-zetian-query tag-targets
    `(or ,zetian-query-permanent
         ,zetian-query-project
         ,zetian-query-area))
#+END_SRC

*** Search for search functions
zetian is starting to get a lot of search functions and I don't really like to have to keybind them all so let's write a function that let's us select a function to run.

#+BEGIN_SRC emacs-lisp
  (defun zetian--select-call-command (arg regex prompt &rest args)
    "Select and call any defined `zetian-find-*' function."
    (interactive "P")
    (let ((symbols))
      (mapatoms (lambda (sym)
                  (when (and (string-match-p regex (symbol-name sym))
                             (commandp sym))
                    (setq symbols (cons sym symbols)))))
      (when-let ((func-name (completing-read prompt symbols)))
        (apply (symbol-function (intern func-name)) arg args))))

  (defun zetian-select-find (&optional arg)
    (interactive "P")
    (zetian--select-call-command arg "^zetian-find-" "function: "))

  (defun zetian-select-search (&optional arg)
    (interactive "P")
    (zetian--select-call-command arg "^zetian-search-" "function: "))
#+END_SRC

*** Inserting Links
#+BEGIN_SRC emacs-lisp
  (defun zetian-node-link (node)
    "Return an `org-mode' link to NODE as a string."
    (org-make-link-string (concat "id:" (org-roam-node-id node))
                          (org-roam-node-title node)))

  (defun zetian-link (&optional immediate)
    "Query Zetian for a node and return an `org-mode' link as a string, creating
  the node if IMMEDIATE is non-nil."
    (interactive)
    (when-let ((node (zetian-search zetian-query-non-archive
                                    (concat "node to link"
                                            (when immediate
                                              " (create if needed)"))
                                    immediate)))
        (zetian-node-link node)))

  (defun zetian-link-immediate ()
    "Query Zetian for a node and return an `org-mode' link as a string, creating
  the node if needed."
    (interactive)
    (zetian-link t))

  (defun zetian-link-insert ()
    "Query Zetian for a node and insert a link at point."
    (interactive)
    (if-let ((link (zetian-link)))
        (insert link)
      (message "Error: specified zetian does not exist")))

  (defun zetian-link-insert-immediate ()
    "Query Zetian for a node and insert a link at point, creating the node if
    needed."
    (interactive)
    (insert (zetian-link-immediate)))

  (defun zetian-link-insert-search-immediate ()
    "Query zetian for a search function, call that function: insert a link to
    chosen node at point."
    (interactive)
    (when-let ((node (zetian-select-search)))
      (insert (zetian-node-link node))))

  (defun zetian-node-create (&optional title template-key)
    "Return zetian node for TITLE, creating it if necessary. Uses TEMPLATE-KEY to
  lookup template from `org-roam-capture-templates', when NIL prompt user for key."
    (if title
        (if-let (node (org-roam-node-from-title-or-alias title))
            ;; we have a title and an existing node
            node
          ;; we have a title, but the node needs to be created
          (let ((template (append
                           (assoc (or template-key
                                      (zetian-capture-select-template))
                                  org-roam-capture-templates)
                           '(:immediate-finish t)))
                (node (org-roam-node-create :title title)))
            (when (org-roam-capture-
                   :node node
                   :templates (list template))
              (or (org-roam-node-from-title-or-alias (org-roam-node-title node))
                  (org-roam-node-from-id (org-roam-node-id node))))))
      ;; we don't have a title, so prompt for one and retry
      (zetian-node-create (org-roam-node-title
                           (zetian-search nil "Zetian note: "))
                          template-key)))
#+END_SRC

*** Category
#+BEGIN_SRC emacs-lisp
  (defun zetian-set-category (&optional category)
    "Set the category of the node at point. If it's on a file, set the #+category:
    property, otherwise use the property drawer."
    (interactive)
    (let ((node (org-roam-node-at-point 'assert))
          (cat (or category (completing-read "Category: " nil))))
      (save-excursion
        (org-set-property "CATEGORY" cat))))

  (defun zetian-get-category ()
    "Return the category of node at point."
    (org-entry-get nil "CATEGORY"))
#+END_SRC

*** State
I use =org-mode= tags for state and =org-roam= provides a pair of functions that work with both file tags and element tags, so let's use those.
#+BEGIN_SRC emacs-lisp
  (defun zetian-org-get-tags-local-only (func &optional pos-or-element _)
    "Wrapper for `org-get-tags' to force LOCAL argument to t."
    (funcall func pos-or-element t))

  (defun zetian-add-state (state)
    "Add STATE to current zetian node."
    (advice-add #'org-get-tags :around #'zetian-org-get-tags-local-only)
    (unwind-protect
        (org-roam-tag-add (list state))      
      (advice-remove #'org-get-tags #'zetian-org-get-tags-local-only)))

  (defun zetian-remove-state (state)
    "Remove STATE from current zetian node."
    (advice-add #'org-get-tags :around #'zetian-org-get-tags-local-only)
    (unwind-protect
        (org-roam-tag-remove (list state))      
      (advice-remove #'org-get-tags #'zetian-org-get-tags-local-only)))

  (defun zetian-set-state (&optional arg)
    "Prompt user for a state to set, when given a universal-argument: remove
  instead."
    (interactive "P")
    (let ((remove (equal arg '(4))))
      (funcall (if remove 'zetian-remove-state 'zetian-add-state)
               (completing-read "state: "
                                (if remove (zetian-get-states) (zetian-all-states))))))

  (defun zetian-get-states (&optional include-hidden)
    "Return a list of states of node at point."
    (zetian-node-get-states (org-roam-node-at-point) include-hidden))

  (defun zetian-node-get-states (node &optional include-hidden)
    "Return a list of states of NODE"
    (seq-filter
     (lambda (tag)
       (or (not (equal (string-to-char tag) ?_))
           include-hidden))
     (org-roam-node-tags node)))

  (defun zetian-has-state (state)
    "Return true if STATE is a current state of node at point."
    (member state (zetian-get-states)))
#+END_SRC

*** Type
I use =type_FOO= tags to denote /what/ a =zetian= node is. I'll need a pair of functions to get/set that.
#+BEGIN_SRC emacs-lisp
  (defun zetian-set-type (&optional type)
    "Set the current node's zetian type to TYPE."
    (interactive)
    (when-let ((new-type (or type (completing-read "Type: " nil))))
      (when-let ((old-type (zetian-get-type)))
        (zetian-remove-state (concat zetian--type-cookie old-type)))
      (zetian-add-state (concat zetian--type-cookie new-type))))

  (defun zetian-get-type ()
    "Return the current node's zetian type."
    (zetian-node-get-type (org-roam-node-at-point)))

  (defun zetian-node-get-type (node)
    "Return the NODE's zetian type."
    (unless node
      (error "No node found."))
    (if-let ((states (zetian-node-get-states node t)))
        (when-let ((types
                    (seq-filter (lambda (s)
                                  (s-starts-with-p zetian--type-cookie s))
                                states)))
          (if (= 1 (length types))
              (string-remove-prefix zetian--type-cookie (car types))
            (error "More than one type found on node.")))
      (error (format "No states found on node: %s"
                     (substring-no-properties
                      (org-roam-node-title node))))))
#+END_SRC

*** Last Modified
Keep track of the last time a node was modified through the =org-mode= property =LAST_MODIFIED=.

#+BEGIN_SRC emacs-lisp
  (defun zetian-get-last-modified ()
    "Return the `org-mode' timestamp of the last time this node was modified."
    (org-entry-get nil "LAST_MODIFIED"))

  (defun zetian-set-last-modified ()
    "Set the `org-mode' timestamp of the last time this node was modified to now."
    (save-excursion
      (goto-char (point-min))
      (org-entry-put nil
                     "LAST_MODIFIED"
                     (with-temp-buffer
                       (org-time-stamp-inactive '(16))
                       (buffer-string)))))
#+END_SRC

*** Update Agenda Files
Ensure that =org-agenda= can find the relevant notes.
#+BEGIN_SRC emacs-lisp
  (defun zetian-refresh-agenda-list ()
    "Search zetian for any files with an 'agenda' tag and add them to
  `org-agenda-files'."
    (interactive)
    (mapc (lambda (node)
            (add-to-list 'org-agenda-files
                         (org-roam-node-file node)))
          (zetian-query '(tag "agenda"))))

  (defun zetian--update-agenda-files-on-load ()
    "Call `zetian-refresh-agenda-list' from `after-init-hook'."
    (remove-hook 'after-init-hook #'zetian--update-agenda-files-on-load)
    (zetian-refresh-agenda-list))
  (add-hook 'after-init-hook #'zetian--update-agenda-files-on-load)
#+END_SRC

*** Header Links
**** Modifying header
I want an easy way to add/update tags and other links on a given zettel. To start I'm probably just going to use /Tags/, but I could see myself using other forms as well, (maybe /Depends/ for moving my emacs config into zettels?). So I'll call them =header-links=.

#+BEGIN_SRC emacs-lisp
  (defvar zetian-header-formats '((context . "context: ")
                                  (project . "project: ")
                                  (tags . "tags: ")))
  (defvar zetian-header-seperator ", ")


  (defun zetian-set-header-links (type links)
    (setq links (seq-uniq links))
    (sort links (lambda (n1 n2)
                  (string< (org-roam-node-title n1)
                           (org-roam-node-title n2))))
    (let* ((other-types (seq-filter (lambda (s) (not (eq s type)))
                                    (mapcar 'car zetian-header-formats)))
           (other-links (mapcar (lambda (type)
                                  (cons type (zetian-get-header-links type)))
                                other-types))
           (all-links (cons (cons type links) other-links)))
      (zetian--overwrite-header all-links)))

  (defun zetian--overwrite-header (all-links)
    "Set the entire header with the alist ALL-LINKS."
    (with-zetian-node (org-roam-node-at-point)
      (zetian--remove-header)
      (let (inserted-header)
        (dolist (type (mapcar 'car zetian-header-formats))
          (when-let ((links (assoc-default type all-links)))
            (setq inserted-header t)
            (insert
             (assoc-default type zetian-header-formats)
             (mapconcat #'zetian-node-link links zetian-header-seperator)
             "\n")))))
    ;; when overwriting a header and the point is on the initial content character
    ;; the point is moved to the start of the header, so move back to the content.
    (when (zetian--looking-at-header)
      (while (and (not (= (point) (point-max)))
                  (or (zetian--looking-at-header)
                      (looking-at "^$")))
        (forward-line 1))))

  (defun zetian--remove-header ()
    "Remove the header from the current note.
  Leave point where the header would be."
    (goto-char (point-min))
    (re-search-forward "^$")
    (let ((bot (point))
          top)
      (forward-line -1)
      (while (zetian--looking-at-header)
        (setq top (point))
        (forward-line -1))
      (when top
        (delete-region top bot))
      (forward-line 1)))

  (defun zetian-get-header-links (type)
    "Return list of nodes contained in zetian header TYPE."
    (with-zetian-node (org-roam-node-at-point)
      (let ((header (assoc-default type zetian-header-formats)))
        (goto-char (zetian--header-pos type))
        (when (looking-at header)
          (forward-char (length header))
          (let ((start (point))
                links done)
            (while (not done)
              ;; is the point on an org link?
              (if-let ((elem (org-element-link-parser)))
                  (progn
                    (setq links (cons (org-roam-node-from-id
                                       (org-element-property :path elem))
                                      links))
                    ;; move to the end of the link
                    (goto-char (org-element-property :end elem))
                    ;; try and move over `zetian-header-seperator'
                    (re-search-forward
                     (regexp-quote zetian-header-seperator)
                     (+ (point) (length zetian-header-seperator))
                     t)
                    ;; keep going if we're looking at another org link
                    (setq done (not (looking-at (regexp-quote "[[")))))
                ;; point was not on an org link, so we're done
                (setq done t)))
            links)))))

  (defun zetian--header-pos (type)
    "Return start position of header TYPE.
  If header TYPE doesn't exist: return the position it would have if it existed."
    (let ((header-end (zetian--header-end-pos))
          (header (assoc-default type zetian-header-formats)))
      (save-excursion
        (goto-char (point-min))
        (condition-case err
            (progn
              (re-search-forward (concat "^" (regexp-quote header))
                                 header-end)
              (match-beginning 0))
          (search-failed
           header-end)))))

  (defun zetian--header-end-pos ()
    "Return the position of the newline separating the header from the content."
    (save-excursion
      (goto-char (point-min))
      (re-search-forward "^$")
      (match-end 0)))

  (defun zetian--looking-at-header (&optional type)
    "Return non-nil when POINT is on header TYPE.
  When TYPE is nil check for any type."
    (let ((types (if type
                     (list type)
                   (mapcar #'car zetian-header-formats))))
      (-any? (lambda (type)
               (looking-at
                (regexp-quote (assoc-default type zetian-header-formats)))) 
             types)))
#+END_SRC

**** Tags
=zetian= tags are really just plain =org-mode= links that are stored near the top of the file.
#+BEGIN_SRC emacs-lisp
  (defun zetian-get-tags ()
    "Return the tags of the node at point."
    (save-excursion (zetian-get-header-links 'tags)))

  (defun zetian-set-tag (&optional arg)
    "Set a tag on the current node.
  Removes a tag when the universal argument is set."
    (interactive "P")
    (let ((tags (zetian-get-header-links 'tags))
          (removing (equal arg '(4))))
      (when-let ((node (if removing
                           (zetian-completing-read tags)
                         (zetian-search zetian-query-tag-targets
                                        "add tag" t))))
        (setq tags (if removing
                       (delete node tags)
                     (cons node tags)))
        (zetian-set-header-links 'tags tags))))
#+END_SRC

**** Project
A =zetian= node can have a project associated with it. Like tags a project is simply an =org-mode= link stored near the top of the file.
#+BEGIN_SRC emacs-lisp
  (defun zetian-get-project ()
    "Return the project associated with the node at point."
    (car (zetian-get-header-links 'project)))

  (defun zetian-set-project (&optional arg)
    "Set the project for the current node."
    (interactive "P")
    (let* ((remove (equal arg '(4)))
           (new-project (unless remove
                          (zetian-search-project))))
      (zetian-set-header-links 'project (unless remove (list new-project)))))

  (defun zetian-node-to-state (&optional node)
    "Return a string suitable for an org-mode tag from the NODE's title."
    (concat "_"
            (replace-regexp-in-string (rx (not (any alnum "@_")))
                                      "_"
                                      (org-roam-node-title
                                       (or node (org-roam-node-at-point t))))))

  (defun zetian-node-from-state (state)
    "Return a zetian node given a project STATE."
    (unless (= (string-to-char state) ?_)
      (error "Not a valid project state: %s" state))
    (zetian-query-1 `(title-like ,(substring state 1))))
#+END_SRC

**** Context
A =zetian= node can be a conversation so we want to keep the context of the notes the current note is building off of.

#+BEGIN_SRC emacs-lisp
  (defun zetian-get-context ()
    "Return the context links of the node at point."
    (zetian-get-header-links 'context))

  (defun zetian-set-context (&optional arg)
    "Set a context on the current node.
  Removes a tag when the universal argument is set."
    (interactive "P")
    (let ((links (zetian-get-header-links 'context))
          (removing (equal arg '(4))))
      (when-let ((node (if removing
                           (zetian-completing-read links)
                         (zetian-search nil "add context" t))))
        (setq links (if removing
                        (delete node links)
                      (cons node links)))
        (zetian-set-header-links 'context links))))
#+END_SRC

*** Title
#+BEGIN_SRC emacs-lisp
  (defun zetian-get-title ()
    "Return the title from the current zetian node."
    (when-let ((node (org-roam-node-at-point)))
      (org-roam-node-title node)))
#+END_SRC

*** Meta Information
Sometimes I want some information about the entire state of =Zetian=.

#+BEGIN_SRC emacs-lisp
  (defun zetian-all-states (&optional include-hidden)
    "Return a list of all states (org tags) in the zetian database."
    (let ((results (org-roam-db-query
                    `[:select :distinct tag
                      :from tags
                      ,@(unless include-hidden
                          '(:where tag :not :like '"\"\\_%\""
                            :escape '"\\"))])))
      (sort (mapcar #'car results)
            #'string-collate-lessp)))

  (defun zetian-all-categories ()
    "Returns a list of all categories in the zetian database. Note: does a full
  table search."
    (let ((results
           (seq-reduce
            (lambda (cats node)
              (let ((cat (assoc-default "CATEGORY"
                                        (org-roam-node-properties node))))
                (if (member cat cats)
                    cats
                  (cons cat cats))))
            (org-roam-node-list)
            '())))
      (sort results #'string-collate-lessp)))
#+END_SRC

*** Copy ID
I'd like a function to copy the current node's id, both to the =kill-ring= and to the system clipboard.
#+BEGIN_SRC emacs-lisp
  (defun zetian-kill-id ()
    "Add the current node's id to the kill ring and system clipboard."
    (interactive)
    (when-let ((node (org-roam-node-at-point)))
      (with-temp-buffer
        (insert (org-roam-node-id node))
        (clipboard-kill-ring-save 1 (point))
        (message "%S" (buffer-string)))))
#+END_SRC

*** OpenLibrary Book Import
Let's migrate my book importing code to =org-roam=.
#+BEGIN_SRC emacs-lisp
  (defun zetian--format-template (book filename)
    "Load the `yas-snippet' found in FILENAME with the environment from BOOK"
    (with-temp-buffer
      (unless (yas-minor-mode 1)
        (error "failed to load yas-minor-mode"))
      (let ((snippet-env
             (append
              (mapcar (lambda (c)
                        (list (car c)
                              (if (listp (cdr c))
                                  `(quote ,(cdr c))
                                (cdr c))))
                      book)
              `((authors-pretty
                 ,(string-join (assoc-default 'authors book)
                               ", and "))
                (authors-pretty-links
                 ,(string-join (mapcar
                                (lambda (author)
                                  (zetian-node-link
                                   (zetian-node-create author "P")))
                                (assoc-default 'authors book))
                               ", and "))
                (authors-emacs-list
                 ,(format "%S" (assoc-default 'authors book)))
                (author-ol-links
                 ,(string-join
                   (mapcar
                    (lambda (tuple)
                      (format "- [[https://openlibrary.org/authors/%s][OpenLibrary - %s]]"
                              (cdr tuple)
                              (car tuple)))
                    (-zip-pair (assoc-default 'authors book)
                               (assoc-default 'ol-author-ids book)))
                   "\n"))
                (maybe-quote
                 ,(when-let ((desc (assoc-default 'description book)))
                    (format "#+begin_quote\n%s\n#+end_quote\n\n" desc)))
                (lt-uri
                 ,(if-let (id (assoc-default 'librarything-id book))
                      (format "/work/%s" id)
                    (format "/search.php?search=%s"
                            (assoc-default 'query-title book))))
                (gr-uri
                 ,(if-let (id (assoc-default 'goodreads-id book))
                      (format "/book/show/%s" id)
                    (format "/search?q=%s&search_type=books"
                            (assoc-default 'query-title book))))))))
        (yas-expand-snippet
         (with-temp-buffer
           (insert-file-contents
            (locate-user-emacs-file filename))
           (buffer-string))       
         nil
         nil
         snippet-env))
      (buffer-string)))

  (defun zetian-capture-book (&optional tag)
    "Import a book from OpenLibrary, optionally applying zetian TAG."
    (interactive)
    (let* ((book (ic/openlibrary-find-book))
           (title (assoc-default 'title book))
           (template `("p" "capture book template" plain
                       ,(zetian--format-template
                         book "data/templates/capture-book-body.org")
                       :target (file+head
                                "%<%Y%m%d%H%M%S>-${id}.org"
                                ,(zetian--format-template
                                  book "data/templates/capture-book-header.org")))))
      (cl-letf ((org-roam-capture-templates (list template)))
        (when-let ((node (zetian-node-create title "p")))
          (when tag
            (if-let ((tag-node (org-roam-node-from-title-or-alias tag)))
                (save-excursion
                  (zetian-node-find tag-node)
                  (goto-char (point-max))
                  (insert "- " (zetian-node-link node) "\n")
                  (save-buffer))
              (error "Invalid zetian tag: %s" tag)))
          ;; end visiting the captured book's node
          (zetian-node-find node)))))

  (defun zetian-capture-book-pleasure-toread ()
    "Import a book from OpenLibrary, and apply the 'Read for Pleasure' tag."
    (interactive)
    (zetian-capture-book "Read for Pleasure"))

  (defun zetian-capture-book-pleasure-completed ()
    "Import a book from OpenLibrary, and apply the 'Completed Pleasure Books' tag."
    (interactive)
    (zetian-capture-book "Completed Pleasure Books"))

  (defun zetian-capture-book-enrichment-toread ()
    "Import a book from OpenLibrary, and apply the 'Read for Enrichment' tag."
    (interactive)
    (zetian-capture-book "Read for Enrichment"))

  (defun zetian-capture-book-enrichment-completed ()
    "Import a book from OpenLibrary, and apply the 'Completed Enrichment Books' tag."
    (interactive)
    (zetian-capture-book "Completed Enrichment Books"))
#+END_SRC

*** Integrate with completing-read
Here we'll integrate =zetian= with emacs built-in =completing-read= api. We'll also annotate each item as ='zetian= so further packages (=marginalia= / =embark=) can key off the category.
#+BEGIN_SRC emacs-lisp
  (defun zetian-completing-read (&optional nodes query-name create)
    (interactive)
    (let*
        ((candidates
          (mapcar
           (lambda (node)
             ;; add 'zetian-node to the title's properties so we can reference
             ;; it later.
             (let ((title (org-roam-node-title node)))
               (add-text-properties 0 1 `(zetian-node ,node) title)
               (cons title node)))
           nodes))
         (completing-func
          (lambda (input predicate action)
            (if (eq action 'metadata)
                '(metadata (category . zetian))
              (complete-with-action action candidates input predicate))))
         (prompt (if query-name
                     (format "[%s]: " query-name)
                   "Zetian Node: "))
         (selection (completing-read prompt completing-func)))
      (if-let ((node (assoc-default selection candidates)))
          (prog1 node
            ;; remove the 'zetian-node property added to the title
            (remove-text-properties
             0 1 '(zetian-node) (org-roam-node-title node)))
        (when create
          (zetian-node-create selection)))))

  (defun zetian-search (&optional query prompt create)
    (interactive)
    (zetian-completing-read (zetian-query query) prompt create))

  (defun zetian-capture ()
    "Similar to `org-roam-capture' and `org-capture', but for Zetian. Will
  auto-complete the capture template."
    (interactive)
    (zetian-node-find
     (zetian-completing-read (zetian-query-all) "all nodes" t)))
#+END_SRC

*** Integrate with marginalia
Let's tell =marginalia= how to annotate zetian nodes so we get pretty completions.
#+BEGIN_SRC emacs-lisp
  (defvar zetian--org-done-keywords nil
    "Saved `org-done-keywords' so we can properly style todo items.")
  (with-eval-after-load 'org
    (setq zetian--org-done-keywords
          (with-temp-buffer
            (org-mode)
            org-done-keywords)))

  (defun zetian--completion-annotator (cand)
    "An annotator function for zetian nodes to be called from
  `completing-read'."
    (when-let ((node (get-text-property 0 'zetian-node cand)))
      (let* ((todo (org-roam-node-todo node))
             (todo-face (if (member todo zetian--org-done-keywords)
                            'org-done
                          'org-todo))
             (todo-str (if todo
                           (if (< 4 (length todo))
                               (concat (propertize (substring todo 0 4)
                                                   'face todo-face)
                                       ".")
                             (propertize todo 'face todo-face))
                         ""))
             (tags-str (string-join (zetian-node-get-states node) ":"))
             (type-str (zetian-node-get-type node))
             (pri (org-roam-node-priority node))
             (pri-str (if pri
                          (format "[#%s]" (char-to-string pri))
                        ""))
             ;; (contents (zetian--completion-get-contents node))
             )
        (marginalia--fields
         (type-str :face 'org-document-info
                   :truncate 8)
         (pri-str :face (org-get-priority-face pri)
                  :truncate 4)
         (todo-str :truncate 5)
         (tags-str :face 'org-tag
                   :truncate 20)
         ;; ("|" :width 1 :truncate 1)
         ;; (contents :face 'org-footnote
         ;;           :truncate 200)
         ))))

  (defun zetian--completion-get-contents (node)
    "Return the formatted contents of NODE as a string."
    (with-temp-buffer
      (insert (zetian-get-contents node))
      (goto-char (point-min))
      (re-search-forward "^$")
      (s-replace-regexp
       "\\[\\[.*\\]\\[\\(.*\\)\\]\\]"
       "\\1"
       (replace-regexp-in-string
        "\n" " "
        (buffer-substring-no-properties (point) (point-max))))))

  ;; add our annotator to marginalia
  (with-eval-after-load 'marginalia
    (add-to-list 'marginalia-annotator-registry
                 '(zetian zetian--completion-annotator builtin none)))
#+END_SRC

*** Import from Moonreader
I do most of my reading on the =moonreader+= app and I want a way to import from notes and highlights along with reading times from it.

**** map to zetian id
I need a way to map from the ebook filename to a =zetian= note id. First try and lookup the filename as an =org-mode= uid, if that doesn't work look it up in a mapping file, if not found prompt the user for a =zetian= node and save it in the mapping file.

#+BEGIN_SRC emacs-lisp
  (defvar zetian-ebook-mapping-file
    (concat org-roam-directory "/zetian-ebook-mapping.el")
    "The file to store ebook filename -> zetian id mappings.")

  (setq zetian--ebook-mapping
        (when (file-exists-p zetian-ebook-mapping-file)
          (with-temp-buffer
            (insert-file zetian-ebook-mapping-file)
            (read (buffer-string)))))

  (defun zetian--add-ebook-mapping (ebook)
    "Prompt the user for the zetian note that EBOOK should be associated with."
    (interactive)
    (when-let ((node (zetian-search '(type "book")
                                    (format "associate (%s) with book" ebook))))
      (push (cons ebook (org-roam-node-id node)) zetian--ebook-mapping)
      (with-temp-file zetian-ebook-mapping-file
        (insert (format "%S" zetian--ebook-mapping)))
      (org-roam-node-id node)))

  (defun zetian-node-from-ebook (filename)
    "Return the zetian node that the filename FILENAME is associated with, prompting
    the user to add a mapping if needed."
    (interactive)
    (let ((ebook (file-name-nondirectory filename)))
      (or (org-roam-node-from-id (file-name-base ebook))
          (org-roam-node-from-id (assoc-default ebook zetian--ebook-mapping))
          (org-roam-node-from-id (zetian--add-ebook-mapping ebook)))))
#+END_SRC

**** map to refnote
Now we need a way to lookup a reference note by the book's note.

#+BEGIN_SRC emacs-lisp
  (defun zetian-ref-node-from-book-node (book-node)
    "Return the 'reference note' Zetian node that refers to `book-node', creating
  it if needed."
    (let ((nodes (zetian-query `(and ,zetian-query-refnote
                                     (links-to ,book-node)))))
      (cond
       ((= 1 (length nodes))
        (car nodes))
       ((= 0 (length nodes))
        (zetian--create-refnote-node book-node))
       (t
        (error "more than one refnote found linking to %s"
               (org-roam-node-title book-node))))))

  (defun zetian--create-refnote-node (book-node)
    "Create a new refnote that refers to `book-node'."
    (let* ((id (org-id-new))
           (now (format-time-string "%Y%m%d%H%M%S"))
           (node-file (format "%sref/%s-%s.org" org-roam-directory now id)))
      (with-current-buffer
          (find-file-noselect node-file)
        (insert (ic/expand-snippet "refnote-head"
                                   'org-mode
                                   `((node ,book-node)
                                     (id ,id))))
        (save-buffer)
        (org-roam-db-sync)
        (org-roam-node-at-point))))
#+END_SRC

**** extract backup
#+BEGIN_SRC emacs-lisp
  (defvar zetian-moonreader-backup-dir
    "~/sync/moonreader/"
    "The directory to search for moonreader backup files.")

  (defun zetian--moonreader-backup-file ()
    "Return the filename of the moonreader backup file to process."
    (interactive)
    (when-let ((files (file-expand-wildcards
                       (concat zetian-moonreader-backup-dir "*.mrpro"))))
      (if (= 1 (length files))
          (car files)
        (completing-read "moonreader backup to process: " files))))

  (defun zetian--moonreader-extract (file)
    "Extract the moonreader zip backup FILE to a temporary directory, return the
  directory."
    (let ((tmpdir (concat temporary-file-directory "moonreader-extract/")))
      (when (file-exists-p tmpdir)
        (delete-directory tmpdir t))
      (make-directory tmpdir)
      (let ((ret (call-process "unzip" nil nil nil
                               "-q" (expand-file-name file)
                               "-d" (expand-file-name tmpdir))))
        (unless (= ret 0)
          (error "received exit %d from unzip" ret)))
      tmpdir))

  (defun zetian--moonreader-database-file (dir)
    "Return the sqlite database file under the extracted backup DIR."
    (let* ((base (concat dir "com.flyersoft.moonreaderp/"))
           (metadata
            (with-temp-buffer
              (insert-file-contents (concat base "_names.list"))
              (split-string (buffer-string) "\n")))
           (idx (-elem-index
                 "com.flyersoft.moonreaderp/databases/mrbooks.db"
                 metadata))
           (file (format "%s%d.tag" base (+ idx 1))))
      (if (file-exists-p file)
          file
        (error "Could not find database file under %s" dir))))

  (defun zetian--moonreader-highlights (db-file)
    "Given a sqlite db at DB-FILE: return a list of moonreader highlights in the
  form: ((ebook quoted-text note) ...)."
    (with-temp-buffer
      (call-process "sqlite3" nil t nil "-line" db-file
                    (concat "select filename, original, note, time "
                            "from notes order by time desc"))
      (goto-char (point-min))
      (let (result filename quoted note time)
        (while (re-search-forward "^filename = " nil t)
          (setq filename (buffer-substring-no-properties
                          (point) (line-end-position)))
          (re-search-forward "^original = ")
          (setq quoted (buffer-substring-no-properties
                        (point) (line-end-position)))
          (re-search-forward "^    note = ")
          (setq note (buffer-substring-no-properties
                      (point) (line-end-position)))
          (re-search-forward "^    time = ")
          (setq time (buffer-substring-no-properties
                      (point) (line-end-position)))
          (setq timestamp
                (format-time-string "[%Y-%m-%d %a %H:%M]"
                                    (seconds-to-time
                                     (/ (string-to-number time) 1000))))
          (push `((ebook . ,filename)
                  (quoted . ,quoted)
                  (note . ,note)
                  (timestamp . ,timestamp)
                  (checksum . ,(md5 (concat quoted note))))
                result))
        result)))

  (defun zetian--moonreader-expand-template (template highlight)
    "call `ic/expand-snippet' with the correct environment from HIGHLIGHT"
    (ic/expand-snippet template
                       'org-mode
                       (mapcar (lambda (c)
                                 (list (car c)
                                       (if (listp (cdr c))
                                           `(quote ,(cdr c))
                                         (cdr c))))
                               highlight)))

  (defun zetian--moonreader-import-highlight (highlight)
    "Import HIGHLIGHT into zetian if it's not already imported."
    (interactive)
    (when-let ((ebook (assoc-default 'ebook highlight))
               (book-node (zetian-node-from-ebook ebook))
               (ref-node (zetian-ref-node-from-book-node book-node))
               )
      (with-zetian-node ref-node
        (let ((checksum (assoc-default 'checksum highlight))
              (current-checksums
               (org-element-map (org-element-parse-buffer) 'headline
                 (lambda (elem)
                   (org-element-property :raw-value elem)))))
          (unless (member checksum current-checksums)
            (goto-char (point-max))
            (insert "\n")
            (insert (zetian--moonreader-expand-template
                     "refnote-content" highlight))
            t)))))

  (defun zetian-moonreader-import ()
    "Import any highlights from a moonreader backup in
  `zetian-moonreader-backup-dir'."
    (interactive)
    (if-let ((backup (zetian--moonreader-backup-file)))
        (let* ((tmpdir (zetian--moonreader-extract backup))
               (db-file (zetian--moonreader-database-file tmpdir))
               (highlights (zetian--moonreader-highlights db-file))
               imported)
          (dolist (highlight highlights)
            (when-let ((node (zetian--moonreader-import-highlight highlight)))
              (push node imported)))
          (message "imported %d new notes (%d total moonreader notes)"
                   (length imported) (length highlights))
          (delete-directory tmpdir t)
          (delete-file backup))
      (message "no moonreader backup file found")))
#+END_SRC

*** Contents
I'd like a way to open a buffer with a node's text without having too many open buffers in emacs.
#+BEGIN_SRC emacs-lisp
  (defun zetian-get-contents (&optional node)
    "Return the content of NODE as a string. If NODE is nil: use the node at
  point."
    (let ((node (or node (org-roam-node-at-point))))
      (with-temp-buffer
        (insert-file-contents
         (org-roam-node-file node))
        (goto-char (org-roam-node-point node))
        (org-mode)
        (when (org-at-heading-p)
          (org-narrow-to-element))
        (buffer-substring-no-properties (point) (point-max)))))
#+END_SRC

*** Rename note
I want to be able to rename a =zetian= note. This should not only change the title of the note, but any notes that link to it as well.

#+BEGIN_SRC emacs-lisp
  (defun zetian-rename-current ()
    "Rename the current note, updating any linking notes"
    (interactive)
    (when-let ((old-title (zetian-get-title)))
      (let ((new-title (read-from-minibuffer "new name: " old-title))
            (cur (org-roam-node-at-point))
            (inhibit-read-only t))
        (save-excursion
          (goto-char (point-min))
          (re-search-forward "^#\\+title: ")
          (delete-region (point)
                         (progn (end-of-line) (point)))
          (insert new-title))
        (rename-buffer (format "zetian: %s" new-title))
        (save-buffer)
        (dolist (node (zetian-query `(links-to ,new-title)))
          (save-excursion
            (with-current-buffer
                (find-file-noselect (org-roam-node-file node))
              (zetian--update-link-to (org-roam-node-id cur) new-title)
              (save-buffer)))))))

  (defun zetian--update-link-to (id desc)
    "In the current buffer: update all `org-mode' links to ID with the description
    DESC."
    (when id
      (goto-char (point-min))
      (let ((regex (format "\\[\\[id:%s\\]\\[\\(.*\\)\\]\\]" id)))
        (while (re-search-forward regex nil t)
          (save-restriction
            (narrow-to-region (match-beginning 0) (match-end 0))
            (replace-match desc t t nil 1))))))
#+END_SRC

*** Archive old tasks
I want any completed task to be moved out of it's current file and into an archive file (with an =archive= file-tag). This is mostly to keep the number of headings =org-agenda= needs to search to a reasonable amount.

#+BEGIN_SRC emacs-lisp
  (defun zetian-archive-completed-tasks ()
    "Move all completed zetian tasks and events into the archive."
    (interactive)
    ;; because we're modifying one file mostly: we want to work back-to-front or
    ;; end-to-beginning.
    (when-let ((nodes (sort (zetian-query-closed-task-or-event)
                       (lambda (n1 n2)
                         (< (org-roam-node-point n2)
                            (org-roam-node-point n1))))))
      (let ((touched-files (mapcar #'zetian-archive-task nodes)))
        (mapc (lambda (file)
                (with-current-buffer (find-file-noselect file)
                  (save-buffer)))
              (cons zetian-tasks-file
                    (-uniq touched-files))))
      (message "archived %d tasks" (length nodes))))

  (defun zetian-archive-task (node)
    "Move the zetian note NODE into the archive."
    (save-excursion
      (with-current-buffer
          (find-file-noselect (org-roam-node-file node))
        (goto-char (org-roam-node-point node))
        (let* ((org-log-refile nil)
               (org-refile-allow-creating-parent-nodes t)
               (props (org-roam-node-properties node))
               (closed (org-matcher-time (cdr (assoc "CLOSED" props))))
               (archive-file (zetian--get-archive-file closed)))
          (org-refile nil nil (list "" archive-file nil 1))
          (save-window-excursion
            (org-refile-goto-last-stored)
            (org-entry-put
             nil "ARCHIVED_ON" (with-temp-buffer
                                 (org-time-stamp-inactive '(16))
                                 (buffer-string))))
          archive-file))))

  (defun zetian--get-archive-file (ts)
    "Return the filename of the archive valid for TS, creating it if necessary."
    (let ((file (format-time-string zetian-tasks-archive-file-fmt ts)))
      (unless (file-exists-p file)
        (with-current-buffer (find-file-noselect file)
          (insert (concat ":PROPERTIES:\n"
                          ":ID: " (org-id-new) "\n"
                          ":END:\n"
                          "#+title: Archive of tasks for "
                          (format-time-string "%Y" ts) "\n"
                          "#+filetags: :_type_task:HOME:archive:\n"
                          "#+startup: all\n"
                          "\n"
                          "This is an archive of my completed tasks. All nodes in here should have the =archive= tag and /not/ an =agenda= tag. This will keep them out of zetian and org-agenda.
  "
                          "\n"))
          ;; we need to save the file before `org-refile' runs or it will create a
          ;; minibuffer prompt
          (save-buffer)))
      file))
#+END_SRC

*** Linter
I want a function to ensure that =zetian= remains healthy.
#+BEGIN_SRC emacs-lisp
  (defun zetian--lint-duplicates ()
    "Return a list of nodes that are duplicates of one another in the form
    ((NODE-A1 . NODE-A2) ...)"
    (let* ((results (org-roam-db-query
                     [:select [file title] :from files
                      :where (in title [:select title :from files
                                        :group :by title
                                        :having (> (funcall count *) 1)])
                      :order :by title])))
      (mapcar (lambda (x)
                (cons (car x)
                      (mapcar (lambda (n) (zetian--lint-node-from-file (car n)))
                              (cdr x))))
              (-group-by 'cadr results))))

  (defun zetian--lint-node-from-file (filename)
    (with-current-buffer (find-file-noselect filename)
      (org-roam-node-at-point)))

  (defun zetian--lint-broken-links ()
    "Return a list of broken links in the form ((NODE1 POS1 POS2) ...)."
    (let ((results (org-roam-db-query
                    [:select [source pos]
                     :from links
                     :where (and (= type "id")
                                 (not (in dest
                                          [:select id :from nodes])))])))
      (mapcar (lambda (x)
                (cons (org-roam-node-from-id (car x))
                      (mapcar 'cadr (cdr x))))
              (-group-by 'car results))))

  (defun zetian--lint-read-link-at-pos (node pos)
    "Return the link's description for NODE at POS within buffer."
    (with-current-buffer
        (find-file-noselect (org-roam-node-file node))
      (save-restriction
        (save-excursion
          (widen)
          (goto-char pos)
          (re-search-forward "\\[\\[.*\\]\\[\\(.*\\)\\]\\]")
          (buffer-substring-no-properties
           (match-beginning 1)
           (match-end 1))))))


  (defun zetian--lint-show-buffer (dups links stuck-projects stuck-areas
                                        tasks-without-project isolated)
    "Build and show a buffer with any errors found."
    (let ((buf (get-buffer-create "*zetian database lint*"))
          (now (format-time-string "[%Y-%m-%d %a %H:%M]")))
      (pop-to-buffer-same-window buf)
      (read-only-mode -1)
      (erase-buffer)
      (insert "#+title: zetian database lint\n\n")
      (insert (format "linting was run at %s\n" now))
      (when stuck-areas
        (insert (format "\n* %d stuck areas found\n" (length stuck-areas)))
        (dolist (area stuck-areas)
          (insert (format "- %s\n" (zetian-node-link area)))))
      (when stuck-projects
        (insert (format "\n* %d stuck projects found\n" (length stuck-projects)))
        (dolist (project stuck-projects)
          (insert (format "- %s\n" (zetian-node-link project)))))
      (when dups
        (insert (format "\n* %d duplicate titles found" (length dups)))
        (dolist (dup dups)
          (insert (format "\n** %s\n" (car dup)))
          (dolist (bad (cdr dup))
            (insert (format "- [[id:%s][%s]]\n"
                            (org-roam-node-id bad)
                            (file-relative-name
                             (org-roam-node-file bad)
                             org-roam-directory)))
            ;; (insert (format "in-links=%d out-links=%d\n"
            ;;                 (length (zetian-links-to bad))
            ;;                 (length (zetian-links-from bad))))
            )))
      (when links
        (insert (format "\n* %d nodes with broken links found" (length links)))
        (dolist (link links)
          (insert (format "\n** %s\n" (zetian-node-link (car link))))
          (dolist (pos (cdr link))
            (insert (format "- \"%s\" (pos:%d)\n"
                            (zetian--lint-read-link-at-pos (car link) pos)
                            pos)))))
      (when tasks-without-project
        (insert (format "\n* %d open tasks with missing projects\n"
                        (length tasks-without-project)))
        (dolist (task tasks-without-project)
          (insert (format "- %s\n" (zetian-node-link task)))))
      (when isolated
        (insert (format "\n* %d isolated nodes (no in-bound or out-bound links)"
                        (length isolated)))
        (dolist (task isolated)
          (insert (format "\n- %s" (zetian-node-link task)))))
      (org-mode)
      (read-only-mode 1)
      (goto-char (point-min))))

  (defun zetian-lint ()
    "Check zetian for any inconsistencies and open a buffer containing the
  faults."
    (interactive)
    (org-roam-db-sync)
    (let ((found (list
                  (zetian--lint-duplicates)
                  (zetian--lint-broken-links)
                  (zetian-query-stuck-project)
                  (zetian-query-stuck-area)
                  (zetian-query-open-tasks-without-project)
                  (zetian-query-isolated))))
      (if (-any 'identity found)
          (apply #'zetian--lint-show-buffer found)
        (message "no errors found in zetian"))))

  ;; strange categories
  ;; orphaned nodes
#+END_SRC

*** Reports
I would like to view some reports on the state of zetian.

**** Report Macro
This will open a buffer and insert a standard header for the reports to use.

#+BEGIN_SRC emacs-lisp
  (defmacro zetian--with-report-buffer (name &rest body)
    "Open a list of all open tasks grouped by project."
    (declare (indent 1))
    (let ((sym-name (gensym))
          (sym-buf (gensym))
          (sym-now (gensym)))
      `(let* ((,sym-name ,name)
              (,sym-buf (get-buffer-create (concat "*" ,sym-name "*")))
              (,sym-now (format-time-string "[%Y-%m-%d %a %H:%M]")))
         (pop-to-buffer-same-window ,sym-buf)
         (read-only-mode -1)
         (erase-buffer)
         (insert (concat "#+title: " ,sym-name "\n\n"))
         (insert (format "report was run at %s\n\n" ,sym-now))
         ,@body
         (org-mode)
         (read-only-mode 1)
         (goto-char (point-min)))))
#+END_SRC

**** Tasks
Open a buffer with a list of all the open tasks grouped by project.

#+BEGIN_SRC emacs-lisp
  (defun zetian-report-tasks ()
    (interactive)
    (zetian--with-report-buffer "zetian task list"
      ;; for each area
      (mapc
       (lambda (area)
         (insert (concat "* " (zetian--report-format area) "\n"))
         (when-let ((tasks (zetian-query `(and ,zetian-query-open-task-or-event
                                               (links-to ,area)))))
           ;; for each task linked to this area
           (mapc
             (lambda (task)
               (insert (concat "- " (zetian--report-format task) "\n")))
             tasks))
         ;; for each project linked to the area
         (mapc
          (lambda (proj)
            (insert (concat "** " (zetian--report-format proj) "\n"))
            ;; for each task linked to the project
            (mapc
             (lambda (task)
               (insert (concat "- " (zetian--report-format task) "\n")))
             (zetian-query `(and ,zetian-query-open-task-or-event
                                 (links-to ,proj)))))
          (zetian-query `(and ,zetian-query-project
                              (links-to ,area)
                              (not ,zetian-query-archive))))
         (insert "\n"))
       (zetian-query-area))))

  (defun zetian--report-generate (name elements)
    "Generate a report of `NAME', using the alist `ELEMENTS'."
    (zetian--with-report-buffer name
      (mapc (lambda (elem)
              (let ((title (car elem))
                    (items (cdr elem)))
                (insert (concat "\n* " (zetian--report-format title) "\n"))
                (mapc (lambda (it) (insert (concat "- " (zetian--report-format it)"\n")))
                      items)))
           elements)))

  (defun zetian--report-format (thing)
    "Format `THING' as a string suitable for inserting into an org document."
    (cond ((stringp thing) thing)
          (t
           ;; assume an org-roam node
           (format "[[id:%s][%s]]"
                   (org-roam-node-id thing)
                   (org-roam-node-title thing)))))
#+END_SRC

**** Completed Tasks
I'd like to be able to see a list of the recently completed tasks, sorted by date. I also want to be able to specify an ISO week to narrow it down.
#+BEGIN_SRC emacs-lisp
  (require 'cal-dst)
  (require 'cal-iso)

  (defun ic/dates-within-iso-week (year week &optional include-future)
    "Return a list of dates (in the format \"%Y-%m-%d\") that fall within the ISO
    week WEEK of YEAR. Include future dates when INCLUDE-FUTURE is true."
    (let ((iso-days (mapcar (lambda (d) (list week d year))
                            '(1 2 3 4 5 6 0)))
          (today (car (calendar-absolute-from-time
                       (time-convert (current-time) 'integer)
                       0))))
      (mapcar
       (lambda (abs)
         (let ((date (calendar-gregorian-from-absolute abs)))
           (format "%d-%02d-%02d" (nth 2 date) (nth 0 date) (nth 1 date))))
       (seq-filter
        (lambda (date) (or include-future (<= date today)))
        (mapcar #'calendar-iso-to-absolute iso-days)))))

  (defun ic/org-get-heading-contents (title buffer)
    "Return the contents of header with title TITLE, found in BUFFER."
    (save-excursion
      (with-current-buffer buffer
        (org-element-map (org-element-parse-buffer) 'headline
          (lambda (heading)
            (when (string-equal (org-element-property :raw-value heading)
                                title)
              (let ((beg (org-element-property :contents-begin heading))
                    (end (org-element-property :contents-end heading)))
                (if (and beg end)
                    (buffer-substring beg end)
                  ""))))
          nil t))))

  (defun zetian-report-completed (&optional week-delta)
    "Generate a zetian report with all completed tasks, use WEEK-DELTA to
    determine ISO week difference from current week"
    (interactive)
    (let* ((time (time-add nil (days-to-time (* 7 week-delta))))
           (year (string-to-number (format-time-string "%G" time)))
           (week (string-to-number (format-time-string "%V" time)))
           (dates (ic/dates-within-iso-week year week))
           )
      (zetian--with-report-buffer (format "zetian completed tasks for %s-w%s"
                                          year week)
        (dolist (date dates)
          (let ((time (encode-time (parse-time-string (concat date "T00:00:00")))))
            (insert (concat "* "
                            (format-time-string "%A, %d %B %G" time)
                            "\n"))
            (insert
             (or
              (ic/org-get-heading-contents "Completed Tasks" (zetian-journal-day time))
              ""))
            (insert "\n"))))))

  (defun zetian-report-completed-this-week ()
    "Run a zetian report for all completed journal entries for the current ISO
  week."
    (interactive)
    (zetian-report-completed 0))

  (defun zetian-report-completed-last-week ()
    "Run a zetian report for all completed journal entries for the previous ISO
  week."
    (interactive)
    (zetian-report-completed -1))
#+END_SRC

*** Show links buffer
I'd like something similar to =org-roam-buffer-toggle=.

#+BEGIN_SRC emacs-lisp
  (defun zetian-show-links-buffer ()
    (interactive)
    (when-let ((node (org-roam-node-at-point)))
      (pop-to-buffer-same-window
       (get-buffer-create "*zetian links buffer*"))
      (org-transclusion-mode -1)
      (read-only-mode -1)
      (erase-buffer)
      (insert (format "#+title: Links for %s\n\n" (org-roam-node-title node)))
      (insert "* In Bound Links\n")
      (dolist (link (zetian-query `(links-to ,node)))
        (insert (format "** %1$s\n#+transclude: %1$s\n\n"
                        (zetian-node-link link))))
      (insert "\n* Out Bound Links\n")
      (dolist (link (zetian-query `(links-from ,node)))
        (insert (format "** %1$s\n#+transclude: %1$s\n"
                        (zetian-node-link link))))
      (org-mode)
      (org-transclusion-mode 1)
      (read-only-mode 1)
      (goto-char (point-min))
      (re-search-forward "^$")
      (forward-char)))
#+END_SRC

*** Code Execution
I want a function that let's us view a list of zetian nodes as an org-mode list. This should help with viewing lists through code execution inside zetian nodes.
#+BEGIN_SRC emacs-lisp
  (defun zetian-show-list (nodes &optional no-sort)
    "Turn `NODES' into a string of ORG-MODE links suitable for inclusion in an org
    document."
    (mapconcat (lambda (node) (format "- [[id:%s][%s]]\n"
                                      (org-roam-node-id node)
                                      (org-roam-node-title node)))
               (if no-sort
                   nodes
                 (sort nodes
                       (lambda (n1 n2) (string< (org-roam-node-title n1)
                                                (org-roam-node-title n2)))))))
#+END_SRC

*** journal
I would like to start keeping a journal.

#+BEGIN_SRC emacs-lisp
  (defun zetian--journal-buffer (date-format template-name &optional time)
    "Return the buffer for today's journal."
    (let* ((journal (concat zetian-journal-dir
                            (format-time-string date-format time)
                            ".org"))
           ;; yas-env is `eval'd when the snippet is expanded, so be careful with
           ;; quoting variables
           (safe-time (and time `(cons ,(car time) ,(cdr time))))
           (yas-env `((time ,safe-time))))
      (with-current-buffer
          (find-file-noselect journal)
        (unless (file-exists-p journal)
          (yas-expand-snippet
           (yas-lookup-snippet template-name 'org-mode)
           nil nil yas-env)
          (save-excursion
            (goto-char (point-min))
            (org-id-get-create)
            (save-buffer)))
        (zetian-mode)
        (current-buffer))))


  (defun ic/time-advance (key value)
    "Return an encoded time value advanced by KEY VALUEs.
  See `make-decoded-time' for possible KEY/VALUE."
    (let ((time (decode-time nil nil t))
          (delta (make-decoded-time key value)))
      (encode-time (decoded-time-add time delta))))

  (defun zetian-quarter-number (&optional time)
    "Return values between 1 and 4 (as strings) based on what quarter of the year
  TIME falls under."
    (let ((week (string-to-number (format-time-string "%V" time))))
      (number-to-string (ceiling (/ week 13.0)))))

  (defun ic/days-in-month (time)
    "Return a list of encoded time objects that correspond to each day of the
  month TIME refers to."
    (let* ((dtime (decode-time time))
           (year (decoded-time-year dtime))
           (month (decoded-time-month dtime))
           (days (date-days-in-month year month)))
      (mapcar
       (lambda (day)
         (encode-time
          (parse-time-string
           (format "%04d-%02d-%02dT00:00:00" year month day))))
       (number-sequence 1 days))))


  (defun zetian-journal-day (&optional time)
    "Return the buffer for today's journal"
    ;; the day journal snippet refers to the week journal, so create it first
    (zetian-journal-week time)
    (zetian--journal-buffer "%Y-%m-%d" "journal-day" time))

  (defun zetian-journal-week (&optional time)
    "Return the buffer for week's journal"
    ;; the week journal snippet refers to the year journal, so create it first
    (zetian-journal-year time)
    (zetian--journal-buffer "%Y-w%V" "journal-week" time))

  (defun zetian-journal-month (&optional time)
    "Return the buffer for month's journal"
    (zetian--journal-buffer "%Y-%m" "journal-month" time))

  (defun zetian-journal-quarter (&optional time)
    "Return the buffer to this quarter's journal"
    (zetian--journal-buffer (concat "%Y-q" (zetian-quarter-number time))
                            "journal-quarter" time))

  (defun zetian-journal-year (&optional time)
    "Return the buffer for year's journal"
    (zetian--journal-buffer "%Y" "journal-year" time))


  (defun zetian-journal-goto-today (&optional arg)
    "Open today's journal."
    (interactive "P")
    (pop-to-buffer-same-window
     (zetian-journal-day
      (when (equal '(4) arg)
        (org-read-date nil t)))))

  (defun zetian-journal-goto-tomorrow ()
    "Open tomorrow's journal."
    (interactive)
    (pop-to-buffer-same-window
     (zetian-journal-day
      (ic/time-advance :day 1))))

  (defun zetian-journal-goto-week (&optional arg)
    "Open this week's journal."
    (interactive "P")
    (pop-to-buffer-same-window
     (zetian-journal-week
      (when (equal '(4) arg)
        (org-read-date nil t)))))

  (defun zetian-journal-goto-next-week ()
    "Open next week's journal."
    (interactive)
    (pop-to-buffer-same-window
     (zetian-journal-week
      (ic/time-advance :day 7))))

  (defun zetian-journal-goto-month (&optional arg)
    "Open this month's journal."
    (interactive "P")
    (pop-to-buffer-same-window
     (zetian-journal-month
      (when (equal '(4) arg)
        (org-read-time nil t)))))

  (defun zetian-journal-goto-next-month ()
    "Open next month's journal."
    (interactive)
    (pop-to-buffer-same-window
     (zetian-journal-month
      (ic/time-advance :month 1))))

  (defun zetian-journal-goto-quarter (&optional arg)
    "Open this quarter's journal."
    (interactive "P")
    (pop-to-buffer-same-window
     (zetian-journal-quarter
      (when (equal '(4) arg)
        (org-read-date nil t)))))

  (defun zetian-journal-goto-next-quarter ()
    "Open next quarter's journal."
    (interactive)
    (pop-to-buffer-same-window
     (zetian-journal-quarter
      (ic/time-advance :day (* 7 13)))))

  (defun zetian-journal-goto-year (&optional arg)
    "Open this year's journal."
    (interactive "P")
    (pop-to-buffer-same-window
     (zetian-journal-year
      (when (equal '(4) arg)
        (org-read-date nil t)))))

  (defun zetian-journal-goto-next-year ()
    "Open next year's journal."
    (interactive)
    (pop-to-buffer-same-window
     (zetian-journal-year
      (ic/time-advance :year 1))))


  (defun zetian--journal-link (buffer title)
    "Return and org-mode link to BUFFER with TITLE"
    (format "[[id:%s][%s]]"
            (with-current-buffer buffer
              (save-excursion
                (goto-char (point-min))
                (org-id-get)))
            title))

  (defun zetian-journal-day-link (&optional time)
    "Return an org-mode link to today's journal."
    (zetian--journal-link
     (zetian-journal-day time)
     (format-time-string "%Y-%m-%d" time)))

  (defun zetian-journal-week-link (&optional time)
    "Return an org-mode link to this week's journal."
    (zetian--journal-link
     (zetian-journal-week time)
     (format-time-string "Week %V" time)))

  (defun zetian-journal-month-link (&optional time)
    "Return an org-mode link to this month's journal."
    (zetian--journal-link
     (zetian-journal-month time)
     (format-time-string "%B" time)))

  (defun zetian-journal-quarter-link (&optional time)
    "Return an org-mode link to this quarter's journal."
    (zetian--journal-link
     (zetian-journal-quarter time)
     (concat (format-time-string "%Y-Q")
             (zetian-quarter-number time))))

  (defun zetian-journal-year-link (&optional time)
    "Return an org-mode link to this year's journal."
    (zetian--journal-link
     (zetian-journal-year time)
     (format-time-string "%Y" time)))


  (defun zetian--add-completed-task-to-journal ()
    "This hook should run under `org-after-todo-state-change-hook' and will add
    any completed task to the current day's journal."
    (when (org-entry-is-done-p)
      (let ((link (format "[[id:%s][%s]]"
                          (org-id-get)
                          (org-get-heading t t t t))))
        (with-current-buffer (zetian-journal-day)
          (save-excursion
            (save-restriction
              (goto-char (marker-position
                          (org-find-olp '("Completed Tasks")
                                        (current-buffer))))
              (org-narrow-to-subtree)
              (goto-char (point-max))
              (insert (format "- [X] %s" link))
              (save-buffer)))))))
  (add-hook 'org-after-todo-state-change-hook
            #'zetian--add-completed-task-to-journal)
#+END_SRC

*** git
#+BEGIN_SRC emacs-lisp
  (defconst zetian-update-git-seconds 600
    "Automatically update zetian's git repo every count seconds.")

  (defun zetian-update-git ()
    "Update the git repo under `org-roam-directory'.
  Automatically pull any updates, commit our changes, and push back up."
    (interactive)
    (let ((default-directory org-roam-directory)
          (commit-msg (format "zetian auto update (%s)" (system-name))))
      (magit-git "pull" "--ff-only" "origin" "master")
      (when (or (magit-modified-files)
                (magit-untracked-files))
        (magit-git "add" "-A")
        (magit-git "commit" (format "--message='%s'" commit-msg))
        (magit-git "push" "origin" "master"))
      (org-roam-db-sync)))

  ;; ensure we run `zetian-update-git' every `zetian-update-git-seconds'.
  (run-with-idle-timer zetian-update-git-seconds t #'zetian-update-git)

  ;; run `zetian-update-git' when we first start emacs
  (add-hook 'emacs-startup-hook #'zetian-update-git)
#+END_SRC

*** Export
I would like to export my zetian graph into a suitable format for viewing on mobile. My intention is to first export all the currently open agenda tasks into a json file for viewing with a html file. After that, I plan on creating an export for permanent notes into static html files.

#+BEGIN_SRC emacs-lisp
  (defconst zetian-export-dir "/mnt/c/Data/www/zetian/")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defconst zetian-export-agenda-json-file
    (concat zetian-export-dir "agenda.json"))

  (defconst zetian-export-bookmarks-file
    (expand-file-name "~/tmp/bookmarks.js"))

  (defun zetian-export-all ()
    "Export all of zetian."
    (interactive)
    (zetian-export-agenda))
#+END_SRC

**** Agenda
#+BEGIN_SRC emacs-lisp
  (defun zetian-export-agenda ()
    "Create a json datafile with all the currently non-archived tasks."
    (save-excursion
      (with-current-buffer
          (find-file-noselect zetian-export-agenda-json-file t)
        (erase-buffer)
        (insert "{\"tasks\": [\n")
        (insert (s-join ",\n" (map-zetian #'zetian-export--task-to-json
                                          (zetian-query-task))))
        (insert "\n]}")
        (save-buffer))))

  (defun zetian-export--task-to-json (node)
    "Return the currently visited task as a json string"
    (let ((title (org-roam-node-title node))
          (id (org-roam-node-id node))
          (state (org-roam-node-todo node))
          (scheduled (or (org-roam-node-scheduled node) ""))
          (deadline (or (org-roam-node-deadline node) ""))
          (priority (if-let (p (org-roam-node-priority node))
                        (char-to-string p)
                      ""))
          (effort (or (cdr (assoc "EFFORT" (org-roam-node-properties node))) "")))
      (format "{\"title\":\"%s\",\"state\":\"%s\",\"scheduled\":\"%s\",\"deadline\":\"%s\",\"priority\":\"%s\",\"effort\":\"%s\",\"id\":\"%s\"}"
              title state scheduled deadline priority effort id)))
#+END_SRC

**** Bookmarks
#+BEGIN_SRC emacs-lisp
  (defun zetian-export-bookmarks ()
    "Export zetian bookmarks to `zetian-export-bookmarks-file'."
    (interactive)
    (let ((bookmarks (zetian-export--all-bookmarks "All My Bookmarks")))
      (save-excursion
        (with-current-buffer
            (find-file-noselect zetian-export-bookmarks-file)
          (goto-char (point-min))
          (erase-buffer)
          (insert "export const _ALL_BOOKMARKS = [\n")
          (insert (s-join ",\n" bookmarks))
          (insert "\n];\n")
          (basic-save-buffer)))))

  (defun zetian-export--all-bookmarks (node-title)
    (with-zetian-node
        (zetian-query-1 `(title ,node-title))
      (org-element-map (org-element-parse-buffer) 'headline
        #'zetian-export--single-bookmark)))

  (defun zetian-export--single-bookmark (headline)
    (let* ((link-raw (org-element-property :raw-value headline))
           (link (car (org-element-parse-secondary-string link-raw '(link))))
           (path (org-element-property :raw-link link))
           (title (substring-no-properties (nth 2 link)))
           (tags (org-element-property :tags headline)))
      (format "{\"title\": \"%s\", \"path\": \"%s\", tags: [%s]}"
              title path
              (mapconcat (lambda (tag) (format "\"%s\"" tag))
                         tags ","))))
#+END_SRC

*** org-protocol
I want to be able to store both bookmarks and reference notes from anywhere (firefox mostly) so I will register two new =org-protocol= endpoints.

This is the firefox bookmark used for capturing reference notes:
#+BEGIN_EXAMPLE
  javascript:location.href = 'org-protocol://zetian-ref?' + new URLSearchParams({url: location.href, title: document.title, body: window.getSelection()});void(0)
#+END_EXAMPLE

And this is for capturing bookmarks:
#+BEGIN_EXAMPLE
  javascript:location.href = 'org-protocol://zetian-bookmark?' + new URLSearchParams({url: location.href, title: document.title, body: window.getSelection()});void(0)
#+END_EXAMPLE

See the file =org-protocol-windows.reg= for registering =org-protocol= in windows under WSL.

#+BEGIN_SRC emacs-lisp
  ;; defined some dynamically bound variables so we can reference them in the
  ;; capture template string
  (defvar ic//captured-url)
  (defvar ic//captured-title)
  (defvar ic//captured-body)


  (defun zetian-protocol-ref (data)
    (let ((ic//captured-url (plist-get data :url))
          (title (format "refnote - %s"
                         (plist-get data :title)))
          (body (string-replace "\r" "" (plist-get data :body))))
      (zetian-node-find
       (zetian-node-create title "R"))
      (goto-char (point-max))
      (unless (string-empty-p body)
        (insert (format "\n#+BEGIN_QUOTE\n%s\n#+END_QUOTE\n\n" body))
        (basic-save-buffer))))

  (add-to-list 'org-protocol-protocol-alist
               '("zetian-ref" :protocol "zetian-ref"
                 :function zetian-protocol-ref))


  (defun zetian-protocol-bookmark (data)
    (let* ((ic//captured-url (plist-get data :url))
           (ic//captured-title (plist-get data :title))
           (ic//captured-body (string-replace "\r" "" (plist-get data :body)))
           (org-capture-initial ic//captured-body)
           (org-capture-entry (org-capture-select-template "B")))
      (unwind-protect
          ;; don't let org-mode split the window
          (cl-letf (((symbol-function #'switch-to-buffer-other-window)
                     #'switch-to-buffer))
            (org-capture))
        (when (equal "Org Capture" (frame-parameter nil 'name))
          (delete-frame)))))

  (add-to-list 'org-protocol-protocol-alist
               '("zetian-bookmark" :protocol "zetian-bookmark"
                 :function zetian-protocol-bookmark))
#+END_SRC

** Beeping
Turn off the damn bell!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil)
  (setq ring-bell-function #'ignore)
#+END_SRC

** Tramp
Some tramp specific configurations.

*** Guix
=tramp= doesn't honor the host's =$PATH= by default, instead searching directories manually for commands (ex =/usr/bin/ls=, =/bin/ls=, etc). As =guix= makes heavy use of =PATH= this doesn't work, so we need to setup =tramp= accordingly.
#+BEGIN_SRC emacs-lisp
  ;; only use $PATH on the remote host
  (connection-local-set-profile-variables
   'use-remote-path-envvar
   '((tramp-remote-path . (tramp-own-remote-path))))

  (connection-local-set-profiles
   '(:application tramp :machine "tornado")
   'use-remote-path-envvar)
#+END_SRC

** Directory Locals
*** lsp ignore Unity directories
=lsp-mode= should not create file watchers for every directory in a Unity project. I wish there was a way to whitelist directories, but =lsp= only allows for blacklisting. So use =dir-locals= to add some common =Unity= directories.
#+BEGIN_SRC emacs-lisp
  (when on-home-windows-desktop
    ;; setup directory local variables and make them as safe
    (let* ((ignore-dirs '("Build" "Library" "Logs" "obj" "Packages"
                          "ProjectSettings" "Temp" "UserSettings"))
           (ignore-regexes (append (mapcar (lambda (d) (concat "[/\\\\]" d "\\'"))
                                           ignore-dirs)
                                   lsp-file-watch-ignored-directories))
           (vars `((lsp-file-watch-ignored-directories . ,ignore-regexes))))
      (dir-locals-set-class-variables
       'unity-project
       `((nil . ,vars)))
      (dolist (var vars)
        (add-to-list 'safe-local-variable-values var)))
    (dir-locals-set-directory-class
     "c:/Code/Icarus" 'unity-project))
#+END_SRC
** Random names
I keep some random name lists in a specific org file and I want a way to grab a random one from those lists. So I want a command that will ask for a tag I want to narrow to and then yank a random name from that list onto the killring and system clipboard.

#+BEGIN_SRC emacs-lisp
  (defvar ic/random-list-file (concat org-directory
                                      "/home/lists-of-names.org"))

  (defun ic/random-name ()
    "Return a random name from the lists in `ic/random-list-file'."
    (interactive)
    (save-excursion
      (save-restriction
        (with-current-buffer (find-file-noselect ic/random-list-file)
          (widen)
          (let* (;; find tag
                 (tag (completing-read "Tag for random name:"
                                       (org-get-buffer-tags)))
                 ;; find random heading matching tag
                 (headings (org-ql-select (current-buffer) `(tags ,tag)))
                 (heading (seq-random-elt headings))
                 ;; data for heading
                 (data (org-element-parse-secondary-string
                        (buffer-substring
                         (plist-get (cadr heading) :contents-begin)
                         (plist-get (cadr heading) :contents-end))
                        '(item)))
                 (text (substring-no-properties (car data)))
                 ;; find random line
                 (lines (split-string text "\n" t))
                 (line (seq-random-elt lines))
                 (result (ic//random-name-cleanup (substring line 2))))
            ;; add to kill ring and return
            (kill-new result)
            (message result))))))

  (defun ic//random-name-cleanup (name)
    (let ((regexes (list ;; (rx (or " in" " and" " or" " is" "," ":" " -")
                         ;;     word-end (* nonl) eol)
                         (rx " in" word-end (* nonl) eol)
                         (rx " and" word-end (* nonl) eol)
                         (rx " or" word-end (* nonl) eol)
                         (rx " is" word-end (* nonl) eol)
                         (rx " - " (* nonl) eol)
                         (rx "," (* nonl) eol)
                         (rx ":" (* nonl) eol)
                         (rx ";" (* nonl) eol)
                         (rx (optional space) "(" (* (not ")")) ")")
                         (rx (optional space) "[" (* (not "]")) "]")
                         )))
      (mapc
       (lambda (re)
         ;; (message re)
         (setq name (replace-regexp-in-string re "" name)))
       regexes)
      name))
#+END_SRC
** Oraclian
=Oraclian= is an =Angular= app that helps be with using random tables for TTRPGs. I'd like to keep my lists of random tables in an =org-mode= document and use the exporter backend to translate to a suitable json file for =Oraclian=.

#+BEGIN_SRC emacs-lisp
  (org-export-define-backend
   'oraclian
   '((headline . ic/oraclian-export--as-is)
     (inner-template . ic/oraclian-export--inner-template)
     (item . ic/oraclian-export--item)
     (paragraph . ic/oraclian-export--paragraph)
     (plain-list . ic/oraclian-export--plain-list)
     (section . ic/oraclian-export--as-is))
   :menu-entry
   '(?O "Export to Oraclian json"
        (lambda (a s v b)
          (ic/oraclian-export a s v b)))
   ;; :filters-alist
   ;; '((:filter-paragraph . ic/oraclian-export--filter-paragraph))
   )

  (defun ic/oraclian-export
      (&optional async subtreep visible-only body-only ext-plist)
    (interactive)
    (let ((file (org-export-output-file-name ".json" subtreep)))
      (org-export-to-file 'oraclian file
        async subtreep visible-only body-only ext-plist)))

  (defun ic/oraclian-export--inner-template (contents info)
    (let ((data (s-replace "\n" ","
                           (s-replace-regexp "\n+" "\n"
                                             (string-trim contents)))))
      (concat "export const TABLES = [" data "];")))

  (defun ic/oraclian-export--plain-list (plain-list contents info)
    (let* ((parent (org-export-get-parent-headline plain-list))
           (name (org-element-property :raw-value parent))
           (roll-value (org-element-property :ROLL parent))
           (id-value (org-element-property :ID parent))
           (source-value (ic/oraclian-export--source parent))
           (roll (or roll-value
                     (format "1d%d" (1- (length (s-split "\n" contents))))))
           (table-id (or id-value
                         (ic/oraclian-export--get-id parent)))
           (tags (mapconcat (lambda (tag) (format "\"%s\"" tag))
                            (org-export-get-tags parent info nil t)
                            ","))
           (text (string-replace "\n" "," (substring contents 0 -1))))
      (format "{\"name\": \"%s\", \"id\": \"%s\", \"roll\": \"%s\", \"source\": \"%s\", \"tags\": [%s], \"table\": [%s]}"
              name table-id roll source-value tags text)))

  (defun ic/oraclian-export--get-id (elem)
    (let ((parent (org-export-get-parent-element elem))
          (title (s-replace-all
                  '((" " . "-") ("(" . "") (")" . ""))
                  (downcase (org-element-property :raw-value elem)))))
      (if parent
          (concat (ic/oraclian-export--get-id parent) "-" title)
        title)))

  (defun ic/oraclian-export--source (elem)
    (if-let ((source (org-element-property :SOURCE elem)))
        source
      (if-let ((parent (org-export-get-parent-headline elem)))
          (ic/oraclian-export--source parent)
        (error "No :SOURCE found for element"))))

  (defun ic/oraclian-export--item (item contents info)
    (concat "\"" (string-replace "\"" "\\\"" (string-trim contents)) "\""))

  (defun ic/oraclian-export--as-is (elem contents info)
    contents)

  (defun ic/oraclian-export--paragraph (elem contents info)
    (when (equal 'item
                 (org-element-type (org-export-get-parent elem)))
      contents))
#+END_SRC
** Open emacs source files
I want a keybind to automatically open the source of a user-prompted library.
#+BEGIN_SRC emacs-lisp
  (defun ic/open-library-source ()
    "Locate and navigate to the source of a user-prompted emacs library."
    (interactive)
    (when-let ((source (call-interactively #'locate-library)))
      (find-file source)))
#+END_SRC
* Keybindings
Here we copy the spacemacs keybindings, more or less.

** main
#+BEGIN_SRC emacs-lisp
  (leader-keys
    "|" 'ic/shell-command-on-region-replace
    "C-|" 'shell-command-on-region
    "TAB" 'mode-line-other-buffer
    "u" 'universal-argument)
#+END_SRC

** normal mode
#+BEGIN_SRC emacs-lisp
  ;; (general-define-key
  ;;  :states '(normal)
  ;;  :keymaps 'general-override-mode-map
  ;;  "go" 'ic/move-to-outline-dwim
  ;;  "gl" 'helm-occur)
#+END_SRC

** insert mode
Some of these keys are set in a mode specific keymap that I don't want to trigger while in insert mode.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps  'meow-insert-state-keymap
   "<left>"  'meow-left
   "<up>"    'meow-prev
   "<down>"  'meow-next
   "<right>" 'meow-right
   )
#+END_SRC

** Escape Key
Make  =<escape>= quit as much as possible.

XXX should these go in an override map?

#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map
                 minibuffer-local-must-match-map
                 minibuffer-local-isearch-map)
      "<escape>" 'keyboard-escape-quit)
#+END_SRC

** a :: applications
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "a"
   "" '(nil :which-key "applications")
   "c" 'calc
   "d" 'dired
   "s" 'ansi-term
   "i" 'ielm
   )
#+END_SRC

** b :: buffers
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "b"
   "" '(nil :which-key "buffers")
   "b" 'consult-buffer
   "B" 'consult-buffer-other-window
   "d" 'kill-current-buffer
   "D" 'ic/ediff-current-buffer-with-disk
   "i" 'ibuffer
   "P" 'ic/paste-clipboard-to-buffer
   "R" 'revert-buffer
   "s" 'ic/switch-to-scratch-buffer
   "S" 'tramp-revert-buffer-with-sudo
   "w" 'read-only-mode
   "Y" 'ic/yank-buffer-to-clipboard)
#+END_SRC

** B :: build

** e :: errors

** E :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "E"
    "" '(nil :which-key "emacs")
    "d" 'toggle-debug-on-error
    "f" 'toggle-frame-fullscreen
    "F" 'make-frame
    "m" 'toggle-frame-maximized)
#+END_SRC

** Ep :: Emacs profiler
Profiler bindings.
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "Ep"
   "" '(nil :which-key "emacs profiler")
   "c" #'ic/start-cpu-profiler
   "m" #'ic/start-mem-profiler
   "p" #'ic/start-cpu-mem-profiler
   "s" #'profiler-stop
   "r" #'profiler-report)
#+END_SRC

** f :: Files
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "f"
   "" '(nil :which-key "files")
   "b" 'ic-consult-bookmark
   "c" 'copy-file
   "D" 'ic/delete-current-buffer-file
   "E" 'sudo-edit
   "f" 'find-file
   "F" 'find-file-other-window
   "L" 'ic/open-library-source
   "M" 'ic/rename-current-buffer-file
   ;; "r" 'ic/helm-recentf
   "y" 'ic/yank-current-filename)
#+END_SRC

** fC :: Convert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fC"
   "" '(nil :which-key "convert")
   "d" 'unix-to-dos
   "u" 'dos-to-unix)
#+END_SRC

** fe :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fe"
   "" '(nil :which-key "emacs")
   "i" 'ic/edit-init-file
   "I" 'ic/edit-early-init-file
   "o" 'ic/edit-org-config-file)
#+END_SRC

** TODO g :: git/vc
/can't use "g" with meow/
#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
    :infix "g"
    "" '(nil :which-key "git")
    "i" 'magit-gitignore
    "s" 'magit-status
    "S" 'magit-stage-file
    "U" 'magit-unstage-file
    )
#+END_SRC

** TODO h :: help
/can't use "h" with meow/
#+BEGIN_SRC emacs-lisp
  (define-key help-map (kbd "a") 'consult-apropos)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
   :infix "h"
   "" '(nil :which-key "help")
   "a" 'apropos
   "k" 'which-key-show-top-level
   "i" 'info
   "I" 'helm-info
   "m" 'helm-man-woman)
#+END_SRC

** TODO hd :: help describe
#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
   :infix "hd"
   "" '(nil :which-key "describe")
   "b" 'describe-bindings
   "c" 'describe-char
   "f" 'describe-function
   "F" 'describe-face
   "K" 'describe-keymap
   "k" 'describe-key
   "l" 'describe-last-keys
   "m" 'describe-mode
   "p" 'describe-package
   "s" 'describe-system-info
   "t" 'describe-theme
   "v" 'describe-variable)
#+END_SRC

** i :: insert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "i"
   "" '(nil :which-key "insert")
   ;; "8" 'helm-ucs
   "b" 'insert-buffer
   "c" 'insert-char
   "e" 'emoji-insert
   "f" 'insert-file
   "r" 'insert-register)
#+END_SRC

** j :: jump
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "j"
    "" '(nil :which-key "jump")
    "i" 'consult-imenu
    "I" 'consult-imenu-multi
    "l" 'consult-line
    "m" 'consult-mark
    "M" 'consult-global-mark
    "o" 'consult-outline-or-org-heading
    )
#+END_SRC

** l :: layouts

** m :: major mode

** p :: projects

** r :: registers
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "r"
    "" '(nil :which-key "registers")
    "l" 'consult-register-load
    "k" 'consult-yank-from-kill-ring
    "r" 'consult-register
    "s" 'consult-register-store
    )
#+END_SRC

** s :: search
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "s"
    "" '(nil :which-key "search")
    "f" 'consult-find
    "g" 'consult-git-grep
    "G" 'consult-grep
    "r" 'consult-ripgrep
    )
#+END_SRC

** S :: snippets
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "S"
    "" '(nil :which-key "snippets")
    "e" #'yas-visit-snippet-file
    "i" #'yas-insert-snippet
    "n" #'yas-new-snippet)
#+END_SRC

** t :: toggle
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "t"
   "" '(nil :which-key "toggle")
   "C" 'flycheck-mode
   "S" 'flyspell-mode
   "T" 'load-theme
   "m" 'consult-minor-mode-menu
   "w" 'visual-fill-column-mode
   "W" 'whitespace-mode
   )
#+END_SRC

** w :: windows
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "w"
   "" '(nil :which-key "windows")
   "=" 'balance-windows
   "d" 'delete-window
   "f" 'follow-mode
   ;; new for emacs 31
   ;; "k" 'rotate-windows
   ;; "j" 'rotate-windows-back
   ;; "l" 'flip-window-layout-horizontally
   ;; "h" 'flip-window-layout-vertically
   ;; "L" 'rotate-window-layout-clockwise
   ;; "H" 'rotate-window-layout-anticlockwise
   "m" 'delete-other-windows
   "S" 'split-window-below-and-focus
   "s" 'split-window-below
   "U" 'winner-redo
   "u" 'winner-undo
   "V" 'split-window-right-and-focus
   "v" 'split-window-right
   )
#+END_SRC

** x :: text

