# -*- lexical-binding: t; -*-
#+TITLE: Emacs Config
#+STARTUP: content

Welcome to my emacs configuration.

* Initial Setup
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

I want to be able to potentially load separate emacs configurations so set the base emacs directory to where the currently loading configuration is.
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory load-file-name))
#+END_SRC

I also want to keep my =user-emacs-directory= somewhat clean, so let's define a few sub directories that we'll try to keep the plethora of emacs files in:
- =user-cache-directory= :: files that contain transient data (history, projectile, etc).
- =user-data-directory= :: files that contain version controlled data (snippets, etc)

#+BEGIN_SRC emacs-lisp
  (defvar user-cache-directory (concat user-emacs-directory "cache/"))
  (defvar user-data-directory (concat user-emacs-directory "data/"))
#+END_SRC

I want my config to be portable between machines. So I'll need some variables to key on for various changes

#+BEGIN_SRC emacs-lisp
  (defconst on-linux (string-equal system-type "gnu/linux"))
  (defconst on-windows (string-equal system-type "windows-nt"))
  (defconst on-mac (string-equal system-type "darwin"))

  ;; at_home/at_work are bash functions defined in ~/.bashrc
  (defconst at-home (= 0 (call-process "bash" nil nil nil "-c" "source ~/.bashrc && at_home")))
  (defconst at-work (= 0 (call-process "bash" nil nil nil "-c" "source ~/.bashrc && at_work")))

  (defun on-host (hostname)
    "Return non-nil when the current system is `hostname'."
    (string-equal (system-name) hostname))

  (defconst on-tablet (on-host "DESKTOP-F6Q3GN2"))
  (defconst on-old-imac (on-host "Michaels-iMac.local"))
  (defconst on-home-windows-desktop (and on-windows (on-host "Chetwood")))
  (defconst on-home-windows-desktop-wsl (and on-linux (on-host "Chetwood")))
#+END_SRC

* Bootstrap
** Native compilation
I want to make use of the native compilation system introduced in emacs 28.
#+BEGIN_SRC emacs-lisp
  ;; do we have native compilation available?
  (defconst have-native-compilation
    (and (fboundp 'native-comp-available-p)
         (native-comp-available-p)))

  (when have-native-compilation
    ;; don't blast me with (mostly) useless warnings
    (setq native-comp-async-report-warnings-errors nil)
    ;; keep the eln cache tidy
    (setq native-comp-eln-load-path
          (list (concat user-cache-directory "eln-cache/")
                (car (last native-comp-eln-load-path)))))
#+END_SRC
** straight.el
I use =straight.el= for package management so install this early.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integrate =straight.el= with =use-package=.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
#+END_SRC

I want to check in my packages to git so store the version file under =user-data-directory=.
#+BEGIN_SRC emacs-lisp
  (setq straight-profiles `((nil . ,(concat user-data-directory "straight-default.el"))))
#+END_SRC
** async
I use the =async= package in my =init.el= tangling function, so we need to load it early.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC

** init.el
On checking out this repo =init.el= will have temporary code in it to tangle / load this org file (=README.org=), overwriting itself. On this initial run we will have loaded both core =org-mode= and melpa =org-mode= so emit a warning that a restart is needed.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; load core emacs `org-mode', but don't native compile it
  (let ((comp-deferred-compilation nil))
    (require 'org))

  ;; tangle/load our init file
  (let* ((base-dir (file-name-directory load-file-name))
         (org-file (concat base-dir "README.org"))
         (el-file (concat base-dir "init.el")))
    (org-babel-tangle-file org-file el-file)
    ;; on first load we shadow the core emacs org-mode and when trying to quit
    ;; emacs calls the non-existent function `org-clocking-buffer'. Define a dummy
    ;; to allow us to exit cleanly on initial run
    (defun org-clocking-buffer (&rest _))
    (load-file el-file)
    (warn "This is the first load of init.el so core emacs `org-mode' is loaded.
   Restart emacs to use newest version."))
#+END_SRC

We also need to tell =git= to ignore changes to =init.el= so the following command was run:
#+BEGIN_SRC shell :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

Let's also tell emacs where =init.el= lives so packages can find it. =straight.el= requires it for updating packages.
#+BEGIN_SRC emacs-lisp
  (setq user-init-file (concat user-emacs-directory "init.el"))
#+END_SRC

This file (=README.org=) should be tangled into the startup config file (=init.el=) along with compiling (either native or byte). I want that to happen automatically and asynchronously.
#+BEGIN_SRC emacs-lisp
  (defvar ic--tangle-init-async-cookie nil
    "Used to keep track of the async org-tangle process for init.el")

  (defun ic-maybe-tangle-init-file ()
    "Tangle/compile my emacs configuration."
    (let ((org-files (list
                      (expand-file-name "~/src/emacs/README.org")
                      (concat user-emacs-directory "README.org"))))
      (when (member (buffer-file-name) org-files)
        (when (process-live-p ic--tangle-init-async-cookie)
          (kill-process ic--tangle-init-async-cookie))
        (message "Async tangling %s..." (buffer-file-name))
        (setq
         ic--tangle-init-async-cookie
         (async-start
          `(lambda ()
             (require 'ob-tangle)
             (require 'subr-x)
             (let ((start-time (current-time))
                   ;; set to silence messages from `org-babel-tangle-file'.
                   ;; this screws up the async return value on windows :(
                   (inhibit-message t))
               (when-let (ret (org-babel-tangle-file ,(buffer-file-name)
                                                     ,user-init-file))
                 ;; (byte-compile-file ,user-init-file)
                 ;; (when ,have-native-compilation
                 ;;   (native-compile ,user-init-file))
                 (cons ret (float-time (time-since start-time))))))
          `(lambda (ret)
             (unless (consp ret)
               (error "error in org-babel-tangle for %S"
                      ,(buffer-file-name)))
             (message "Tangled %s in %.2f seconds"
                      (caar ret) (cdr ret))))))))

  (add-hook 'after-save-hook 'ic-maybe-tangle-init-file)
#+END_SRC

** meow
Let's give modal editing package a try

*** use-package
#+BEGIN_SRC emacs-lisp
  (use-package meow
    ;; :straight (meow :type git :host github :repo "turbana/meow")
    :ensure t
    :demand t
    :config
    ;; emacs keybind to access local leader map
    (setq emacs-local-leader-prefix "C-?")
    ;; meow keybind alias for local leader map
    (setq meow-local-leader-prefix "/")
    (setq meow-local-leader-insert-prefix "C-/")
    ;; keep the expand hints around a while longer
    (setq meow-expand-hint-remove-delay 3.0)
    ;; start git commits in insert mode
    (add-hook 'git-commit-mode-hook 'meow-insert-mode)
    ;; turn it on, baby
    (meow-global-mode 1))
#+END_SRC
*** Keybinds
**** Core
#+BEGIN_SRC emacs-lisp
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)

  (setq global-leader-map
        (let ((keymap (make-sparse-keymap)))
          (define-key keymap (kbd "c") 'meow-keypad-start)
          (define-key keymap (kbd "g") 'meow-keypad-start)
          (define-key keymap (kbd "h") 'meow-keypad-start)
          (define-key keymap (kbd "m") 'meow-keypad-start)
          (define-key keymap (kbd "x") 'meow-keypad-start)
          keymap))

  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   ;; global leader
   `("SPC" . ,global-leader-map)
   )

  (meow-normal-define-key
   '("1" . meow-1)
   '("2" . meow-2)
   '("3" . meow-3)
   '("4" . meow-4)
   '("5" . meow-5)
   '("6" . meow-6)
   '("7" . meow-7)
   '("8" . meow-8)
   '("9" . meow-9)
   '("0" . meow-0)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   ;; global leader
   `("SPC" . ,global-leader-map)
   ;; local leader
   `(,meow-local-leader-prefix . ,emacs-local-leader-prefix)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . keyboard-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . keyboard-quit))

  ;; local leader in insert mode
  (define-key meow-insert-state-keymap
    (kbd meow-local-leader-insert-prefix)
    (meow--parse-def emacs-local-leader-prefix))
#+END_SRC

**** Digit Keys
I really don't like how the default =meow= bindings put the universal arguments under /SPC/ and the expansion digits are the digits. I want to only hit the digit keys and have a function that just does "the right thing" depending on if we're currently expanding or not.
#+BEGIN_SRC emacs-lisp
  (defmacro def-meow-digit-action (func digit)
    "Create function FUNC that when called will call `meow-expand-DIGIT' when
    expanding, and `meow-digit-argument' otherwise."
    (let ((meow-expand-digit (intern (format "meow-expand-%d" digit))))
      `(defun ,func ()
         (interactive)
         (if (meow-expanding-p)
             (,meow-expand-digit)
           (meow-digit-argument)))))

  (defun meow-expanding-p ()
    "Return non-NIL when `meow' is either expanding or selecting text."
    (meow--selection-type))

  (def-meow-digit-action meow-1 1)
  (def-meow-digit-action meow-2 2)
  (def-meow-digit-action meow-3 3)
  (def-meow-digit-action meow-4 4)
  (def-meow-digit-action meow-5 5)
  (def-meow-digit-action meow-6 6)
  (def-meow-digit-action meow-7 7)
  (def-meow-digit-action meow-8 8)
  (def-meow-digit-action meow-9 9)
  (def-meow-digit-action meow-0 0)

  ;; don't need the macro anymore
  (fmakunbound 'def-meow-digit-action)
#+END_SRC

** Theme
Load my custom theme early so if we have errors emacs still looks pretty.

#+BEGIN_SRC emacs-lisp
  (use-package themian-theme
    :straight (themian :type git :host github :repo "turbana/themian")
    :init
    (setq themian-org-mode-variable-pitch t)
    (setq themian--show-unknowns nil)
    (cond (on-old-imac
           (set-face-attribute 'default nil
                               :family "Iosevka Extended" :height 160 :weight 'ultra-light)
           (set-face-attribute 'fixed-pitch nil
                               :family "Iosevka Extended" :height 160 :weight 'ultra-light)
           (set-face-attribute 'variable-pitch nil
                               :family "DejaVu Sans ExtraLight" :height 150 :weight 'ultra-light))
          (t
           (set-face-attribute 'default nil
                               :family "Iosevka Extended" :height 110 :weight 'normal)
           (set-face-attribute 'fixed-pitch nil
                               :family "Iosevka Extended" :height 110 :weight 'normal)
           (set-face-attribute 'variable-pitch nil
                               :family "DejaVu Sans Condensed" :height 120 :weight 'normal)))
    (defun themian--reload-dark-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-dark 'dark)
      (load-theme 'themian-dark t))
    (defun themian--reload-light-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-light 'light)
      (load-theme 'themian-light t))

    :config
    (defun themian--load-theme-on-frame-create (frame)
      "Enable default theme on FRAME, but only when graphics are enabled and no
    other theme is loaded."
      (with-selected-frame frame
        (when (and (display-graphic-p)
                   (not custom-enabled-themes))
          (load-theme
           (if (or on-tablet on-old-imac) 'themian-light 'themian-dark)
           t))))

    ;; set initial theme on frame create
    (add-hook 'after-make-frame-functions 'themian--load-theme-on-frame-create)
    ;; try to set initial theme now
    (themian--load-theme-on-frame-create (selected-frame))

    ;; HACK
    ;; something is using quote as a face, not sure where that is, but define it
    ;; here to silence the warnings in *Messages*
    (defface quote nil "not sure what this is")

    ;; don't use `general' to bind keys as it's not loaded yet
    :bind (("M-<f5>" . 'themian--reload-dark-theme)
           ("M-<f6>" . 'themian--reload-light-theme)))
#+END_SRC

** Debugging
*** Tracing
Some functions to trace the changing of variables.

#+BEGIN_SRC emacs-lisp
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
    (ic/watch-variable-call-func symbol 'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (sym value operation buffer)
      (let ((msg (ic//watch-variable-format sym buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol 'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol 'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (sym value operation buffer)
        (when (member operation ops)
          (apply func (list sym value operation buffer))))
      (add-variable-watcher symbol 'watch-change)
      (push (cons symbol 'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC

*** Profiling
Some profiler keybindings.

#+BEGIN_SRC emacs-lisp
  (require 'profiler)

  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))

  (defun ic/start-cpu-mem-profiler ()
    "Start both CPU and memory profiling."
    (interactive)
    (profiler-start 'cpu+mem))
#+END_SRC

** Keybinds
I like the spacemacs idea of having both a leader key (=SPC=) and a (mode-specific) local leader key (=,=). The leader key being how all the major functions are accessed, such as buffers/files/windows/etc. Where the local leader is how mode-specific functions are accessed, such as =org-mode= bindings or =mu4e=, etc.

There are a few things I don't care for though: I don't need emacs bindings, nor do I want access to the local leader map from the leader map (=SPC m=). So I want a dual leader key system without the cruft.

The package =general.el= makes all of the above rather simple. Here we ensure it's installed and activated with =:demand t=. We then setup two =definers=, one for the leader key (=leader-keys=) and one for the local leader key (=local-leader-keys=). Both =definers= define their keys in the =general-override-mode-map= keymap. This keymap has a high priority, but only when =general-override-mode= is active so ensure it is with =(general-override-mode 1)=.

=NOTE=: some of the above is outdated (as of [2021-12-12 Sun]). See [[*meow][meow]] for more details.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    ;; ensure `general-override-mode-map' is active
    (general-override-mode 1)
  
    ;; create leader (SPC) definer
    (general-create-definer leader-keys
      :keymaps 'global-leader-map
      ;; :prefix "SPC"
      )
  
    ;; create local leader (,) definer
    (general-create-definer local-leader-keys
      :keymaps 'general-override-mode-map
      :prefix emacs-local-leader-prefix))
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
      :config
      (which-key-mode 1))
#+END_SRC
* Packages
** all-the-icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** auto-dim-other-buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for color customization.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
      :config
      (setq auto-dim-other-buffers-dim-on-focus-out t)
      (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
      ;; ensure org-indent face is properly hidden
      (push '(org-indent . auto-dim-other-buffers-hide-face)
            auto-dim-other-buffers-affected-faces)
      (auto-dim-other-buffers-mode t))
#+END_SRC

** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :config
    (setq company-tooltip-align-annotations t)
    (setq company-abort-on-unique-match t)
    (setq company-tooltip-width-grow-only t)
  
    :general
    (general-define-key
     :keymaps 'company-active-map
     "C-l" 'company-show-location
     "C-h" 'company-show-doc-buffer
     "C-w" 'backward-kill-word
     "C-s" 'company-search-candidates
     "C-f" 'company-filter-candidates
     ))
#+END_SRC

** csharp-mode
Minimal setup for viewing =C#= code.

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode)
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    )
#+END_SRC

** haskell-mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :demand t)
#+END_SRC

** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :demand t
    :bind (:map global-map
           ([remap describe-function] . #'helpful-callable)
           ([remap describe-variable] . #'helpful-variable)
           ([remap describe-key] . #'helpful-key)))
#+END_SRC

** json
#+BEGIN_SRC emacs-lisp
  (use-package json)
#+END_SRC

** lsp
*** config
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :demand t
    :commands lsp

    :init
    ;; keep session file tidy
    (setq lsp-session-file (concat user-cache-directory "lsp-session-v1"))
    ;; don't show the top breadcrumbs by default
    (setq lsp-headerline-breadcrumb-enable nil)
    ;; keep more log data
    (setq lsp-log-max 10000)
    ;; setup c# lsp server
    (setq lsp-csharp-server-path
          (cond (on-home-windows-desktop-wsl
                 (executable-find "omnisharp"))))

    :hook
    ((lsp-mode . lsp-enable-which-key-integration)
     (csharp-mode . lsp))

    :general
    (local-leader-keys
      :keymaps 'prog-mode-map
      "l" lsp-command-map))
#+END_SRC

** lsp-ui
#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui)
#+END_SRC

** magit
For some reason on the Surface Pro 4 tablet we need to manually load =magit-section= before loading =magit= proper.
#+BEGIN_SRC emacs-lisp
  (when (or on-tablet on-old-imac)
    (use-package magit-section))
#+END_SRC

Main =magit= config.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    ;; don't use magit's default key bindings
    (setq magit-define-global-key-bindings nil)

    ;; I run emacs on my home windows desktop under MSYS2, but magit guesses that
    ;; it's running under CYGWIN, which screws up filename expansion
    (when on-home-windows-desktop
      (defun ic-magit-maybe-override-cygwin-paths (f &rest args)
        "Call `f' with correct binding of `magit-cygwin-mount-points'.

  When running emacs on windows under MSYS2, we need `magit' to rewrite local file
      paths using `magit-cygwin-mount-points', but ignore it for remote paths."
        (let ((magit-cygwin-mount-points
               (and (not (file-remote-p default-directory))
                    magit-cygwin-mount-points)))
          (apply f args)))
      (advice-add 'magit-expand-git-file-name :around
                  #'ic-magit-maybe-override-cygwin-paths)
      (advice-add 'magit-convert-filename-for-git :around
                  #'ic-magit-maybe-override-cygwin-paths))

    :general
    (general-define-key
     "C-x g" 'magit-status)
    (general-define-key
     :keymaps 'magit-section-mode-map
     "<up>" 'magit-section-backward
     "<down>" 'magit-section-forward)
    :bind (:map magit-status-mode-map
           ("x" . #'magit-discard)))
#+END_SRC

** org
=org-mode= is a large part of my daily emacs usage so it takes a large amount of my configuration as well. Let's go...

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
      :mode (("\\.org$" . org-mode))
      :ensure org-plus-contrib
      :after (all-the-icons yasnippet)
      :config
      <<org-config>>
      :general
      <<org-keybinds>>
      )
#+END_SRC

*** org-config
:PROPERTIES:
:header-args: :noweb-ref org-config :tangle no
:END:

**** Basic Setup
#+BEGIN_SRC emacs-lisp
  (defvar org-home-file "~/org/home/home.org"
    "Default org file for home related items.")
  (defvar org-work-file "~/org/work.org"
    "Default org file for work related items.")
  (defvar org-default-file (if at-home org-home-file org-work-file)
    "Default org file.")
  (setq org-default-notes-file
        (if at-home "~/org/home/inbox.org" "~/org/inbox.org"))
  (setq org-agenda-files
        (append (list ;;org-default-file
                      org-default-notes-file)
                (if at-home
                    '("~/org/home/mobileinbox.org"
                      "~/org/home/jobs.org"))
                ;; (directory-files "~/org" t "\\.org$")
                ))
  (setq org-archive-location "%s_archive::")
#+END_SRC

**** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp
  (defun ic/org-jump ()
    "Jump to an `org-refile-targets' heading."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-refile)))

  (defun ic/org-jump-in-buffer ()
    "Jump to a heading in the current buffer."
    (interactive)
    ;; `org-refile-targets' needs to be dynamically bound
    (defvar org-refile-targets)
    (let ((org-refile-targets '((nil :maxlevel . 999))))
      (ic/org-jump)))
#+END_SRC

**** Normal mode navigation
#+BEGIN_SRC emacs-lisp
  (defun ic/outline-current-heading-or-up ()
    "When point is on an org-mode heading: move to parent heading;
  otherwise: move to current heading."
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'outline-up-heading
                          'outline-previous-heading)))

  (defun ic/outline-current-heading-or-backward ()
    "when point is on an org-mode heading: move to previous heading;
  otherwise: move to previous heading"
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'org-backward-heading-same-level
                          'outline-previous-heading)))
#+END_SRC

**** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation nil)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: \Delta{}v \ne \pi
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t)
  ;; don't use super/sub-scripts as they mess with headings
  (setq org-pretty-entities-include-sub-superscripts nil)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Because =org-mode= is mostly prose use =buffer-face-mode= (along with setting the face =org-default=) to get variable pitch text. See the variable =themian-force-fixed-faces= for a list of faces that will remain fixed.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'buffer-face-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]]. See [[*org-bullets][org-bullets]] setup as well.
#+BEGIN_SRC emacs-lisp
  ;; ⚫•⦾⦿—⬎⌄⌵↴⤵↘↓↷┅🅐🅑🅒
  ;; ⌵
  (setq org-ellipsis " …")

  ;; replace certain org-mode text with symbols
  (defun ic/org-mode-pretty-symbols ()
    "Enable `prettify-symbols-mode' and set `prettify-symbols-alist' for certain
  `org-mode' symbols."
    ;; don't show the prettified symbol around point
    (setq prettify-symbols-unprettify-at-point t)
    (setq prettify-symbols-alist
          `(("[#A]" . ?Ⓐ)
            ("[#B]" . ?Ⓑ)
            ("[#C]" . ?Ⓒ)
            ("[ ]" . ?)
            ("[X]" . ?)
            ("[-]" . ?)
            ("#+BEGIN_SRC" . ?λ)
            ("#+END_SRC" . ?ƛ)
            ("CLOSED:" . ?⟁)
            ("SCHEDULED:" . ?)
            ("DEADLINE:" . ?)))
    (prettify-symbols-mode 1))

  (add-hook 'org-mode-hook #'ic/org-mode-pretty-symbols)
  (add-hook 'org-agenda-mode-hook #'ic/org-mode-pretty-symbols)
#+END_SRC

Change list items to symbol. Code inspired by [[https://emacs.stackexchange.com/questions/59882/how-to-change-color-of-font-lock-add-keywords][this]] stack exchange question.
#+BEGIN_SRC emacs-lisp
  (require 'org-element)

  (setq ic/org-list-icon (propertize "—" 'face 'themian-subtle))

  (defun org+-match-item-marker (bound)
    "Match the bullet of itemizations."
    (and
     (re-search-forward "^ *\\(-\\) " bound t)
     (save-match-data
       (save-excursion
         (goto-char (match-end 1))
         (eq (org-element-type (org-element-at-point)) 'item)))))

  ;; change list dashes
  (font-lock-add-keywords
   'org-mode
   `((org+-match-item-marker
      (1
       '(face default display ,ic/org-list-icon)
       append)))
   t)
#+END_SRC

Color priorities based on how important they are.
#+BEGIN_SRC emacs-lisp
  (setq org-priority-faces '((?A . '(:inherit (themian-error org-priority)))
                             (?B . 'org-priority)
                             (?C . '(:inherit (themian-weak org-priority)))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

**** org-src
Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

**** org-babel
Allow us to execute various languages in =org-src= blocks.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (shell . t)))
#+END_SRC

**** org-persist
Not sure what this is exactly, but let's ensure it keeps it's data files tidy.
#+BEGIN_SRC emacs-lisp
  (setq org-persist-directory (concat user-cache-directory "org-persist/"))
#+END_SRC

**** Agenda
***** Setup
#+BEGIN_SRC emacs-lisp
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(
          ;; work agenda
          ("w" "Work Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile/"
            ;;       ((org-agenda-overriding-header "Archive tasks:")
            ;;        (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            )
           ((org-agenda-tag-filter-preset '("-HOME"))))

          ;; home agenda
          ("h" "Home agenda"
           ((agenda ""
                    ((org-agenda-skip-function 'ic/skip-old-meal-plans)))
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile"
            ;;       ((org-agenda-overriding-header "\nArchive tasks:")
            ;;        (org-agenda-skip-function 'ic/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "\nNext Steps:")))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores-PRIORITY=\"A\"|jobs-PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))
                        ))
            (tags "+HOME"
                  ((org-agenda-overriding-header "\nStuck Projects")
                   (org-agenda-skip-function 'ic/org-skip-nonstuck-projects)
                   ))
            )
           ((org-agenda-tag-filter-preset '("+HOME"))))

          ;; archives
          ("a" . "Archiving")
          ("ah" "Home archive"
           ((tags "+HOME-noarchive/DONE|CANCELLED|APPLIED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ("aw" "Work archive"
           ((tags "-HOME-noarchive+TIMESTAMP_IA<=\"<-2w>\"/DONE|CANCELLED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ))
#+END_SRC

***** Appearance
#+BEGIN_SRC emacs-lisp
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)

  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)

  ;; show weekly agenda by default
  (setq org-agenda-span 'week)

  ;; don't have a separator between agenda sections
  (setq org-agenda-compact-blocks t)

  ;; show agenda icons
  (setq org-agenda-prefix-format "  %i %?-2 t%s")

  ;; highlight the current line
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)

  ;; hide some tags I mostly use for filtering only
  (setq org-agenda-hide-tags-regexp "\\(HOME\\|WORK\\|agenda\\)")
#+END_SRC

***** Test icons (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disable
  ;;; DISABLED ;;;

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (setq tab-width 2)
  ;;                                         ; (setq tab-stop-list '(2 3 5))
  ;;             ))

  (require 'all-the-icons)

  ;; (let ((font (find-font (font-spec :name "FontAwesome"))))
  ;;   (font-put font :spacing 100)
  ;;   (font-get font :spacing)
  ;;   )

  (defun ic/org-agenda-icon (family icon-name)
    (let* ((icon-func (cdr (assoc family
                                  '((ati . all-the-icons-alltheicon)
                                    (faicon . all-the-icons-faicon)
                                    (fileicon . all-the-icons-fileicon)
                                    (octicon . all-the-icons-octicon)
                                    (wicon . all-the-icons-wicon)))))
           (face-func (cdr (assoc family
                                  '((ati . all-the-icons-icon-family)
                                    (faicon . all-the-icons-faicon-family)
                                    (fileicon . all-the-icons-fileicon-family)
                                    (octicon . all-the-icons-octicon-family)
                                    (wicon . all-the-icons-wicon-family)))))
           (all-the-icons-scale-factor 1.0)
           ;; (font (concat (apply face-func nil) ":spacing=monospace"))
           (font "FontAwesomeMono:spacing=100")
           ;; (font (apply face-func nil))
           (face `(:family ,font :height 1.0))
           ;; (icon (apply icon-func (list icon-name :face 'default)))
           (icon (cdr (assoc icon-name all-the-icons-data/fa-icon-alist)))
           )
      (propertize icon
                  'face face
                  'font-lock-face face
                  ;; 'display '(space :width (50) :height 7)
                  ;; 'display '(space-width 5)
                  'rear-nonsticky t
                  )
      ))

  ;; (ic/org-agenda-icon 'faicon "calendar")

  ;; (let ((icon (all-the-icons-faicon "calendar")))
  ;;   (string-to-char icon))

  ;; setup agenda icons
  (setq org-agenda-category-icon-alist
        (let ((icon-mapping
               '(
                 ("annivers" faicon "calendar")
                 ("birthdays" faicon "birthday-cake")
                 ("chores" faicon "home")
                 ("computer" faicon "keyboard-o")
                 ("cpu" faicon "fax")
                 ("holidays" faicon "calendar-o")
                 ("cooking" faicon "cutlery")
                 ("health" faicon "heartbeat")
                 ("jobs" faicon "building-o")
                 ("life" faicon "male")
                 )))
          (mapcar (lambda (config)
                    ;; `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)) :width (50)) nil nil :ascent center :mask heuristic))
                    `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)))))
                  icon-mapping
                  )))

  (defun blaenk/set-char-widths (alist)
    (while (char-table-parent char-width-table)
      (setq char-width-table (char-table-parent char-width-table)))
    (dolist (pair alist)
      (let ((width (car pair))
            (chars (cdr pair))
            (table (make-char-table nil)))
        (dolist (char chars)
          (set-char-table-range table char width))
        (optimize-char-table table)
        (set-char-table-parent table char-width-table)
        (setq char-width-table table))))

  (defconst old-char-width-table char-width-table)

  ;; argument is an alist of width and list of RANGEs,
  ;; which is the same as the RANGE that set-char-table-range accepts
  ;; (blaenk/set-char-widths
  ;;  `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;           ,(string-to-char (all-the-icons-faicon "home"))
  ;;           ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;           ))))

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (message "set-char-widths")
  ;;             (blaenk/set-char-widths
  ;;              `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;                       ,(string-to-char (all-the-icons-faicon "home"))
  ;;                       ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;                       ))))
  ;;                            ))




  ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping
  ;;              '(
  ;;                ("annivers" (all-the-icons-faicon "calendar"))
  ;;                ("birthdays" (all-the-icons-faicon "birthday-cake"))
  ;;                ("chores" (all-the-icons-faicon "home"))
  ;;                ("computer" (all-the-icons-faicon "keyboard-o"))
  ;;                ("cpu" (all-the-icons-faicon "fax"))
  ;;                ("holidays" (all-the-icons-faicon "calendar-o"))
  ;;                ("cooking" (all-the-icons-faicon "cutlery"))
  ;;                ("health" (all-the-icons-faicon "heartbeat"))
  ;;                ("jobs" (all-the-icons-faicon "building-o"))
  ;;                ("life" (all-the-icons-faicon "male"))
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (car config))
  ;;                         (icon (apply (caadr config) (cdadr config))))
  ;;                     `(,category (list ,icon :width (100)) nil nil :ascent center :mask heuristic :width (100))))
  ;;                 icon-mapping)))



  ;; ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping-alist
  ;;              '(
  ;;                ("annivers" 'faicon "calendar")
  ;;                ("birthdays" 'faicon "birthday-cake")
  ;;                ("chores" 'faicon "home")
  ;;                ("computer" 'faicon "keyboard-o")
  ;;                ("cpu" 'faicon "fax")
  ;;                ("holidays" 'faicon "calendar-o")
  ;;                ("cooking" 'faicon "cutlery")
  ;;                ("health" 'faicon "heartbeat")
  ;;                ("jobs" 'faicon "building-o")
  ;;                ("life" 'faicon "male")
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (first config))
  ;;                         (icon-family (second config))
  ;;                         (icon-name (third config))
  ;;                         (ati-family-alist
  ;;                          '(('ati . all-the-icons-alltheicon)
  ;;                            ('faicon . all-the-icons-faicon)
  ;;                            ('fileicon . all-the-icons-fileicon)
  ;;                            ('octicon . all-the-icons-octicon)
  ;;                            ('wicon . all-the-icons-wicon))))
  ;;                 `(,category (list ,(apply (cdr (assoc icon-family ati-family-alist)) (list icon-name :height 0.9 :v-adjust 0))) nil nil :ascent center :mask heuristic)))
  ;;                   icon-mapping-alist)))
#+END_SRC

***** Functions
****** Open agenda
I want to open the correct agenda (home/work) automatically.
#+BEGIN_SRC emacs-lisp
  (defun ic-open-org-agenda ()
    "Open the correct org agenda based on location (home/work)."
    (interactive)
    (cond (at-home (org-agenda nil "h"))
          (at-work (org-agenda nil "w"))
          (t (org-agenda))))
#+END_SRC

****** Stuck Projects
I have a somewhat loose definition of what constitutes a project. I consider any org heading a project if:
- It has a todo state and none of it's ancestors do
- It has one or more immediate children with todo states

Furthermore I consider a stuck project:
- A project with no descendants having a NEXT todo state

#+BEGIN_SRC emacs-lisp
  (defun ic/org-is-active-task-p (&optional state)
    "Returns `t' if the current task is a member of
  `org-not-done-keywords'. When specified, use STATE as the active
  state, defaulting to `org-not-done-keywords'."
    (member (org-get-todo-state)
            (if state (list state) org-not-done-keywords)))

  (defun ic/org-any-active-parent-p ()
    "Return `t' if any parent task is an active task."
    (save-excursion
      (widen)
      (let (active-parent)
        (while (and (not active-parent)
                    (org-up-heading-safe))
          (when (ic/org-is-active-task-p)
            (setq active-parent t)))
        active-parent)))

  (defun ic/org-any-active-children-p (&optional state)
    "Return `t' when any descendant is an active task. When
    specified, use STATE as the active state, defaulting to
    `org-not-done-keywords'."
    (save-excursion
      (let ((subtree-end (save-excursion
                           (org-end-of-subtree t)))
            (child-regex (format "^\\*\\{%d,\\} "
                                 (+ 1 (org-current-level))))
            active-child)
        (while (and (not active-child)
                    (re-search-forward child-regex
                                       subtree-end t))
          (when (ic/org-is-active-task-p state)
            (setq active-child t)))
        active-child)))

  (defun ic/org-is-project-p ()
    "Return `t' when the current task is considered a project."
    (and (ic/org-is-active-task-p)
         (not (ic/org-any-active-parent-p))
         (ic/org-any-active-children-p)))

  (defun ic/org-is-stuck-project-p ()
    "Return `t' when the current task is considered a stuck
  project."
    (and (ic/org-is-project-p)
         (not (ic/org-any-active-children-p "NEXT"))))

  (defun ic/org-skip-nonstuck-projects ()
    (let ((debug-on-error t))
      (save-excursion
        (widen)
        (unless (ic/org-is-stuck-project-p)
          (or (outline-next-heading) (point-max))))))
#+END_SRC

**** Habits
#+BEGIN_SRC emacs-lisp
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 2)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today t)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC

**** Todo
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC

**** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC

**** Capture
***** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("T" "test org-protocol" entry (file org-default-notes-file)
           "* TODO %:description\n%U\n\n#+begin_quote\n%:initial\n#+end_quote\n/From: [[%:link][here]]./\n\n%?"
           :immediate-finish t
           )
          ("r" "reply" entry (file org-default-notes-file)
           "* TODO Reply to %:from on %:subject\nSCHEDULED: %t\n%u\n%a\n"
           :immediate-finish t
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("b" "books")
          ("bp" "pleasure" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bP" "pleasure (already read)" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("be" "enrichment" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bE" "enrichment (already read)" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("bt" "technical" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bT" "technical (already read)" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")))
#+END_SRC

***** Books
I want a system to pull in book information (isbn, authors, etc) based on a search query and generate an =org-mode= item.

****** Open Library
As =Goodreads= is no longer offering API access I had to research where to pull down book information. [[https://openlibrary.org/][OpenLibrary]] seems to be the best option currently. So let's create some functions to query it for book information.

First, we need some variables defined:
#+BEGIN_SRC emacs-lisp
  (defconst ic/openlibrary-base-endpoint
    "http://openlibrary.org")

  (defvar ic/openlibrary-max-results 100
    "Maximum results requested from OpenLibrary.")

  (defvar ic/openlibrary--use-cached-data nil
    "Store results from OpenLibrary in cache?")

  (defvar ic/openlibrary--query-string ""
    "Query string to search OpenLibrary for. Internal use only.")
#+END_SRC

We'll need some functions to query =OpenLibrary= and parse the results. We can get most of the data from the search query, only missing the description found in the =Work=, so we can make that call only when needed (after selecting an item in helm).
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--request (url &optional args)
    (let (result)
      (request
        url
        :params args
        :parser 'json-read
        :sync t
        :timeout 10
        :error (cl-function
                (lambda (&key error-thrown &allow-other-keys)
                  (error "error fetching (%s): %s"
                         url
                         (cdr error-thrown))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (setq result data))))
      result))
#+END_SRC

Now we'll need a function to take the raw data returned from =OpenLibrary= and translate it into a format more useful to us.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-search-results (data)
    "Take DATA in OpenLibrary search.json format and parse it into a list of
  ALISTs."
    (mapcar
     (lambda (doc)
       (cl-flet*
           ((to-list (vec) (append vec nil))
            (get (attr &optional alist) (assoc-default attr (or alist doc)))
            (get-list (attr &optional alist) (to-list (get attr (or alist doc))))
            (get-first (attr &optional alist) (car (get-list attr (or alist doc)))))
         `((title . ,(get 'title))
           (query-title . ,(s-replace-regexp " " "+" (get 'title)))
           (ol-work-id . ,(get 'key))
           (ol-author-ids . ,(get-list 'author_key))
           (edition-count . ,(get 'edition_count))
           (first-year-published . ,(get 'first_publish_year))
           (pages-median . ,(get 'number_of_pages_median))
           (public-scan . ,(not (eq (get 'public_scan_b) ':json-false)))
           (authors . ,(get-list 'author_name))
           (goodreads-id . ,(get-first 'id_goodreads))
           (librarything-id . ,(get-first 'id_librarything)))))
     (assoc-default 'docs data)))
#+END_SRC

Now, make another call to =LibraryThing= and check for =Work= data to add in.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--add-work-data (doc)
    "Query OpenLibrary for the work contained in DOC and add in any needed data."
    (let* ((data (ic/openlibrary--request
                  (concat "http://openlibrary.org"
                          (assoc-default 'ol-work-id doc)
                          ".json")))
           (desc-raw (assoc-default 'description data))
           (desc-value (if (eq (type-of desc-raw) 'cons)
                           (assoc-default 'value desc-raw)
                         desc-raw))
           (desc-clean (if desc-value
                           (replace-regexp-in-string
                            ;; OL links in [title](link format)
                            "\\[\\(.*\\)](\\(.*\\))"
                            ;; replace with org-mode format
                            "[[\\2][\\1]]"
                            ;; remove windows new lines
                            (replace-regexp-in-string "\u000d" "" desc-value))
                         nil)))
      (cons (cons 'description desc-clean)
            doc)))
#+END_SRC

Finally, we can put all that together into one supporting function.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary-search (query)
    "Run QUERY against OpenLibrary and return results as a list of association
  lists."
    (ic/openlibrary--parse-search-results
     (ic/openlibrary--request
      (concat ic/openlibrary-base-endpoint "/search.json")
      `(("q" . ,(split-string query " " t))
        ("limit" . ,ic/openlibrary-max-results)
        ("mode" . "everything")))))
#+END_SRC

****** TODO Helm
/need to rewrite against completing-read/
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary-helm-find-book ()
    "Prompt user for query string to search OpenLibrary, then display helm buffer
  to select book. Returns an ALIST with OpenLibrary data."
    (interactive)
    (error "helm not installed")
    (setq ic/openlibrary--query-string
          (read-from-minibuffer "Search OpenLibrary: "))
    (helm :sources
          (helm-build-sync-source
              (format "OpenLibrary (%s)" ic/openlibrary--query-string)
            :candidates 'ic/openlibrary--helm-candidates
            :candidate-number-limit ic/openlibrary-max-results
            :fuzzy-match t
            :coerce 'ic/openlibrary--add-work-data)
          :buffer "*helm openlibrary*"))
#+END_SRC

Now we need a function to query the search page from =OpenLibrary=. It uses the global variable =ic/openlibrary--query-string= to determine the query.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--helm-candidates ()
    "Searches OpenLibrary for `ic/openlibrary--query-string', returning data in
  `((DISPLAY . DATA) ...)' format for use as a helm source."
    (mapcar 'ic/openlibrary--parse-helm-format
            (ic/openlibrary--parse-search-results
             (ic/openlibrary--request
              (concat ic/openlibrary-base-endpoint "/search.json")
              `(("q" . ,(split-string ic/openlibrary--query-string " " t))
                ("limit" . ,ic/openlibrary-max-results)
                ("mode" . "everything"))))))
#+END_SRC

Finally, we need a function to take the data from =OpenLibrary= and return it in a (pretty) format that =helm= will use to display to the user.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-helm-format (doc)
    "Take data in OpenLibrary format and return in `(DISPLAY . DATA)' format
  needed for helm."
    (cons
     (concat (propertize (assoc-default 'title doc) 'face 'helm-ol-title)
             (propertize " :: " 'face 'helm-ol-separator)
             (propertize (string-join (assoc-default 'authors doc) ", ")
                         'face 'helm-ol-author)
             (propertize " [" 'face 'helm-ol-separator)
             (format "%s" (assoc-default 'first-year-published doc))
             (propertize "] -- " 'face 'helm-ol-separator)
             (propertize (format "%s editions" (assoc-default 'edition-count doc))
                         'face 'helm-ol-editions))
     doc))
#+END_SRC

****** completing-read
Now let's use =completing-read= to lookup a book.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--lookup-work (works olid)
    "Given a list of association lists in WORKS, return the alist with 'ol-word-id
  equal to OLID."
    (when works
      (if (equal (cdr (assoc 'ol-work-id (car works)))
                 olid)
          (car works)
        (ic/openlibrary--lookup-work (cdr works) olid))))

  (defun ic/openlibrary-find-book (&optional query results)
    (interactive)
    (let* ((query (or query (read-from-minibuffer "Search OpenLibrary: ")))
           (results (or results (ic/openlibrary-search query)))
           (titles (mapcar (lambda (work) (alist-get 'title work))
                           results)))
      (ic/openlibrary--lookup-work
       results
       (completing-read
        (format "Search OpenLibrary (%s): " query)
        (lambda (str pred action)
          (if (eq action 'metadata)
              `(metadata
                (annotation-function
                 . ,(lambda (cand)
                      (let ((work
                             (ic/openlibrary--lookup-work
                              results cand)))
                        (format " by %s [%d] %s {%s %s %s}"
                                (alist-get 'authors work)
                                (alist-get 'first-year-published work)
                                (if-let ((editions (alist-get 'edition-count
                                                              work)))
                                    (format "%d editions" editions)
                                  "")
                                (alist-get 'ol-work-id work)
                                (alist-get 'goodreads-id work)
                                (alist-get 'librarything-id work))))))
            (complete-with-action action titles str pred)))))))

  (defun ic/openlibrary-find-book (&optional query results)
    (interactive)
    (let* ((query (or query (read-from-minibuffer "Search OpenLibrary: ")))
           (results (or results (ic/openlibrary-search query)))
           (collection
            (mapcar
             (lambda (work)
               (format "%s by %s [%s] %s"
                       (alist-get 'title work)
                       (or (and (alist-get 'authors work)
                                (string-join (alist-get 'authors work) " & "))
                           "?")
                       (or (alist-get 'first-year-published work) "?")
                       (alist-get 'ol-work-id work)))
             results))
           (selected (completing-read
                      (format "Search OpenLibrary (%s): " query)
                      collection))
           (olid (car (last (split-string selected " ")))))
      (ic/openlibrary--lookup-work results olid)))
#+END_SRC

****** Capture
Now, we need a function that takes the data from =OpenLibrary= and generates an =org-mode= element for us to use.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-capture-book (&optional already-read)
    "`org-capture' task for a new book. Prompts the user for a query string to
  search OpenLibrary against and generate an `org-mode' element from the resulting
    data."
    (let* ((result "")
           (doc (ic/openlibrary-find-book)))
      (cl-flet* ((add (fmt &rest args)
                      (when (-all? 'identity args)
                        (setq result (concat result
                                             (apply 'format fmt args))))))
        (add "* %s %s :: %s [%s]\n"
             (if already-read "DONE" "TODO")
             (assoc-default 'title doc)
             (string-join (assoc-default 'authors doc) ", ")
             (assoc-default 'first-year-published doc))
        (add ":PROPERTIES:\n")
        (add ":TITLE: %s\n" (assoc-default 'title doc))
        (add ":AUTHORS: %S\n" (assoc-default 'authors doc))
        (add ":PAGES_MEDIAN: %s\n" (assoc-default 'pages-median doc))
        (add ":FIRST_YEAR_PUBLISHED: %s\n" (assoc-default 'first-year-published doc))
        (add ":PUBLIC_SCAN: %s\n" (assoc-default 'public-scan doc))
        (add ":OL_AUTHOR_IDS: %S\n" (assoc-default 'ol-author-ids doc))
        (add ":OL_WORK_ID: %s\n" (assoc-default 'ol-work-id doc))
        (add ":GOODREADS_ID: %s\n" (assoc-default 'goodreads-id doc))
        (add ":LIBRARYTHING_ID: %s\n" (assoc-default 'librarything-id doc))
        (add ":END:\n")
        (add "%%u\n\n")
        (add "#+BEGIN_QUOTE\n%s\n#+END_QUOTE\n\n" (assoc-default 'description doc))
        (add "** Links\n")
        (add "- [[http://openlibrary.org%s][OpenLibrary]]\n"
             (assoc-default 'ol-work-id doc))
        (dolist (tuple (-zip (assoc-default 'authors doc)
                             (assoc-default 'ol-author-ids doc)))
          (add "- [[http://openlibrary.org/authors/%s][OpenLibrary - %s]]\n"
               (cdr tuple) (car tuple)))
        (add (concat "- [[https://librarything.com"
                     (if-let (id (assoc-default 'librarything-id doc))
                         (format "/work/%s" id)
                       (format "/search.php?search=%s"
                               (assoc-default 'query-title doc)))
                     "][LibraryThing]]\n"))
        (when (assoc-default 'public-scan doc)
          (add (concat "- [[https://www.gutenberg.org/ebooks/search/?query=%s]"
                     "[Project Gutenberg]]\n")
             (assoc-default 'query-title doc)))
        (add "- [[https://www.overdrive.com/search?q=%s][Overdrive]]\n"
             (assoc-default 'query-title doc))
        (add (concat "- [[https://goodreads.com"
                     (if-let (id (assoc-default 'goodreads-id doc))
                         (format "/book/show/%s" id)
                       (format "/search?q=%s&search_type=books"
                               (assoc-default 'query-title doc)))
                     "][Goodreads]]\n"))
        (add "- [[https://amazon.com/s?k=%s][Amazon]]\n"
             (assoc-default 'query-title doc))
        (add "\n")
        (add "** Notes\n\n"))
      result))


  (defun ic/org-capture-book-read ()
    "Same as `ic/org-capture-book', but mark entry as DONE instead."
    (ic/org-capture-book t))
#+END_SRC

****** TODO Faces
/does this really need to be tied to helm?/

I like my =helm= searches to be pretty, so let's define some faces to use for that.
#+BEGIN_SRC emacs-lisp
  (defface helm-ol-title nil
    "Face used for OpenLibrary titles in a helm buffer.")

  (defface helm-ol-author nil
    "Face used for OpenLibrary authors in a helm buffer.")

  (defface helm-ol-editions nil
    "Face used for OpenLibrary edition counts in a helm buffer.")

  (defface helm-ol-seperator nil
    "Face used for OpenLibrary seperators in a helm buffer.")
#+END_SRC

***** Full Frame
The standard =org-capture= behavior is to split the window before capturing a task. When this is started from outside emacs a random buffer occupies half the frame. What I want is the capture buffer to take the full frame when starting the capture from outside emacs. My window manager will start the capture task with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook where it splits the frame we'll need to advise it to ~(delete-other-windows)~ when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC

**** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disabled
  (require 'org-clock)

  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  ;; persist open clocks
  (setq org-clock-persist-file (concat user-cache-directory "org-clock-save.el"))
  (org-clock-persistence-insinuate)

  (defun ic/org-clock-jump-to-current-clock ()
    "Jump to the currently active clock."
    (interactive)
    ;; why isn't this (interactive) already, ugh
    (org-clock-jump-to-current-clock))
#+END_SRC

**** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
#+END_SRC

It would be handy to have a function that would handle =org-mode= style time strings such as =+3d=, =-1w=, etc.
#+BEGIN_SRC emacs-lisp
  (defun ic-parse-org-date-string (time-str &optional next-day-when-no-time)
    "Translate TIME-STR into an emacs encoded time based on `org-read-date-*'
  syntax rules such as: +1d, -3w, etc. When NEXT-DAY-WHEN-NO-TIME is non-nil and
    TIME-STR does not contain a time component then use the next day. Returns nil
    on invalid time string."
    (setq org-time-was-given nil)
    (let* ((org-time (org-read-date-analyze
                      time-str
                      ;; encoded default time
                      (list 0 0 0 0)
                      ;; decoded default time
                      (list 0 0 0 0 0 0 0 0 0)))
           ;; `org-read-date-analyze' will return the default date if it failed to
           ;; parse a valid time string. We check for year 2000 because of the
           ;; following line in `org-read-date-analyze':
           ;;     (when (< year 100) (setq year (+ 2000 year)))
           (bad-time (list 0 0 0 0 0 2000))
           (encoded-time (apply #'encode-time org-time)))
      (cond ((equal org-time bad-time)
             (error "invalid time string: %s" time-str))
            ((or org-time-was-given (not next-day-when-no-time))
             ;; we either specified a time or we don't want to use the following day
             encoded-time)
            (t
             ;; we didn't specify a time and we want to use the *following* day
             (time-add encoded-time (* 24 60 60))))))
#+END_SRC

**** org-id
Keep track of =org-mode= items with a guid. This is required by =zeitan= / =org-roam=.
#+BEGIN_SRC emacs-lisp
  ;; save id locations in a nicer place
  (setq org-id-locations-file (concat user-cache-directory "org-id-locations"))

  (setq org-id-files (append (directory-files "~/org" t "\\.org$")
                             (directory-files "~/org/home" t "\\.org$")
                             (and (boundp 'org-id-files) org-id-files)))
#+END_SRC

**** Code Execution
Don't prompt for code execution if we're in a file in certain locations.

#+BEGIN_SRC emacs-lisp
  (defvar ic/allow-babel-evaluate-directories
        '("~/org" "~/.etc"))

  (defun ic/org-confirm-babel-evaluate (_lang _body)
    (let ((filename (buffer-file-name))
          match)
      (dolist (path ic/allow-babel-evaluate-directories (not match))
        (when (string-prefix-p (expand-file-name path) filename)
          (setq match t)))))

  (setq org-confirm-babel-evaluate #'ic/org-confirm-babel-evaluate)
#+END_SRC

**** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want to see most everything else.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC

**** Snippets
By convention I title most of my snippets ={snippet}>= so I would like the =>= key to try and expand snippets automatically. When no snippet is found a regular =>= should be entered.
#+BEGIN_SRC emacs-lisp
  (defun ic/yas-expand-> ()
    (interactive)
    (insert ">")
    (yas-expand))
#+END_SRC

Based on [[https://emacs.stackexchange.com/questions/29758/yasnippets-and-org-mode-yas-next-field-or-maybe-expand-does-not-expand][this]] stackexchange post =org-mode= binds the tab key in such a way that =yas-snippets= can't use it. So we need the following to allow =TAB= to expand snippets while in =org-mode=.
#+BEGIN_SRC emacs-lisp
  (defun ic/set-org-mode-tab-key ()
    (add-to-list 'org-tab-first-hook 'yas-expand)
    ;; XXX is this needed?
    ;; (general-define-key yas-keymap
    ;;   "<tab>" 'yas-next-field)
    )

  (add-hook 'org-mode-hook 'ic/set-org-mode-tab-key)
#+END_SRC

**** Insert list item
I want to hit =M-RET= from either insert or normal mode and insert a new list item at the same level as the current item. The new item should also have a checkbox when the current item does.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-insert-item-dwim ()
    "Insert an org item, with optional checkbox, below current item."
    (interactive)
    (when-let (item-pos (org-in-item-p))
      (goto-char item-pos)
      (org-insert-item (org-at-item-checkbox-p))
      (org-metadown)))

  (defun ic/org-insert-item-dwim-go-insert-mode ()
    "Call `ic/org-insert-item-dwim' and enter insert mode."
    (interactive)
    (when (ic/org-insert-item-dwim)
      (cond ((fboundp 'meow-insert-mode)
             (meow-insert-mode))
            ((fboundp 'evil-insert)
             (evil-insert 0)))))
#+END_SRC

**** Weekly Review
#+BEGIN_SRC emacs-lisp
  (defvar ic/weekly-reviews-directory "~/org/home/weekly-reviews")

  (defun ic/org-completed-date (heading)
    "Return the date of completion for HEADING."
    (org-timestamp-format (org-element-property :closed heading)
                          "%s"))

  (defun ic/org-completed-date-< (heading-left heading-right)
    "Return non-nil when the completed date of HEADING-LEFT is earlier than the
  completed date of HEADING-RIGHT."
    (let ((left-ts (ic/org-completed-date heading-left))
          (right-ts (ic/org-completed-date heading-right)))
      (cond ((and left-ts right-ts)
             (string< left-ts right-ts))
            (left-ts t)
            (right-ts nil))))

  (defun ic/org-element-get-link (elem &optional link-title)
    "Get a link (as a string) to the org-element ELEM."
    (let* ((marker (org-element-property :org-marker elem))
           (level (org-element-property :level elem))
           (title (org-element-property :raw-value elem))
           (search (org-with-point-at marker
                     (org-link-heading-search-string)))
           (file (buffer-file-name (marker-buffer marker)))
           (link 
            (format "[[%s][%s]]"
                    (format "file:%s::%s" file search)
                    (or link-title title))))
      (set-text-properties 0 (length link) nil link)
      link))

  (defun ic/weekly-review-items ()
    "Return a string containing all items needed for the weekly review in a form
  for direct insertion into a `yasnippit'."
    (let ((org-files (seq-filter #'file-exists-p
                                 (mapcar #'expand-file-name org-agenda-files)))
          current-date)
      (mapconcat (lambda (heading)
                   (let* ((ts (org-element-property :closed heading))
                          (date (format "%s-%s-%s"
                                        (org-element-property :year-start ts)
                                        (org-element-property :month-start ts)
                                        (org-element-property :day-start ts)))
                          (link (ic/org-element-get-link heading)))
                     (concat
                      (when (not (equal current-date date))
                        (setq current-date date)
                        (format-time-string "%A, %d %B %Y\n"
                                            (org-timestamp-to-time ts)))
                      "- " link)))
                 (org-ql-select org-files
                   '(and (tags "HOME")
                         (not (tags "noarchive"))
                         (todo "DONE" "APPLIED"))
                   :action 'element-with-markers
                   :sort #'ic/org-completed-date-<)
                 "\n")))

  (defun ic/weekly-review ()
    "Create a weekly review `org-mode' buffer with all completed tasks."
    (interactive)
    (let* ((year (format-time-string "%Y"))
           (week (format-time-string "%U"))
           (directory (format "%s/%s" ic/weekly-reviews-directory year))
           (filename (format "%s/weekly-review-%s.org" directory week)))
      (unless (file-directory-p directory)
        (make-directory directory t))
      (when (or (not (file-exists-p filename))
                (yes-or-no-p (format "Weekly review for week %s of %s already exists. Delete and re-create? "
                                     week year)))
        (find-file filename)
        (erase-buffer)
        (org-mode)
        (yas-expand-snippet (yas-lookup-snippet "weekly review"))
        (save-buffer))))
#+END_SRC

**** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/skip-non-archivable-tasks ()
    "Skip tasks that I don't want to archive"
    (or (ic/skip-old-meal-plans)
        (bh/skip-non-archivable-tasks)))


  (defun ic/skip-old-meal-plans ()
    "Skip over a task if it's 1) a meal plan and 2) scheduled before today."
    (save-restriction
      (widen)
      (let* ((tags (org-get-tags))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (scheduled (org-get-scheduled-time (point)))
             (yesterday (* 60 60 24 1))
             ;; HACK we check 24 hours ago rather than previous midnight
             (now (time-subtract (current-time) (seconds-to-time yesterday))))
        (if (and (member "cooking" tags)
                 (member "plan" tags)
                 scheduled
                 (time-less-p scheduled now))
            subtree-end
          nil))))


  (defun ic/org-recipe-publish-to-html (_plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC

*** org-keybinds
:PROPERTIES:
:header-args: :noweb-ref org-keybinds :tangle no
:END:

**** local-leader
Main =local-leader= key binds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "'" 'org-edit-special
    ":" 'org-set-tags-command
    "^" 'org-sort
    "A" 'org-archive-subtree
    "D" 'org-insert-drawer
    "d" 'org-deadline
    "f" 'org-set-effort
    "H" 'org-shiftleft
    "J" 'org-shiftdown
    "K" 'org-shiftup
    "L" 'org-shiftright
    "l" 'org-open-at-point
    "N" 'widen
    "n" 'org-narrow-to-subtree
    "p" 'org-priority
    "P" 'org-set-property
    "r" 'org-refile
    "s" 'org-schedule
    "t" 'org-todo
    "w" 'org-save-all-org-buffers
    )
#+END_SRC

=,C= clocks keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "C"
    "" '(nil :which-key "clocks")
    "i" 'org-clock-in
    "j" 'ic/org-clock-jump-to-current-clock
    "o" 'org-clock-out
    "q" 'org-clock-cancel)
#+END_SRC

=,e= export keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "e"
    "" '(nil :which-key "export")
    "e" 'org-export-dispatch
    "T" 'org-babel-tangle-file
    "t" 'org-babel-tangle)
#+END_SRC

=,i= insert keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "i"
    "" '(nil :which-key "insert")
    "a" 'org-attach
    "f" 'org-footnote-new
    "l" 'org-insert-link
    "t" 'org-time-stamp
    "T" 'org-time-stamp-inactive
    "s" 'org-download-screenshot
    "y" 'org-download-yank
    )
#+END_SRC

TODO =,T= tables keybinds
#+BEGIN_SRC emacs-lisp

#+END_SRC

**** org-agenda-mode
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-agenda-mode-map
    "d" 'org-agenda-deadline
    "f" 'org-agenda-set-effort
    "p" 'org-agenda-priority
    "P" 'org-agenda-set-property
    "r" 'org-agenda-refile
    "s" 'org-agenda-schedule
    "t" 'org-agenda-todo
    )
#+END_SRC

**** org-src
=org-src-mode= bindings:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps 'org-src-mode-map
    "c" '(org-edit-src-exit :which-key "org-edit-src-exit")
    "k" 'org-edit-src-abort
    )
#+END_SRC

**** leader-key
=leader-key= keybinds:
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "o"
    "" '(nil :which-key "org-mode")
    "a" 'org-agenda
    "c" 'org-capture
    "j" 'ic/org-jump-in-buffer
    "J" 'ic/org-jump
    )

  (leader-keys
    :infix "oC"
    "" '(nil :which-key "clocks")
    "f" 'org-clock-modify-effort-estimate
    "i" 'org-clock-in
    "g" 'org-clock-goto
    "o" 'org-clock-out
    "l" 'org-clock-in-last
    "r" 'org-clock-report
    )
#+END_SRC

**** global
global keybinds:
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<f12>" 'ic-open-org-agenda
   "M-<f12>" 'org-clock-goto
   )
#+END_SRC

**** normal mode
Here I have some custom normal mode navigation.
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :keymaps 'org-mode-map

    "<left>"      'ic/outline-current-heading-or-up
    "<up>"        'ic/outline-current-heading-or-backward
    "<down>"      'org-forward-heading-same-level
    "<right>"     'outline-next-visible-heading

    "S-<left>"    'org-promote-subtree
    "S-<up>"      'org-move-subtree-up
    "S-<down>"    'org-move-subtree-down
    "S-<right>"   'org-demote-subtree

    "C-S-<left>"  'org-do-promote
    "C-S-<right>" 'org-do-demote

    "M-<return>" 'ic/org-insert-item-dwim-go-insert-mode
    )
#+END_SRC

**** insert mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps 'org-mode-map
      ">" 'ic/yas-expand->
      "M-<return>" 'ic/org-insert-item-dwim
      )
#+END_SRC

** org-bullets
Let's have some fancy heading bullets.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("•"))
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-protocol
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

** org-roam
Most of this config is located under [[*Zetian][Zetian]], but I'll do the initial =use-package= and define the keybinds in here.
#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :demand t
    :requires org
    :init
    (setq org-roam-v2-ack t)
    (setq org-roam-directory "~/org/home/roam")
    (setq org-roam-db-location
          (concat user-cache-directory "org-roam.db"))
    (setq org-roam-completion-everywhere t)
    (setq org-id-files (append (directory-files org-roam-directory t "\\.org$")
                               (and (boundp 'org-id-files) org-id-files)))

    :config
    ;; the org-element cache messes with correct category lookup and seems to
    ;; break org-roam sometimes, so disable it
    (setq org-element-use-cache nil)
    (org-roam-setup)
    (require 'org-roam-protocol)
    :bind (("<f2>" . org-roam-capture)
           :map global-leader-map
           :prefix "z"
           :prefix-map zetian
           ("b" . org-roam-buffer-toggle)
           ("D" . org-roam-db-diagnose-node)
           ("i" . zetian-link-insert)
           ("I" . zetian-link-insert-immediate)
           ("u" . org-roam-ui-open)
           :prefix "zc"
           :prefix-map zetian-capture
           ("c" . org-roam-capture)
           :prefix "zcb"
           :prefix-map zetian-capture-books
           ("b" . zetian-capture-book)
           ("p" . zetian-capture-book-pleasure-toread)
           ("P" . zetian-capture-book-pleasure-completed)
           ("e" . zetian-capture-book-enrichment-toread)
           ("E" . zetian-capture-book-enrichment-completed)
           :prefix "zf"
           :prefix-map zetian-find
           ("f" . zetian-node-find)
           ("a" . zetian-find-author)
           ("b" . zetian-find-book)
           ("c" . zetian-find-category)
           ("e" . zetian-find-open-event)
           ("l" . zetian-find-link-to)
           ("L" . zetian-find-link-from)
           ("o" . zetian-find-task-open-orphaned)
           ("p" . zetian-find-project)
           ("P" . zetian-find-stuck-projects)
           ("r" . zetian-find-review)
           ("s" . zetian-find-state)
           ("S" . zetian-find-strange)
           ("t" . zetian-find-task-next)
           :prefix "zfT"
           :prefix-map zetian-find-tasks
           ("a" . zetian-find-task)
           ("l" . zetian-find-task-open-link)
           ("n" . zetian-find-task-next)
           ("o" . zetian-find-task-open)
           ("p" . zetian-find-task-next-project)
           ("P" . zetian-find-task-open-project)
           ("T" . zetian-find-task)
           ))

  (local-leader-keys 'org-mode-map
    :infix "z"
    "" '(nil :which-key "zetian")
    "s" #'zetian-add-state
    "S" #'zetian-remove-state
    "t" #'zetian-add-tag
    "T" #'zetian-remove-tag
    "p" #'zetian-add-project
    "P" #'zetian-remove-project
    )
#+END_SRC

** org-roam-ui
#+BEGIN_SRC emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+END_SRC

** org-ql
Let's try having a nice search interface for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package org-ql)
#+END_SRC

** projectile
This used to be much more involved, but I found a lot of my project specific code just wasn't all that useful and I'm trying to pare down my config as much as possible, so let's see what a more or less default =projectile= can look like.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand t
    :init
    ;; ensure projectile saves its files in a nice location
    (setq projectile-cache-file
          (concat user-cache-directory "projectile.cache"))
    (setq projectile-known-projects-file
          (concat user-cache-directory "projectile-bookmarks.eld"))

    :config
    (projectile-mode 1)

    :general
    (leader-keys
      "p" 'projectile-command-map))
#+END_SRC

** requests
=emacs-request= is a library for making HTTP requests easily.
#+BEGIN_SRC emacs-lisp
  (use-package request)
#+END_SRC

** smartparens
Keep my toe-nail clippings in balance.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :demand t
    :config
    (require 'smartparens-config)
    (smartparens-global-strict-mode 1)
    ;; don't run smartparens in the minibuffer
    (add-hook 'minibuffer-mode-hook 'turn-off-smartparens-strict-mode)

    ;; XXX this is shadowing the insert mode binding for some reason
    ;; :general
    ;; (general-define-key
    ;;  :keymaps 'emacs-lisp-mode-map
    ;;  "^" #'sp-backward-up-sexp)
    )
#+END_SRC

** spaceline
I want a pretty mode-line. Note: most of the configuration happens in the =spaceline-all-the-icons= package.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
      :config
      ;; disable separators
      (setq powerline-default-separator nil)

      ;; change face based on evil state
      ;; TODO add meow state function
      ;; (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)

      ;; ensure the mode-line is re-compiled when switching themes
      (advice-add 'load-theme :after
                  (lambda (&rest args)
                    (spaceline-compile))))
#+END_SRC

** spaceline-all-the-icons
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package spaceline-all-the-icons
      :after (all-the-icons spaceline)
      :config
      <<spaceline-ati-config>>
      )
#+END_SRC

*** spaceline-ati-config
:PROPERTIES:
:header-args: :noweb-ref spaceline-ati-config :tangle no
:END:

By default =all-the-icons= returns an object without an =:inherit= property. You can pass a face to inherit from, but can't specify a bare =:inherit=. This has the issue where an icon has the wrong background color based on which section of the modeline it occupies. So we need a function that will both apply a bare =:inherit= property along with some default scaling values.
#+BEGIN_SRC emacs-lisp
  (defun ic/icon (name &optional group)
    (setf group (or group 'alltheicon))
    (let* ((icon (funcall (intern (format "all-the-icons-%s" group))
                          name))
           (family (plist-get (plist-get (text-properties-at 0 icon)
                                         'face)
                              :family))
           (face `(:family ,family :inherit)))
      (propertize icon 'face face 'font-lock-face face 'display '(raise 0.1))))
#+END_SRC

For the version control segment I would like the see the git icon along with the current file's status if we're in the master branch. If we're in a non-master branch I want to see the git branch icon along with the branch name and current file's status.
#+BEGIN_SRC emacs-lisp
  (defun ic//vc-icon-git ()
    (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
           ;; (project-name (second (nreverse (split-string (projectile-project-root) "/"))))
           (vc-state-icon (pcase (vc-state (buffer-file-name))
                            ('up-to-date "-")
                            ('edited "*")
                            ('added "^")
                            ('removed' "v")
                            ('conflict "!")
                            ('missing "m")
                            ('ignored "i")
                            ('unregistered "x")
                            (_ "?")))
           (branch-icon (if (string= branch "master")
                            (ic/icon "git")
                          (concat
                           (ic/icon "git-branch" 'octicon)
                           " "
                           branch))))
      (concat vc-state-icon " " branch-icon)))

  (spaceline-define-segment
      ic-vc-icon "A segment for the Version Control icon"
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode) (ic//vc-icon-git))
              (t (propertize (format "%s" vc-mode))))))
#+END_SRC

I want to see when our current =projectile= differs from the active =persp-mode= perspective. This shouldn't happen, but I am seeing it when first getting the two to work together.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-project-name "A segment for the active projectile project."
      (let ((project (projectile-project-name))
            (persp (safe-persp-name (get-frame-persp))))
        (if (equal project persp)
            project
          (concat project "|" persp))))
#+END_SRC

Sometimes I use an older Surface Pro 4 tablet. This has a nasty habit of screen flickering when it gets hot. It seems to be alievated when the screen refreshes. So I hack around it by ensuring the modeline displays alternating =,= and =.= every second. I then need a timer to force the modeline to update, causing emacs to do a screen repaint, "fixing" the screen flickering. Simply calling =(redisplay t)= is not sufficient it seems.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-tablet-fix "A segment to hack around the screen flickering on the Surface
      Pro 4."
      (let ((seconds (% (floor (time-to-seconds)) 2)))
        (if (= seconds 0) "☳" "☷")))

  (when on-tablet
    (setq ic//tablet-fix-timer (run-at-time nil 1 #'force-mode-line-update))
    ;; (cancel-timer ic//tablet-fix-timer)
    )
#+END_SRC

I want to try having some extra vertical space on the mode-line. Just setting the =:height= property on the =mode-line= face will scale all the text on the line as well, which isn't what I want. [[https://github.com/seagle0128/doom-modeline][doom-modeline]] handles this by making an image scaled to the desired size and displaying that in the mode line.

I made one change: to ignore if we running on graphics or not. I'm always in GUI emacs and the mode-line is set prior to the graphics system being initialized, so we need to generate the image even if we don't have =(display-graphic-p)=.
#+BEGIN_SRC emacs-lisp
  ;; taken from: https://github.com/seagle0128/doom-modeline/blob/master/doom-modeline-core.el
  (defun doom-modeline--create-bar-image (face width height)
    "Create the bar image.
  Use FACE1 for the bar, FACE2 for the background.
  WIDTH and HEIGHT are the image size in pixels."
    (when (and ;;(display-graphic-p)
               (image-type-available-p 'pbm))
      (propertize
       " " 'display
       (let ((color (or (face-background face nil t) "None")))
         (ignore-errors
           (create-image
            (concat (format "P1\n%i %i\n" width height)
                    (make-string (* width height) ?1)
                    "\n")
            'pbm t :foreground color :ascent 'center))))))
#+END_SRC

Set the mode line.
#+BEGIN_SRC emacs-lisp
  ;; bring in bundled segments
  (require 'spaceline-segments)

  ;; and define our custom mode-line
  (spaceline-compile
    'main
    ;; left side
    '((window-number
       :priority 100
       ;; :fallback evil-state
       :face highlight-face)
      ((buffer-modified
        all-the-icons-mode-icon
        remote-host)
       :priority 95)
      ((buffer-id)
       :priority 96)
      ((anzu
        selection-info)
       :priority 90)
      ((flycheck-error
        flycheck-warning
        flycheck-info)
       :priority 85)
      process)

    ;; right side
    '(((org-clock) :when active)
      ((ic-vc-icon)
       :priority 87)
      all-the-icons-git-status
      ;; XXX (projectile-root) is really slow outside a project
      ;; (projectile-root)
      ;; ((buffer-encoding-abbrev buffer-size
      ;;   input-method)
      ;;  :priority 5)
      (((ic-tablet-fix :when (and active on-tablet))
        buffer-position)
       :priority 91)))

  ;; and enable it
  (let ((spacing-image (doom-modeline--create-bar-image
                        'powerline-active1 1 30)))
    (setq-default mode-line-format `(,(concat spacing-image "%e")
                                     (:eval (spaceline-ml-main)))))

#+END_SRC

=mode-line-format= is buffer-local and there are some buffers that have set it prior to us generating the mode-line, so we need to reset their values:
#+BEGIN_SRC emacs-lisp
  (save-excursion
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (setq mode-line-format (default-toplevel-value 'mode-line-format)))))
#+END_SRC

** visual-fill-column
I want emacs to wrap long lines automatically and refill when modifying text. =visual-fill-column= does just that.
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :init (setq-default fill-column 80)
    :hook (visual-line-mode . visual-fill-column-mode))
#+END_SRC

** wgrep
=wgrep= is a package that let's us live edit a =helm-occur= buffer.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    ;; :init
    ;; (add-hook 'helm-occur-mode-hook #'wgrep-change-to-wgrep-mode)
    )
#+END_SRC

** winum
For numbering and jumping to windows.
#+BEGIN_SRC emacs-lisp
  (use-package winum
      :demand t
      :config
      ;; I want frames numbered only within a frame, not globally
      (setq winum-scope 'frame-local)
      ;; spaceline handles window numbers
      (setq winum-auto-setup-mode-line nil)
      (winum-mode)

      (defun ic/winum-delete-window-0-or-10 (&optional _arg)
        "Delete window 0 if assigned or 10 if exists."
        (interactive "P")
        (winum-select-window-0-or-10 '(4)))

      (defmacro defun-ic--winum-delete-window-num (n)
        "Create function for calling `winum-select-window-by-number'
  so that it kills window N."
        `(defun ,(intern (format "ic/winum-delete-window-%d" n)) (&optional _arg)
           ,(format "Delete window %d." n)
           (interactive "P")
           (winum-select-window-by-number ,(- n))))

      (defun-ic--winum-delete-window-num 1)
      (defun-ic--winum-delete-window-num 2)
      (defun-ic--winum-delete-window-num 3)
      (defun-ic--winum-delete-window-num 4)
      (defun-ic--winum-delete-window-num 5)
      (defun-ic--winum-delete-window-num 6)
      (defun-ic--winum-delete-window-num 7)
      (defun-ic--winum-delete-window-num 8)
      (defun-ic--winum-delete-window-num 9)

      :general
      (leader-keys
       "0" '(winum-select-window-0-or-10 :which-key ("0..9" . "winum-window 0..9"))
       "1" '(winum-select-window-1 :which-key t)
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t)
       "C-0" '(ic/winum-delete-window-0-or-10 :which-key ("C-0..9" . "ic/winum-delete-window 0..9"))
       "C-1" '(ic/winum-delete-window-1 :which-key t)
       "C-2" '(ic/winum-delete-window-2 :which-key t)
       "C-3" '(ic/winum-delete-window-3 :which-key t)
       "C-4" '(ic/winum-delete-window-4 :which-key t)
       "C-5" '(ic/winum-delete-window-5 :which-key t)
       "C-6" '(ic/winum-delete-window-6 :which-key t)
       "C-7" '(ic/winum-delete-window-7 :which-key t)
       "C-8" '(ic/winum-delete-window-8 :which-key t)
       "C-9" '(ic/winum-delete-window-9 :which-key t)
       )
      )
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :demand t
    )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :init
      (setq yas-snippet-dirs (list (concat user-data-directory "snippets")))
      (yas-global-mode 1))
#+END_SRC

* Modes
** info-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

** lisp-mode
Setup tab width.
#+BEGIN_SRC emacs-lisp
  (defun ic/lisp-mode-setup ()
    (setq indent-tabs-mode nil)
    (setq tab-width 8)
    (setq lisp-indent-function 'common-lisp-indent-function))

  (add-hook 'lisp-mode-hook #'ic/lisp-mode-setup)
#+END_SRC

Some useful functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/eval-outer-sexp-dwim ()
    "Evaluate the outermost sexp at POINT, stopping at any (def*) found."
    (interactive)
    (save-excursion
      (condition-case nil
          ;; move up as much as possible
          (while (not (looking-at "(def"))
            (up-list -1 t))
        (error nil))
      ;; are we on a left paren?
      (if (eq ?\( (following-char))
          (progn
            ;; move to the end
            (forward-sexp)
            ;; and evaluate
            (call-interactively 'eval-last-sexp))
        (message "Cannot evaluate: not inside an sexp"))))

  (defun ic/eval-enclosing-sexp ()
    "Evaluate the sexp enclosing POINT."
    (interactive)
    (save-excursion
      (condition-case nil
          (progn
            (up-list -1 t)
            (forward-sexp)
            (backward-char))
        (error
         (message "Cannot evaluate: not inside an sexp"))
        (:success
         (call-interactively 'eval-last-sexp)))))
#+END_SRC

Setup keybinds
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps 'emacs-lisp-mode-map
    "e" '(ic/eval-enclosing-sexp :which-key "ic/eval-enclosing-sexp")
    "E" 'ic/eval-outer-sexp-dwim
    "B" 'eval-buffer
    "M" 'emacs-lisp-macroexpand
    )
#+END_SRC

** prog-mode
#+BEGIN_SRC emacs-lisp
  (defun ic/prog-mode-setup ()
    (flyspell-prog-mode)
    (auto-fill-mode)
    (company-mode 1)
    (setq indent-tabs-mode nil)
    (setq tab-width 4))
  (add-hook 'prog-mode-hook #'ic/prog-mode-setup)
#+END_SRC

** python-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'python))

  (defun ic/python-mode-setup ()
    (setq python-indent-offset tab-width)
    (lsp))

  (add-hook 'python-mode-hook #'ic/python-mode-setup)
#+END_SRC

** text-mode
Let's have automatic spell checking for text heavy buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

** winner-mode
I like being able to undo/redo window changes.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

* Misc
** Misc cruft
Turn off some default emacs settings I don't like, such as the menu bar, scroll
bar, etc.

#+BEGIN_SRC emacs-lisp
  ;; disable unwanted UI elements
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  ;; static cursor
  (blink-cursor-mode -1)

  ;; don't show the initial emacs screen
  (setq inhibit-startup-screen t)
  ;; start in the *Messages* buffer
  (setq initial-buffer-choice (lambda () (get-buffer "*Messages*")))
  ;; let me use y/n in prompts
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** Encoding
I do most of my work in =UTF-8= with =unix= line endings, so set that as the default coding system. Emacs seems to still Do The Right Thing on windows with this set. When it's not set =tramp= from windows into a linux system does not work properly.
#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8-unix)
#+END_SRC
** Ediff
#+BEGIN_SRC emacs-lisp
  ;; don't open ediff controls in a new frame
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; use a more comfortable window split
  (setq ediff-split-window-function 'split-window-horizontally)

  ;; restore old window configuration on exit
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** user-emacs-directory
Try and keep the =user-emacs-directory= somewhat clean.
#+BEGIN_SRC emacs-lisp
  ;; cache/ directory
  (setq recentf-save-file (concat user-cache-directory "recentf"))
  (setq eshell-history-file-name (concat user-cache-directory "eshell-history"))
  (setq savehist-file (concat user-cache-directory "savehist-history"))
  (setq request-storage-directory (concat user-cache-directory "request"))
  (setq transient-history-file (concat user-cache-directory "transient-history.el"))
  (setq transient-values-file (concat user-cache-directory "transient-values.el"))
  (setq transient-levels-file (concat user-cache-directory "transient-levels.el"))
  (setq bookmark-default-file (concat user-cache-directory "bookmarks"))
  (setq tramp-persistency-file-name (concat user-cache-directory "tramp"))

  ;; cache/{backups,auto-saves}
  (let ((backup-dir (concat user-cache-directory "backups/"))
        (autosave-dir (concat user-cache-directory "auto-saves/")))
    ;; create directories if needed
    (dolist (path (list backup-dir autosave-dir))
      (unless (file-directory-p path)
        (make-directory path t)))
    (setq backup-directory-alist `((".*" . ,backup-dir)))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq auto-save-list-file-prefix (concat autosave-dir "saves-"))
    (setq tramp-backup-directory-alist `((".*" . ,backup-dir)))
    (setq tramp-auto-save-directory autosave-dir))

  ;; data/ directory
  (setq abbrev-file-name (concat user-data-directory "abbrev"))
#+END_SRC

** Buffers
Some useful buffer related functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/yank-buffer-to-clipboard ()
    "Yank contents of current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun ic/paste-clipboard-to-buffer ()
    "Overwrite the current buffer with the clipboard contents."
    (interactive)
    (when (yes-or-no-p "Overwrite current buffer with clipboard?")
      (widen)
      (erase-buffer)
      (clipboard-yank)))

  (defun ic/yank-current-filename ()
    "Yank the full filename of the currently active buffer. Return
  `nil' if no underlying file."
    (interactive)
    (let ((filename (or (buffer-file-name) "nil")))
      (kill-new filename)
      (message filename)))

  (defun ic/switch-to-scratch-buffer ()
    "Switch to the `*scratch*' buffer."
    (interactive)
    (switch-to-buffer (startup--get-buffer-create-scratch)))

  (defun ic/check-buffer-visiting (file-name)
    "Return the first active buffer visiting FILE-NAME, NIL if not such buffer
  exists."
    (when file-name
      (let ((expanded-file-name (expand-file-name file-name)))
        (car (seq-filter
              (lambda (b)
                (when-let ((buf-file (buffer-file-name b)))
                  (equal expanded-file-name
                         (expand-file-name buf-file))))
              (buffer-list))))))
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("org" (or
                   (mode . org-mode)
                   (name . "^\\*Org Src")))
           ("tramp" (name . "^\\*tramp.*"))
           ("magit" (or
                     (mode . magit-mode)
                     (mode . magit-diff-mode)
                     (mode . magit-process-mode)
                     (name . "^magit.*")))
           ("emacs" (or
                     (name . "^\\*scratch\\*$")
                     (name . "^\\*Messages\\*$")
                     (name . "^\\*Shell Command Output\\*$")
                     ))
           ("ediff" (or
                     (name . "^\\*ediff.*")
                     (name . "^\\*Ediff.*")
                     )
            )
           ("dired" (mode . dired-mode))
           ("terminal" (or
                         (mode . term-mode)
                         (mode . shell-mode)
                         (mode . eshell-mode)
                         ))
           ("help" (or
                    (name . "^\\*Help\\*$")
                    (name . "^\\*info\\*$")
                    ))
           )))

  ;; use our custom groupings by default
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  ;; don't show empty groups
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

** Files
Some useful file related functions.

First, some shortcuts to my configuration files.
#+BEGIN_SRC emacs-lisp
  (defun ic/edit-init-file ()
    "Open the `init. l' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))

  (defun ic/edit-early-init-file ()
    "Open the `early-init.el' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "early-init.el")))

  (defun ic/edit-org-config-file ()
    "Open the `README.org' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "README.org")))
#+END_SRC

Some functions to manipulate underlying files.
#+BEGIN_SRC emacs-lisp
  (defun ic/delete-current-buffer-file ()
    "Delete the currently visited file."
    (interactive)
    (if-let (filename (buffer-file-name))
        (when (yes-or-no-p (format "Delete file %S? " filename))
          (delete-file filename)
          (kill-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache filename))
          (message (format "Deleted file %S." filename)))))


  (defun ic/rename-current-buffer-file ()
    "Rename the currently visited file."
    (interactive)
    (if-let (cur-filename (buffer-file-name))
        (let ((new-filename (read-file-name
                             (format "Rename %S to: "
                                     (file-name-nondirectory cur-filename))))
              (cur-buffer (buffer-name)))
          (rename-file cur-filename new-filename)
          (find-file new-filename)
          (kill-buffer cur-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache cur-filename)
            (call-interactively 'projectile-cache-current-file))
          (message (format "Renamed %S to %S." cur-filename new-filename)))))
#+END_SRC

** display-buffer configuration
#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
          ;; display help windows on the right
          ("^\\*\\(Help\\|info\\)"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . right)
           (slot . 1)
           (window-width . 80)
           (reusable-frames . nil))

          ;; display compile errors on the bottom
          ("^\\*\\(Compile\\|Backtrace\\)"
           (display-buffer-reuse-window display-buffer-at-bottom)
           (window-width . 0.5)
           (window-height . 15)
           (reusable-frames . nil))

          ;; display magit windows on the left
          ("^magit:"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . left)
           (slot . 1)
           (window-width . 80)
           (window-height . 1.0)
           (reusable-frames . nil))
          ))
#+END_SRC

** Secrets
I keep certain information out of source control: email addresses, account information, etc. I have a small python program called =secret= that I use to retrieve these secrets, let's expose that to emacs.

#+BEGIN_SRC emacs-lisp
  (defvar ic/secret-cmd "secret")

  (defun ic/get-secret (secret)
    "Retrieve `secret' using the `ic/secret-cmd' program."
    (nth 0 (process-lines ic/secret-cmd secret)))
#+END_SRC

** Customize
I don't like =customize= so discard all settings.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat (temporary-file-directory) "emacs-customize-settings"))
#+END_SRC

** Tab Width
Use 4 spaces by default for tabs. Note: these are commonly overwritten in mode hooks.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].

#+BEGIN_SRC emacs-lisp
  (defun ic/save-and-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (save-buffer)
    (ic/kill-buffer-and-window))

  (defun ic/maybe-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (save-buffers-kill-emacs)))

  (defun ic/kill-buffer-and-window ()
    "Destroy the current buffer and window, if it was the sole window also delete
  the frame."
    (interactive)
    (condition-case-unless-debug nil
        (kill-buffer-and-window)
      (error
       (spacemacs/frame-killer))))

  ;; from spacemacs
  (defun spacemacs/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error
       (make-frame-invisible nil 1))))
#+END_SRC

And some =leader-key= bindings:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "q"
   "" '(nil :which-key "quit")
   "q" 'spacemacs/frame-killer
   "Q" 'ic/maybe-kill-emacs)
#+END_SRC

** Frame title
Set the frame title to something meaningful.

#+BEGIN_SRC emacs-lisp
  (defun ic/short-persp-name ()
    "Return a shortened name for currently active perspective. Returns `nil'
  when `persp-mode' not enabled."
    ;; we guard calls to `get-frame-persp' and `safe-persp-name' behind a
    ;; check for `\'persp-mode' so shutup the compiler about unknown functions.
    (eval-when-compile
      (unless (fboundp 'get-frame-persp)
        (defun get-frame-persp ()))
      (unless (fboundp 'safe-persp-name)
        (defun safe-persp-name (_))))
    (when (and (boundp 'persp-mode) (get-frame-persp))
      (let ((name (safe-persp-name (get-frame-persp))))
        (concat " <"
                (if (file-directory-p name)
                    (file-name-nondirectory (directory-file-name name))
                  name)
                "> "))))

  (setq frame-title-format
        '((:eval (buffer-name (window-buffer (minibuffer-selected-window))))
          (:eval (ic/short-persp-name))))
#+END_SRC

** Spelling
When typing in insert mode I want to hit =C-e= to automatically correct the previous misspelled word.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   "C-e" #'flyspell-auto-correct-previous-word)
#+END_SRC

** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of the re-display code so can run only when needed. Lisp implementations such as =linum= and =nlinum= have to run over an entire window as they can't know which part of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain text-heavy modes.
#+BEGIN_SRC emacs-lisp
  (global-linum-mode -1)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp
  ;; use lines displayed on screen rather than new line characters; so folds work
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 3 ...
  (setq-default display-line-numbers-width 3)
  ;; ... and allow it to shrink :(
  (setq-default display-line-numbers-grow-only nil)
#+END_SRC

I would really like to set =display-line-numbers-grow-only= to =t= so that it only grows and prevents shrinkage, but it seems there is a significant performance cost associated with it. I've increased the default width slightly to offset it, but that will waste a bit more space on small files.

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like =linum-mode=, instead it uses the =text-area= where the main buffer text is. This means that anything in the fringe (=display-margin=) now shows up to the left of the line numbers. I'm not a fan of that, but I guess I'll live with it as there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of =display-line-numbers= for more info.

** Web Browser
=firefox=, duh.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program
        (cond
         (on-windows
          "c:/Program Files/Mozilla Firefox/firefox.exe")
         (on-old-imac
          "/Applications/Firefox.app/Contents/MacOS/firefox")
         (t
          "firefox")))
#+END_SRC

** Minibuffer / completion testing (disabled)
:PROPERTIES:
:header-args: :tangle no
:END:

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (defun ic/ignore-marginalia-annotate-binding (&_))
    (advice-add 'marginalia-annotate-binding :override 'ic/ignore-marginalia-annotate-binding)
    (marginalia-mode 1)
    )

#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    ;; (add-to-list 'display-buffer-alist
    ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
    ;;                nil
    ;;                (window-parameters (mode-line-format . none))))

    (add-hook 'embark-post-action-hook #'embark-collect--update-linked)
    ;; (remove-hook 'embark-post-action-hook #'embark-collect--update-linked)

    (add-hook 'minibuffer-setup-hook #'embark-collect-completions)
    ;; (remove-hook 'minibuffer-setup-hook #'embark-collect-completions)

    (defun ic/embark-act-noexit ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'embark-act)))

    :general
    (leader-keys
      "hdb" 'embark-bindings)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-," 'embark-act
     "C-<" 'ic/embark-act-noexit
     "C-." 'embark-become)
    )

#+END_SRC

*** Minibuffer
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'minibuffer-local-map
   "C-w" 'backward-kill-word)

#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :config
    ;; use TAB for previewing
    (setq consult-preview-key (kbd "<tab>"))
    (setq consult-narrow-key "<")

    (defun ic/consult-unfocus-lines ()
      "Reset any current focus from `consult-focus-lines'."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-focus-lines)))

    :general
    (leader-keys
      "bb" 'consult-buffer
      "fb" 'consult-bookmark
      "pi" 'consult-project-imenu
      "ha" 'consult-apropos
      "sf" 'consult-find
      "sL" 'consult-locate
      "sg" 'consult-grep
      "sG" 'consult-git-grep
      "sm" 'consult-multi-occur
      "sr" 'consult-ripgrep
      "su" 'consult-focus-lines
      "sU" 'ic/consult-unfocus-lines
      )

    (general-define-key
     "go" 'consult-outline
     "gh" 'consult-org-heading
     "gi" 'consult-imenu
     "gl" 'consult-line
     )

    )

#+END_SRC

*** Selectrum (not used)
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand nil
    :after (orderless embark)
    :config
    (selectrum-mode 1)

    ;; window should be exactly 20 lines always
    (setq selectrum-max-window-height 20)
    (setq selectrum-fix-vertical-window-height selectrum-max-window-height)

    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (setq selectrum-refine-candidates-function #'orderless-filter)

    ;; when we have an embark collect: only show the current selectrum item
    (defun ic/single-line-selectrum ()
      (when (eq embark-collect--kind :live)
        (with-selected-window (active-minibuffer-window)
          (setq-local selectrum-num-candidates-displayed 1)
          (setq-local selectrum-display-style
                      '(horizontal :before-candidates "[" :after-candidates "]"
                                   :more-candidates "" :candidates-separator "")))))
    (add-hook 'embark-collect-mode-hook #'ic/single-line-selectrum)

    ;; selectrum should have a decoration-less window on the bottom
    (setq selectrum-display-action '(display-buffer-in-side-window
                                     (side . bottom)
                                     (slot . -1)
                                     (window-parameters (mode-line-format . none))))
    )
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t
    :demand t
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :config
    (defun ic/orderless-bang-prefix (pattern _index _total)
      (when (string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))

    (defun ic/orderless-bang-suffix (pattern _index _total)
      (when (string-suffix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 0 -1))))

    (defun ic/orderless-carrot-suffix (pattern _index _total)
      (when (string-suffix-p "^" pattern)
        `(orderless-regexp . ,(concat "^" (substring pattern 0 -1)))))

    (setq completion-styles '(orderless))
    (setq orderless-matching-styles '(orderless-regexp))
    (setq orderless-style-dispatchers '(ic/orderless-bang-prefix
                                        ic/orderless-bang-suffix
                                        ic/orderless-carrot-suffix))
    )
#+END_SRC

** Second completion testing

*** Selectrum
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :init
    ;; always show a certain amount of candidates
    (setq selectrum-max-window-height 15)
    (setq selectrum-fix-vertical-window-height t)
    ;; selection face should extend to the screen edge
    (setq selectrum-extend-current-candidate-highlight t)
  
    :config
    (selectrum-mode 1)
  
    :general
    (leader-keys
      "R" 'selectrum-repeat))
#+END_SRC

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode 1))
#+END_SRC

*** Orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless))
    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)

    :config
    ;; persist history
    (savehist-mode)
    )
#+END_SRC

*** Prescient
#+BEGIN_SRC emacs-lisp
  (use-package selectrum-prescient
    :demand t
    :init
    (setq selectrum-prescient-enable-filtering nil)
    (setq prescient-save-file (concat user-cache-directory "prescient-save.el"))
    :config
    (selectrum-prescient-mode 1)
    (prescient-persist-mode 1))
#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t
    :config
    ;; always use completing-read for selecting actions, rather than keybinds
    (setq embark-prompter 'embark-completing-read-prompter)
    ;; setup initial action keybind
    (meow-normal-define-key
     '("C-." . embark-act))
  
    :bind (:map minibuffer-local-map
           ("C-." . embark-act)))
#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :config
    (defun consult-outline-or-org-heading (&optional match scope)
      "Call `consult-org-heading' when in an `org-mode' buffer, otherwise call
    `consult-outline'."
      (interactive)
      (if (eq major-mode 'org-mode)
          (consult-org-heading match scope)
        (consult-outline)))

    (defun ic-consult-bookmark ()
      "Call `consult-bookmark' without automatic buffer preview.
  This is to prevent possible `tramp' calls."
      (interactive)
      (let ((consult-preview-key 'nil))
        (call-interactively #'consult-bookmark)))
    )
#+END_SRC

*** consult-lsp
#+BEGIN_SRC emacs-lisp
  (use-package consult-lsp
    :bind (:map lsp-mode-map
           ([remap consult-imenu-multi] . #'consult-lsp-symbols)
           :map lsp-command-map
           ("GD" . #'consult-lsp-diagnostics)))
#+END_SRC

** Movement
Some misc functions to support moving around.

#+BEGIN_SRC emacs-lisp
  (defun ic/move-to-outline-dwim ()
    "Prompt for, and move to, an outline heading."
    (interactive)
    (cond ((eq major-mode 'org-mode)
           (ic/org-jump-in-buffer))
          (t
           (message (format "No outline command found for mode `%s'" major-mode)))))
#+END_SRC

** Garbage Collection
I have problems typing in =org-mode= documents with the default garbage collector settings. So let's give the GC 100mb to work with and call it when emacs is idle.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 (expt 2 20)))
  (setq gc-cons-percentage 0.5)
  (run-with-idle-timer 5 t #'garbage-collect)
  (setq garbage-collection-messages nil)
#+END_SRC

** Shell replace
I'd like a way to call =shell-command-on-region= and have it replace the current region without using a prefix arg.

#+BEGIN_SRC emacs-lisp
  (defun ic/shell-command-on-region-replace ()
    "Call `shell-command-on-region' with prefix arg set."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'shell-command-on-region)))
#+END_SRC

** Windows fixes
For some reason on windows emacs doesn't associate =FontAwesome= code points with the font, so specifiy that manually. Taken from [[https://www.reddit.com/r/emacs/comments/34ttb8/get_fontawesome_to_display_correctly_under_windows/?][here]].

Note: =f2b4= was chosen as the ending codepoint by inspecting =data-faicons.el= from =all-the-icons= package. This might change on updates.
#+BEGIN_SRC emacs-lisp
  (when on-windows
    (set-fontset-font "fontset-default" '(#xf000 . #xf2b4) "FontAwesome"))
#+END_SRC

When I'm on =Chetwood= I'm running inside =MSYS2= which has a =/dev/null= device, so use that over the windows =NUL= device. This helps when remoting into a linux machine.
#+BEGIN_SRC emacs-lisp
  (when on-home-windows-desktop
    (setq null-device "/dev/null"))
#+END_SRC

** Mac Fixes
For some (stupid) reason =/usr/local/bin= isn't included in the =PATH= on mac. I've ensured it's loaded in =~/.bashrc=, =~/.bash_profile= and =~/.profile=. I've also added it under =/etc/paths.d/= as well as ensured it's part of =/etc/paths=. I've checked permissions (I can run programs from it) and since I know it's added correctly in a shell (with code I've been using for a decade now) let's just add it manually for emacs. Ugh
#+BEGIN_SRC emacs-lisp
  (when on-old-imac
    (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    (add-to-list 'exec-path "/usr/local/bin"))
#+END_SRC

Ensure =emacs= takes up as much of the screen as possible when maximizing.
#+BEGIN_SRC emacs-lisp
  (when on-mac
    (setq frame-resize-pixelwise t))
#+END_SRC

When we're on a mac and we have GNU =ls= installed (=gls=): use that as our =dired= listing program. Both because it supports  the =--dired= flag, but we can also get some marginally better collating from the GNU version.
#+BEGIN_SRC emacs-lisp
  (when (and on-mac
             (executable-find "gls"))
    (setq insert-directory-program "gls")
    (setq dired-listing-switches "-alU"))
#+END_SRC

** Start maximized
I want every frame to start maximized by default.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

** Zetian
My personal 2nd brain implemented in =org-roam=.

*** Capture Templates
=org-roam= defines its own syntax for capture templates separate from =org-mode= so we'll define them here.
#+BEGIN_SRC emacs-lisp
  (defun zetian--capture-target (file title)
    `(file+head ,file ,title))

  (defun zetian--capture-target-default (&optional cat file-name title)
    (let ((default-file "%<%Y%m%d%H%M%S>-${slug}.org")
          (default-title (concat "#+filetags: review\n"
                                 "#+title: ${title}"))
          (cat-s (format ":PROPERTIES:\n:CATEGORY: %s\n:END:\n" cat)))
      (zetian--capture-target
       (or file-name default-file)
       (concat (when cat cat-s)
               (or title default-title)))))

  (defun zetian--capture-node (cat &optional todo)
    (concat "* " (when todo (concat todo " ")) "${title}\n"
            ":PROPERTIES:\n"
            ":ID: %(org-id-new)\n"
            ":CATEGORY: " cat " \n"
            ":END:\n"
            "%U"))

  (let ((tasks-file "zetian-tasks.org")
        (tasks-title (concat "#+title: All My Tasks\n"
                             "#+category: task\n"
                             "#+filetags: "
                             ":%(if at-home \"HOME\" \"WORK\"):agenda:\n"
                             "#+startup: content"))
        (person-file "zetian-people.org")
        (person-title (concat "#+title: All My Contacts\n"
                              "#+category: person\n"
                              "#+filetags: "
                              ":%(if at-home \"HOME\" \"WORK\"):agenda:\n"
                              "#+startup: content")))
    (setq org-roam-capture-templates
          `(
            ;; permanent note
            ("p" "permanent note" plain "%U\n\n%?"
             :target ,(zetian--capture-target-default "perm")
             :unnarrowed t)
          
            ;; task note
            ("t" "task" entry
             ,(concat (zetian--capture-node "task" "TODO")
                      "\n\n%?")
             :target ,(zetian--capture-target tasks-file tasks-title)
             :unnarrowed nil
             :empty-lines-before 1)
          
            ;; event note
            ("e" "event" entry
             ,(concat (zetian--capture-node "event" "TODO")
                      "\n\n%?")
             :target ,(zetian--capture-target tasks-file tasks-title)
             :unnarrowed nil
             :empty-lines-before 1)
          
            ;; lit note
            ("l" "literature note" plain
             ,(concat "%U\n\n%?\n\n"
                      "#+begin_quote\n%i#+end_quote\n"
                      "/Quote from %(zetian-link)/")
             :target ,(zetian--capture-target-default "lit")
             :unnarrowed t)
          
            ;; person note
            ("P" "person" entry
             ,(concat (zetian--capture-node "person")
                      "\n\n"
                      "- organization ::\n"
                      "- birthday ::\n"
                      "FIXME %\\%(org-anniversary yyyy mm dd) "
                      "${title}'s %d%s birthday\n"
                      "- phone ::\n"
                      "- address ::"
                      "\n\n%?")
             :target ,(zetian--capture-target person-file person-title)
             :unnarrowed nil
             :empty-lines-before 1)
          
            ;; movie note
            ("M" "movie" plain "%U\n\n%?"
             :target ,(zetian--capture-target-default "movie")
             :unnarrowed t)
          
            ;; TODO author note
            ;; TODO idea note
            )))

  ;; don't need these anymore
  (fmakunbound #'zetian--capture-node)
  (fmakunbound #'zetian--capture-target)
  (fmakunbound #'zetian--capture-target-default)
#+END_SRC

These templates are used from =org-capture-protocol=.
#+BEGIN_SRC emacs-lisp
  (setq org-roam-capture-ref-templates
        `(("W" "web zettel (org-capture)" plain
           ,(concat "%U\n\n"
                    "#+begin_quote\n%:initial\n#+end_quote\n"
                    "/From the webpage [[%:link][${title}]]/\n\n%?"
                    )
           :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org)"
                              ":PROPERTIES:\n\n#+title: ${title}\n#+filetags: :lit:web:")
           :unnarrowed t
           :immediate-finish t)))

#+END_SRC

*** Opening notes
When I call =org-roam-node-find= and the node is an =org-mode= element rather than a file. I want my view narrowed to that specific element.
#+BEGIN_SRC emacs-lisp
  (defun zetian-node-find (&optional node)
    "Act like `org-roam-node-find', but create a narrowed indirect buffer when
    visiting an element (as opposed to a file)."
    (interactive)
    (when-let (node (or node (zetian-search nil t "Find or create note")))
      (if-let ((guid (org-roam-node-id node))
               (title (org-roam-node-title node))
               (buf-name (format "zetian: %s" title)))
          (let ((buf (get-buffer buf-name))
                (loc (org-id-find guid)))
            (cond ((buffer-live-p buf)
                   (pop-to-buffer-same-window buf))
                  (loc
                   (bury-buffer)
                   (pop-to-buffer-same-window
                    (make-indirect-buffer (find-file (car loc)) buf-name t))
                   (widen)
                   (goto-char (cdr loc))
                   (when (org-at-heading-p)
                     (org-narrow-to-subtree)))
                  (t
                   (find-file (org-roam-node-file node))
                   (rename-buffer buf-name))))
        (error "could not lookup zetian node: %s" (org-id-find (org-roam-node-id node))))))
#+END_SRC

*** Saved searches
I do some common queries against =Zetian= so save them here.
#+BEGIN_SRC emacs-lisp
  (defconst zetian--open-state
    '(or (todo "TODO")
         (todo "NEXT"))
    "Zetian sub-query for an \"open\" item.")

  (defun zetian-find-book ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find '(category "book")
                        "books"))

  (defun zetian-find-author ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find '(category "author")
                        "authors"))

  (defun zetian-find-task ()
    "Search zetian for a task and navigate to buffer."
    (interactive)
    (zetian-search-find '(category "task")
                        "tasks"))

  (defun zetian-find-task-next ()
    "Search zetian for a task and navigate to buffer."
    (interactive)
    (zetian-search-find '(and (category "task")
                              (todo "NEXT"))
                        "next tasks"))

  (defun zetian-find-task-open ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find `(and (category "task")
                              ,zetian--open-state)
                        "open tasks"))

  (defun zetian--sub-search (name query query-name)
    "Return NAME if non-nil, otherwise call `(zetian-search QUERY nil NAME)' and
  if non-nil return the title."
    (if name
        name
      (if-let ((node (zetian-search query nil query-name)))
          (org-roam-node-title node))))

  (defun zetian-find-task-next-project (&optional project-name)
    "Find all NEXT tasks that link to PROJECT-NAME. Prompt user if NIL."
    (interactive)
    (if-let ((project (zetian--sub-search project-name
                                          '(category "project")
                                          "projects")))
        (zetian-search-find
         `(and (category "task")
               (todo "NEXT")
               (links-to ,project))
         (format "NEXT tasks that link to %S" project))))

  (defun zetian-find-task-open-project (&optional project-name)
    "Find all open tasks that link to PROJECT-NAME. Prompt user if NIL."
    (interactive)
    (if-let ((project (zetian--sub-search project-name
                                          '(category "project")
                                          "projects")))
        (zetian-search-find
         `(and (category "task")
               ,zetian--open-state
               (links-to ,project))
         (format "open tasks that link to %S" project))))

  (defun zetian-find-task-open-link (&optional node-name)
    "Find all open tasks that link to NODE-NAME. Prompt user if NIL."
    (interactive)
    (if-let ((title (zetian--sub-search node-name
                                        nil
                                        "linked note")))
        (zetian-search-find
         `(and (category "task")
               ,zetian--open-state
               (links-to ,title))
         (format "open tasks that link to %S" title))))

  (defun zetian-find-task-open-orphaned ()
    "Find all open tasks that are not linked to any project."
    (interactive)
    (let ((no-project
           `(not ,(append '(or)
                          (mapcar
                           (lambda (node)
                             `(links-to ,(org-roam-node-title node)))
                           (zetian-query '(category "project")))))))
      (zetian-search-find `(and (category "task")
                                ,zetian--open-state
                                ,no-project)
                          "orphaned tasks")))

  (defun zetian-find-link-to (&optional node-name)
    "Search zetian for nodes that link to NODE-NAME, prompt for name if NIL."
    (interactive)
    (if-let ((title (zetian--sub-search node-name nil "linked note")))
        (zetian-search-find `(links-to ,title)
                            (format "nodes that link to %S" title))))

  (defun zetian-find-link-from (&optional node-name)
    "Search zetian for nodes that NODE-NAME links to, prompt for name if NIL."
    (interactive)
    (if-let ((node (zetian--sub-search node-name nil "linked note")))
        (zetian-search-find `(links-from ,node)
                            (format "nodes that %S links to" node))))

  (defun zetian-find-open-event ()
    "Search zetian for open events"
    (interactive)
    (zetian-search-find `(and (category "event")
                              ,zetian--open-state)
                        "open events"))

  (defun zetian-find-project ()
    "Search zetian for projects"
    (interactive)
    (zetian-search-find '(category "project")
                        "project"))

  (defun zetian-stuck-projects ()
    "Return a list of stuck projects as zetian nodes."
    (seq-filter
     (lambda (project)
       (let ((title (org-roam-node-title project)))
         (not (zetian-query `(and (category "task")
                                  (todo "NEXT")
                                  (links-to ,title))))))
     (zetian-query '(and (category "project")
                         (not (tag "never-stuck"))))))

  (defun zetian-find-stuck-projects ()
    "Search zetian for any stuck project."
    (interactive)
    (let ((projects (zetian-stuck-projects)))
      ;; we already found the search results, so override `zetian-query'.
      (cl-letf (((symbol-function 'zetian-query)
                 (lambda (&rest args) projects)))
        (zetian-search-find nil "stuck project"))))

  (defun zetian-find-strange ()
    "Find any \"strange\" zetian notes. Strange could be unknown categories or
    weird tags."
    (interactive)
    (let* ((cats '("task" "event" "book" "author" "project" "perm" "lit"
                   "book" "web" "recipe" "video" "idea"))
           (good-cat (append '(or)
                             (mapcar
                              (lambda (c) `(category ,c))
                              cats))))
      (zetian-search-find `(not ,good-cat))))

  (defun zetian-find-state ()
    "Prompt for state and find all nodes matching it."
    (interactive)
    (let ((state (completing-read "State: "
                                  (zetian-all-states))))
      (zetian-search-find `(tag ,state)
                          (format "notes with state: %s" state))))

  (defun zetian-find-category ()
    "Prompt for category and find all nodes matching it."
    (interactive)
    (let ((cat (completing-read "Category: "
                                (zetian-all-categories))))
      (zetian-search-find `(category ,cat)
                          (format "notes with category: %s" cat))))

  (defun zetian-find-review ()
    "Find all notes that need review."
    (interactive)
    (zetian-search-find '(tag "review")
                        "notes needing review"))
#+END_SRC

*** Inserting Links
#+BEGIN_SRC emacs-lisp
  (defconst zetian-new-note-template-key "p"
    "Template key used when creating a new note from elisp.")

  (defun zetian-node-link (node)
    "Return an `org-mode' link to NODE as a string."
    (org-make-link-string (concat "id:" (org-roam-node-id node))
                          (org-roam-node-title node)))

  (defun zetian-link (&optional immediate)
    "Query Zetian for a node and return an `org-mode' link as a string, creating
  the node if IMMEDIATE is non-nil."
    (interactive)
    (when-let ((node (zetian-search nil immediate
                                    (concat "node to link"
                                            (when immediate
                                              " (create if needed)")))))
        (zetian-node-link node)))

  (defun zetian-link-immediate ()
    "Query Zetian for a node and return an `org-mode' link as a string, creating
  the node if needed."
    (interactive)
    (zetian-link t))

  (defun zetian-link-insert ()
    "Query Zetian for a node and insert a link at point."
    (interactive)
    (insert (zetian-link)))

  (defun zetian-link-insert-immediate ()
    "Query Zetian for a node and insert a link at point, creating the node if
    needed."
    (interactive)
    (insert (zetian-link-immediate)))

  (defun zetian-node-create (&optional title template-key)
    "Return zetian node for TITLE, creating it if necessary. Uses TEMPLATE-KEY to
  lookup template from `org-roam-capture-templates', when NIL use
    `zetian-new-note-template-key'."
    (if title
        (if-let (node (org-roam-node-from-title-or-alias title))
            ;; we have a title and an existing node
            node
          ;; we have a title, but the node needs to be created
          (let ((template (append
                           (assoc (or template-key zetian-new-note-template-key)
                                  org-roam-capture-templates)
                           '(:immediate-finish t))))
            (when (org-roam-capture-
                   :node (org-roam-node-create :title title)
                   :templates (list template))
              (org-roam-node-from-title-or-alias title))))
      ;; we don't have a title, so prompt for one and retry
      (zetian-node-create (org-roam-node-title
                           (zetian-search nil "Zetian note: "))
                          template-key)))
#+END_SRC

*** Set Category / State
I need an easy way to set either the file category or a node's category.

#+BEGIN_SRC emacs-lisp
  (defun zetian-set-category (&optional category)
    "Set the category of the node at point. If it's on a file, set the #+category:
    property, otherwise use the property drawer."
    (interactive)
    (let ((node (org-roam-node-at-point 'assert))
          (cat (or category (completing-read "Category: " nil))))
      (save-excursion
        (org-set-property "CATEGORY" cat))))
#+END_SRC

I use =org-mode= tags for state and =org-roam= provides a pair of functions that work with both file tags and element tags, so let's use those.
#+BEGIN_SRC emacs-lisp
  (defalias #'zetian-add-state #'org-roam-tag-add
    "Add a state to a zetian node.")

  (defalias #'zetian-remove-state #'org-roam-tag-remove
    "Remove a state from a zetian node.")
#+END_SRC

*** Update Agenda Files
Ensure that =org-agenda= can find the relevant notes.
#+BEGIN_SRC emacs-lisp
  (defun zetian-refresh-agenda-list ()
    (interactive)
    (mapc (lambda (node)
            (add-to-list 'org-agenda-files
                         (org-roam-node-file node)))
          (zetian-query '(tag "agenda"))))

  (defun zetian--update-agenda-files-on-load ()
    "Call `zetian-refresh-agenda-list' from `after-init-hook'."
    (remove-hook 'after-init-hook #'zetian--update-agenda-files-on-load)
    (zetian-refresh-agenda-list))
  (add-hook 'after-init-hook #'zetian--update-agenda-files-on-load)
#+END_SRC

*** Searching
I want a way to search through =zetian= in a fast, easy, and general manor.
#+BEGIN_SRC emacs-lisp
  (defvar zetian--readline-histories nil
    "An ALIST of histories to use with `completing-read'.")

  (defun zetian-search-find (&optional query prompt create)
    "Search zetian for QUERY and navigate to chosen buffer. When CREATE is
  non-nil allow user to create a new node."
    (interactive)
    (when-let ((node (zetian-search query create prompt)))
      (zetian-node-find node)))

  (defun ic/org-roam-node-body (node)
    "Return the text contents of NODE"
    (save-excursion
      (with-temp-buffer
        (insert-file-contents-literally (org-roam-node-file node))
        (when (< 0 (org-roam-node-level node))
          (org-mode)
          (widen)
          (goto-char (org-roam-node-point node))
          (org-narrow-to-subtree))
        (buffer-string))))

  (defun zetian-query (&optional query)
    "Run QUERY against `org-roam' database."
    (if (eq query nil)
        ;; when query is nil don't call into the db
        (org-roam-node-list)
      (mapcar
       (lambda (id)
         ;; XXX should this be a bulk operation?
         (org-roam-populate (org-roam-node-create :id (car id))))
       (org-roam-db-query
        (zetian--unroll-query query)))))

  (defun zetian-query-1 (query)
    "Run QUERY against zetian and return the first result. Signal an error when
    receiving zero or more than one result."
    (let* ((results (zetian-query query))
           (count (length results)))
      (if (not (= count 1))
          (error "zetian-query-1 received %s results from: %S"
                 count query)
        (car results))))

  (defun zetian--unroll-query (query)
    "Translate QUERY into a suitable `emacsql' query."
    `[:select [nodes:id]
      :from nodes
      :where ,(zetian--unroll-query-impl query)])

  (defun zetian--unroll-query-impl (query)
    (unless (and (listp query) query)
      (error "QUERY must be an sexp, received: %S" query))
    (pcase (car query)
      ('and
       (cons 'and (mapcar #'zetian--unroll-query-impl (cdr query))))
      ('or
       (cons 'or (mapcar #'zetian--unroll-query-impl (cdr query))))
      ('not
       (list 'not (zetian--unroll-query-impl (cadr query))))
      ('tag
       `(in nodes:id [:select [tags:node-id]
                      :from tags
                      :where (= tags:node-id nodes:id)
                      :and (= tags:tag ,(cadr query))]))
      ('title
       `(like title ,(zetian--query-quote-like (cadr query) t)))
      ('title-like
       `(like title ,(zetian--query-quote-like (cadr query))))
      ('todo
       `(like todo ,(zetian--query-quote-like (cadr query))))
      ('priority
       `(= priority ,(string-to-char (upcase (cadr query)))))
      ((or 'scheduled 'deadline)
       (let ((col (make-symbol (format "nodes:%s" (car query)))))
         (pcase (cadr query)
           ('after
            `(> ,col ,(zetian--query-parse-date (caddr query))))
           ('before
            `(< ,col ,(zetian--query-parse-date (caddr query))))
           ;; ('on-or-after
           ;;  `(>= ,col ,(zetian--query-parse-date (caddr query))))
           ;; ('on-or-before
           ;;  `(<= ,col ,(zetian--query-parse-date (caddr query))))
           (' on
              `(<= ,(zetian--query-parse-date (caddr query))
                   ,col
                   ,(zetian--query-parse-date (caddr query) t)))
           ('between
            `(<= ,(zetian--query-parse-date (caddr query))
                 ,col
                 ,(zetian--query-parse-date (cadddr query) t)))
           (_
            (error "invalid operation for %S: %S" (car query) (cadr query))))))
      ('prop
       `(like
         nodes:properties
         ,(zetian--query-quote-like (cons (cadr query) (caddr query)))))
      ('category
       (zetian--unroll-query-impl `(prop "CATEGORY" ,(cadr query))))
      ((or 'links-to 'links-from)
       (let ((col1 (if (eq 'links-to (car query)) 'links:source 'links:dest))
             (col2 (if (eq 'links-to (car query)) 'links:dest 'links:source)))
         `(in nodes:id [:select [,col1]
                        :from links
                        :where (= ,col1 nodes:id)
                        :and (= links:type "id")
                        ;; TODO this could be a sql sub-query
                        :and (= ,col2
                                ,(org-roam-node-id
                                  (org-roam-node-from-title-or-alias
                                   (cadr query))))])))
      (_
       (error "invalid search key: %S" (car query)))))

  (defun zetian--query-quote-like (obj &optional exact)
    "Return quoted OBJ in a form for `emacsql' query: (like column
  ,(zetian--query-quote-like (cons 'a 'b)))"
    (let ((double-quote "\"")
          (maybe-percent (unless exact "%")))
      `(quote ,(if (stringp obj)
                   (concat double-quote maybe-percent
                           obj
                           maybe-percent double-quote)
                 (concat maybe-percent
                         (prin1-to-string obj)
                         maybe-percent)))))

  (defun zetian--query-parse-date (date &optional next-day-when-no-time)
    (format-time-string "%Y-%m-%dT%H:%M:%S%z"
                        (ic-parse-org-date-string
                         date
                         next-day-when-no-time)))
#+END_SRC

*** Modifying Header Links
I want an easy way to add/update tags and other links on a given zettel. To start I'm probably just going to use /Tags/, but I could see myself using other forms as well, (maybe /Depends/ for moving my emacs config into zettels?). So I'll call them =header-links=.
#+BEGIN_SRC emacs-lisp
  (defvar zetian-header-formats '((tag . "/tags/ - ")
                                  (project . "/project/ - ")))
  (defvar zetian-header-seperator ", ")

  (defun zetian-add-header-link (type &optional node)
    "Add a link to NODE within the header line for TYPE."
    (interactive)
    (save-excursion
      (zetian--header-write
       type
       (zetian--header-modify
        (or node (zetian-node-create))
        'add
        (zetian--header-read type)))))

  (defun zetian-remove-header-link (type &optional node)
    "Add a link to NODE within the header line for TYPE."
    (interactive)
    (save-excursion
      (zetian--header-write
       type
       (zetian--header-modify
        (or node (zetian-header-link-read type (format "Remove %s: " type)))
        'remove
        (zetian--header-read type)))))

  (defun zetian-header-link-read (type &optional prompt)
    "Show a list of header links of TYPE and return the user selected node."
    (interactive)
    (error "helm not installed")
    (when-let ((links (zetian--header-read type)))
      (when-let ((link (helm
                        :sources
                        (helm-build-sync-source
                            (or prompt (format "%s: " type))
                          :candidates
                          (mapcar (lambda (link)
                                    (cons (cdr link) link))
                                  links)
                          :fuzzy-match 1))))
        (org-roam-node-from-title-or-alias (cdr link)))))

  (defun zetian--header-read (type)
    "Parse the contents of the header of type TYPE. Return a list of links found
    or NIL if not found."
    (zetian--move-to-header type)
    (let ((start (point))
          links
          done)
      (while (not done)
        ;; is the point on an org link?
        (if-let ((elem (org-element-link-parser)))
            (let* ((link (cadr elem))
                   (tgt (plist-get link :raw-link))
                   (desc (buffer-substring-no-properties
                          (plist-get link :contents-begin)
                          (plist-get link :contents-end)))
                   (end (plist-get link :end)))
              ;; add the found org link
              (setq links (append links (list (cons tgt desc))))
              ;; move to the end of the link
              (goto-char end)
              ;; try and move over `zetian-header-seperator'
              (re-search-forward
               (regexp-quote zetian-header-seperator)
               (+ (point) (length zetian-header-seperator))
               t)
              ;; keep going if we're looking at another org link
              (setq done (not (looking-at (regexp-quote "[[")))))
          ;; point was not on an org link, so we're done
          (setq done t)))
      ;; move to the start of the links and return
      (goto-char start)
      links))

  (defun zetian--move-to-header (type)
    "Moves point to and returns the position of the header of TYPE, creating it if
  necessary."
    (goto-char (point-min))
    (let ((re (concat "^" (regexp-quote
                           (assoc-default type zetian-header-formats)))))
      (unless (re-search-forward re nil t)
        ;; create header
        (re-search-forward "^$" nil 0)
        ;; TODO what if we have other headers, do we want so many newlines?
        (insert (format "\n%s\n" (assoc-default type zetian-header-formats)))
        ;; move back over the newline
        (backward-char 1))))

  (defun zetian--header-modify (node way links)
    "When WAY is 'add: add the NODE to LINKS. When WAY is 'remove: remove the NODE
  from LINKS."
    (let ((link (cons (concat "id:" (org-roam-node-id node))
                      (org-roam-node-title node))))
      (pcase way
        ('add
         (setq links (if links
                         (add-to-list 'links link)
                       (list link))))
        ('remove
         (when links
           (setq links (delete link links))))
        (_
         (error "invalid WAY: %S" way))))
    ;; return the (sorted) links
    (sort links (lambda (left right)
                  (string-collate-lessp (cdr left) (cdr right)))))

  (defun zetian--header-write (type links)
    "Write the header of type TYPE with LINKS. Overwrite current header if it
  exists or create it if necessary."
    ;; delete the current links
    (delete-region (point) (line-end-position))
    ;; insert the current links
    (insert (cl-reduce
             (lambda (s link)
               (concat s
                       (when (not (equal s "")) zetian-header-seperator)
                       (format "[[%s][%s]]" (car link) (cdr link))))
             links
             :initial-value "")))

  (defun zetian-add-tag ()
    "Prompt for a node to add as a tag to the current zettel."
    (interactive)
    (zetian-add-header-link 'tag))

  (defun zetian-remove-tag ()
    "Prompt for a tag of the current note and remove the selected tag."
    (interactive)
    (zetian-remove-header-link 'tag))

  (defun zetian-add-project ()
    "Prompt for a node to add as a project to the current zettel."
    (interactive)
    (zetian-add-header-link 'project
                            (zetian-search '(category "project")
                                           "Add Zetian project: ")))

  (defun zetian-remove-project ()
    "Prompt for a project of the current note and remove the selected project."
    (interactive)
    (zetian-remove-header-link 'project))
#+END_SRC

*** Meta Information
Sometimes I want some information about the entire state of =Zetian=.

#+BEGIN_SRC emacs-lisp
  (defun zetian-all-states ()
    "Return a list of all states (org tags) in the zetian database."
    (let ((results (org-roam-db-query [:select :distinct tag :from tags])))
      (sort (mapcar #'car results)
            #'string-collate-lessp)))

  (defun zetian-all-categories ()
    "Returns a list of all categories in the zetian database. Note: does a full
  table search."
    (let ((results
           (seq-reduce
            (lambda (cats node)
              (let ((cat (assoc-default "CATEGORY"
                                        (org-roam-node-properties node))))
                (if (member cat cats)
                    cats
                  (cons cat cats))))
            (org-roam-node-list)
            '())))
      (sort results #'string-collate-lessp)))
#+END_SRC

*** OpenLibrary Book Import
Let's migrate my book importing code to =org-roam=.
#+BEGIN_SRC emacs-lisp
  (defun zetian--format-book-template-header (book)
    "Create a template header from BOOK suitable for `org-roam-capture-templates'."
    (with-temp-buffer
      (unless (yas-minor-mode 1)
        (error "failed to load yas-minor-mode"))
      (let ((snippet-env
             (mapcar (lambda (c)
                       (list (car c)
                             (if (listp (cdr c))
                                 `(quote ,(cdr c))
                               (cdr c))))
                     book)))
        (yas-expand-snippet
         (concat
          ":PROPERTIES:\n"
          ":CATEGORY: book\n"
          ":TITLE: `title`\n"
          ":AUTHORS: `(mapcar (lambda (a) (format \"%S\" a)) authors)`\n"
          ":PAGES_MEDIAN: `pages-median`\n"
          ":END:\n"
          "#+title: `title`\n")
         nil
         nil
         snippet-env))
      (buffer-string)))

  (defun zetian--format-book-template-body (book)
    "Create a template body from BOOK suitable for `org-roam-capture-templates'."
    (with-temp-buffer
      (unless (yas-minor-mode 1)
        (error "failed to load yas-minor-mode"))
      (let ((snippet-env
             (append
              (mapcar (lambda (c)
                        (list (car c)
                              (if (listp (cdr c))
                                  `(quote ,(cdr c))
                                (cdr c))))
                      book)
              `((authors-pretty
                 ,(string-join (assoc-default 'authors book)
                               ", and "))
                (authors-pretty-links
                 ,(string-join (mapcar
                                (lambda (author)
                                  (zetian-node-link
                                   (zetian-node-create author "P")))
                                (assoc-default 'authors book))
                               ", and "))

                (author-ol-links
                 ,(string-join
                   (mapcar
                    (lambda (tuple)
                      (format "- [[https://openlibrary.org/authors/%s][OpenLibrary - %s]]"
                              (cdr tuple)
                              (car tuple)))
                    (-zip (assoc-default 'authors book)
                          (assoc-default 'ol-author-ids book)))
                   "\n"))
                (maybe-quote
                 ,(when-let ((desc (assoc-default 'description book)))
                    (format "#+begin_quote\n%s\n#+end_quote\n\n" desc)))
                (lt-uri
                 ,(if-let (id (assoc-default 'librarything-id book))
                      (format "/work/%s" id)
                    (format "/search.php?search=%s"
                            (assoc-default 'query-title book))))
                (gr-uri
                 ,(if-let (id (assoc-default 'goodreads-id book))
                      (format "/book/show/%s" id)
                    (format "/search?q=%s&search_type=books"
                            (assoc-default 'query-title book))))))))
        (yas-expand-snippet
         (concat
          "\%U\n\n"
          "/`title`/ by `authors-pretty-links`.\n\n"
          "`maybe-quote`"
          ;; "#+begin_quote\n`description`\n#+end_quote\n\n"
          "- [[https://librarything.com`lt-uri`][LibraryThing]]\n"
          "- [[https://openlibrary.org`ol-work-id`][OpenLibrary - `title`]]\n"
          "`author-ol-links`\n"
          "- [[https://www.overdrive.com/search?q=`query-title`][Overdrive]]\n"
          "- [[https://goodreads.com`gr-uri`][Goodreads]]\n"
          "- [[https://amazon.com/s?k=`query-title`][Amazon]]\n\n"
          "* TODO `title` :: `authors-pretty` [`first-year-published`]")
         nil
         nil
         snippet-env))
      (buffer-string)))

  (defun zetian-capture-book (&optional tag)
    "Import a book from OpenLibrary, optionally applying zetian TAG."
    (interactive)
    (let* ((book (ic/openlibrary-find-book))
           (title (assoc-default 'title book))
           (template `("p" "capture book template" plain
                      ,(zetian--format-book-template-body book)
                      :target (file+head
                               "%<%Y%m%d%H%M%S>-${slug}.org"
                               ,(zetian--format-book-template-header book)))))
      ;; (message "BOOK: %S\nTITLE: %S\nTEMPLATE:%S" book title template)
      (cl-letf ((org-roam-capture-templates (list template)))
        (when-let ((node (zetian-node-create title)))
          (zetian-node-find node)
          (org-cycle-content)
          (when tag
            (if-let ((tag-node (org-roam-node-from-title-or-alias tag)))
                (progn
                  (zetian-add-header-link 'tag tag-node)
                  (save-buffer))
              (error "Invalid zetian tag: %s" tag)))))))

  (defun zetian-capture-book-pleasure-toread ()
    "Import a book from OpenLibrary, and apply the 'Read for Pleasure' tag."
    (interactive)
    (zetian-capture-book "Read for Pleasure"))

  (defun zetian-capture-book-pleasure-completed ()
    "Import a book from OpenLibrary, and apply the 'Completed Pleasure Books' tag."
    (interactive)
    (zetian-capture-book "Completed Pleasure Books"))

  (defun zetian-capture-book-enrichment-toread ()
    "Import a book from OpenLibrary, and apply the 'Read for Enrichment' tag."
    (interactive)
    (zetian-capture-book "Read for Enrichment"))

  (defun zetian-capture-book-enrichment-completed ()
    "Import a book from OpenLibrary, and apply the 'Completed Enrichment Books' tag."
    (interactive)
    (zetian-capture-book "Completed Enrichment Books"))
#+END_SRC

*** Integrate with completing-read
Here we'll integrate =zetian= with emacs built-in =completing-read= api. We'll also annotate each item as ='zetian= so further packages (=marginalia= / =embark=) can key off the category.
#+BEGIN_SRC emacs-lisp

  (defun zetian-search (&optional query create query-name)
    (interactive)
    (let* ((candidates
            (mapcar
             (lambda (node)
               ;; add 'zetian-node to the title's properties so we can reference
               ;; it later.
               (let ((title (org-roam-node-title node)))
                 (add-text-properties 0 1 `(zetian-node ,node) title)
                 (cons title node)))
             (zetian-query query)))
           (completing-func
            (lambda (input predicate action)
              (if (eq action 'metadata)
                  '(metadata (category . zetian))
                (complete-with-action action candidates input predicate))))
           (prompt (if query-name
                       (format "[%s]: " query-name)
                     "Zetian Node: "))
           (selection (completing-read prompt completing-func)))
      (if-let ((node (assoc-default selection candidates)))
          (prog1 node
            ;; remove the 'zetian-node property added to the title
            (remove-text-properties 0 1 '(zetian-node)
                                    (org-roam-node-title node))
            )
        (when create
          (zetian-node-create selection)))))
#+END_SRC

*** Integrate with marginalia
Let's tell =marginalia= how to annotate zetian nodes so we get pretty completions.
#+BEGIN_SRC emacs-lisp
  (defvar zetian--org-done-keywords nil
    "Saved `org-done-keywords' so we can properly style todo items.")
  (with-eval-after-load 'org
    (setq zetian--org-done-keywords
          (with-temp-buffer
            (org-mode)
            org-done-keywords)))

  (defun zetian--completion-annotator (cand)
    "An annotator function for zetian nodes to be called from
  `completing-read'."
    (when-let ((node (get-text-property 0 'zetian-node cand)))
      (let* ((todo (org-roam-node-todo node))
             (todo-face (if (member todo zetian--org-done-keywords)
                            'org-done
                          'org-todo))
             (todo-str (if todo
                           (if (< 4 (length todo))
                               (concat (propertize (substring todo 0 4)
                                                   'face todo-face)
                                       ".")
                             (propertize todo 'face todo-face))
                         ""))
             (tags (seq-filter
                    (lambda (tag)
                      (not (string-match-p
                            org-agenda-hide-tags-regexp tag)))
                    (org-roam-node-tags node)))
             (tags-str (string-join tags ":"))
             (cat (assoc-default "CATEGORY" (org-roam-node-properties node)))
             (pri (org-roam-node-priority node))
             (pri-str (if pri
                          (format "[#%s]" (char-to-string pri))
                        "")))
        ;; ensure todo string is full width, otherwise the 'org-todo face extends past the tag
        (setq todo-str (concat todo-str
                               (make-string (- 5 (length todo-str)) ? )))
        (marginalia--fields
         (cat :face 'org-document-info
              :width 12)
         (pri-str :face (org-get-priority-face pri)
                  :width 4)
         (todo-str :width 5)
         (tags-str :face 'org-tag
                   :width 20
                   :truncate 20)))))

  ;; add our annotator to marginalia
  (with-eval-after-load 'marginalia
    (add-to-list 'marginalia-annotator-registry
                 '(zetian zetian--completion-annotator builtin none)))
#+END_SRC

** Beeping
Turn off the damn bell!
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil)
  (setq ring-bell-function #'ignore)
#+END_SRC

** Tramp
Some tramp specific configurations.

*** Guix
=tramp= doesn't honor the host's =$PATH= by default, instead searching directories manually for commands (ex =/usr/bin/ls=, =/bin/ls=, etc). As =guix= makes heavy use of =PATH= this doesn't work, so we need to setup =tramp= accordingly.
#+BEGIN_SRC emacs-lisp
  ;; only use $PATH on the remote host
  (connection-local-set-profile-variables
   'use-remote-path-envvar
   '((tramp-remote-path . (tramp-own-remote-path))))

  (connection-local-set-profiles
   '(:application tramp :machine "tornado")
   'use-remote-path-envvar)
#+END_SRC

** Directory Locals
*** lsp ignore Unity directories
=lsp-mode= should not create file watchers for every directory in a Unity project. I wish there was a way to whitelist directories, but =lsp= only allows for blacklisting. So use =dir-locals= to add some common =Unity= directories.
#+BEGIN_SRC emacs-lisp
  ;; setup directory local variables and make them as safe
  (let* ((ignore-dirs '("Build" "Library" "Logs" "obj" "Packages"
                        "ProjectSettings" "Temp" "UserSettings"))
         (ignore-regexes (append (mapcar (lambda (d) (concat "[/\\\\]" d "\\'"))
                                         ignore-dirs)
                                 lsp-file-watch-ignored-directories))
         (vars `((lsp-file-watch-ignored-directories . ,ignore-regexes))))
    (dir-locals-set-class-variables
     'unity-project
     `((nil . ,vars)))
    (dolist (var vars)
      (add-to-list 'safe-local-variable-values var)))

  (when on-home-windows-desktop
    (dir-locals-set-directory-class
     "c:/Code/Icarus" 'unity-project))
#+END_SRC

* Keybindings
Here we copy the spacemacs keybindings, more or less.

** main
#+BEGIN_SRC emacs-lisp
  (leader-keys
    "|" 'ic/shell-command-on-region-replace
    "C-|" 'shell-command-on-region
    "TAB" 'mode-line-other-buffer
    "u" 'universal-argument)
#+END_SRC

** normal mode
#+BEGIN_SRC emacs-lisp
  ;; (general-define-key
  ;;  :states '(normal)
  ;;  :keymaps 'general-override-mode-map
  ;;  "go" 'ic/move-to-outline-dwim
  ;;  "gl" 'helm-occur)
#+END_SRC

** insert mode
Some of these keys are set in a mode specific keymap that I don't want to trigger while in insert mode.
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps  'meow-insert-state-keymap
   "<left>"  'meow-left
   "<up>"    'meow-prev
   "<down>"  'meow-next
   "<right>" 'meow-right
   )
#+END_SRC

** Escape Key
Make  =<escape>= quit as much as possible.

XXX should these go in an override map?

#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map
                 minibuffer-local-must-match-map
                 minibuffer-local-isearch-map)
      "<escape>" 'keyboard-escape-quit)
#+END_SRC

** a :: applications
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "a"
   "" '(nil :which-key "applications")
   "d" 'dired
   "s" 'ansi-term
   "i" 'ielm
   )
#+END_SRC

** b :: buffers
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "b"
   "" '(nil :which-key "buffers")
   "b" 'consult-buffer
   "B" 'consult-buffer-other-window
   "d" 'kill-this-buffer
   "i" 'ibuffer
   "P" 'ic/paste-clipboard-to-buffer
   "R" 'revert-buffer
   "s" 'ic/switch-to-scratch-buffer
   "w" 'read-only-mode
   "Y" 'ic/yank-buffer-to-clipboard)
#+END_SRC

** B :: build

** e :: errors

** E :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "E"
    "" '(nil :which-key "emacs")
    "d" 'toggle-debug-on-error
    "f" 'toggle-frame-fullscreen
    "F" 'make-frame
    "m" 'toggle-frame-maximized)
#+END_SRC

** Ep :: Emacs profiler
Profiler bindings.
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "Ep"
   "" '(nil :which-key "emacs profiler")
   "c" #'ic/start-cpu-profiler
   "m" #'ic/start-mem-profiler
   "p" #'ic/start-cpu-mem-profiler
   "s" #'profiler-stop
   "r" #'profiler-report)
#+END_SRC

** f :: Files
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "f"
   "" '(nil :which-key "files")
   "b" 'ic-consult-bookmark
   "c" 'copy-file
   "D" 'ic/delete-current-buffer-file
   "E" 'sudo-edit
   "f" 'find-file
   "F" 'find-file-other-window
   "L" 'locate-library
   "M" 'ic/rename-current-buffer-file
   ;; "r" 'ic/helm-recentf
   "y" 'ic/yank-current-filename)
#+END_SRC

** fC :: Convert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fC"
   "" '(nil :which-key "convert")
   "d" 'unix-to-dos
   "u" 'dos-to-unix)
#+END_SRC

** fe :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fe"
   "" '(nil :which-key "emacs")
   "i" 'ic/edit-init-file
   "I" 'ic/edit-early-init-file
   "o" 'ic/edit-org-config-file)
#+END_SRC

** TODO g :: git/vc
/can't use "g" with meow/
#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
    :infix "g"
    "" '(nil :which-key "git")
    "i" 'magit-gitignore
    "s" 'magit-status
    "S" 'magit-stage-file
    "U" 'magit-unstage-file
    )
#+END_SRC

** TODO h :: help
/can't use "h" with meow/
#+BEGIN_SRC emacs-lisp
  (define-key help-map (kbd "a") 'consult-apropos)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
   :infix "h"
   "" '(nil :which-key "help")
   "a" 'apropos
   "k" 'which-key-show-top-level
   "i" 'info
   "I" 'helm-info
   "m" 'helm-man-woman)
#+END_SRC

** TODO hd :: help describe
#+BEGIN_SRC emacs-lisp :tangle no
  (leader-keys
   :infix "hd"
   "" '(nil :which-key "describe")
   "b" 'describe-bindings
   "c" 'describe-char
   "f" 'describe-function
   "F" 'describe-face
   "K" 'describe-keymap
   "k" 'describe-key
   "l" 'describe-last-keys
   "m" 'describe-mode
   "p" 'describe-package
   "s" 'describe-system-info
   "t" 'describe-theme
   "v" 'describe-variable)
#+END_SRC

** i :: insert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "i"
   "" '(nil :which-key "insert")
   ;; "8" 'helm-ucs
   "c" 'insert-char
   )
#+END_SRC

** j :: jump
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "j"
    "" '(nil :which-key "jump")
    "i" 'consult-imenu
    "I" 'consult-imenu-multi
    "l" 'consult-line
    "m" 'consult-mark
    "M" 'consult-global-mark
    "o" 'consult-outline-or-org-heading
    )
#+END_SRC

** l :: layouts

** m :: major mode

** p :: projects

** r :: registers
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "r"
    "" '(nil :which-key "registers")
    "l" 'consult-register-load
    "k" 'consult-yank-from-kill-ring
    "r" 'consult-register
    "s" 'consult-register-store
    )
#+END_SRC

** s :: search
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "s"
    "" '(nil :which-key "search")
    "f" 'consult-find
    "g" 'consult-git-grep
    "G" 'consult-grep
    "r" 'consult-ripgrep
    )
#+END_SRC

** S :: snippets
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "S"
    "" '(nil :which-key "snippets")
    "e" #'yas-visit-snippet-file
    "i" #'yas-insert-snippet
    "n" #'yas-new-snippet)
#+END_SRC

** t :: toggle
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "t"
   "" '(nil :which-key "toggle")
   "C" 'flycheck-mode
   "S" 'flyspell-mode
   "T" 'load-theme
   "m" 'consult-minor-mode-menu
   "w" 'whitespace-mode
   )
#+END_SRC

** w :: windows
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "w"
   "" '(nil :which-key "windows")
   "=" 'balance-windows
   "d" 'delete-window
   "f" 'follow-mode
   ;; "H" 'evil-window-move-far-left
   ;; "h" 'evil-window-left
   ;; "J" 'evil-window-move-very-bottom
   ;; "j" 'evil-window-down
   ;; "K" 'evil-window-move-very-top
   ;; "k" 'evil-window-up
   ;; "L" 'evil-window-move-far-right
   ;; "l" 'evil-window-right
   "h" 'windmove-left
   "j" 'windmove-down
   "k" 'windmove-up
   "l" 'windmove-right
   "m" 'delete-other-windows
   "S" 'split-window-below-and-focus
   "s" 'split-window-below
   "U" 'winner-redo
   "u" 'winner-undo
   "V" 'split-window-right-and-focus
   "v" 'split-window-right
   )
#+END_SRC

** x :: text

