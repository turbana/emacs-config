#+TITLE: Emacs Config
#+STARTUP: content

Welcome to my emacs configuration.

* Initial Setup
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

I want to be able to potentially load separate emacs configurations so set the base emacs directory to where the currently loading configuration is.
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory load-file-name))
#+END_SRC

I also want to keep my =user-emacs-directory= somewhat clean, so let's define a few sub directories that we'll try to keep the plethora of emacs files in:
- =user-cache-directory= :: files that contain transient data (history, projectile, etc).
- =user-data-directory= :: files that contain version controlled data (snippets, etc)

#+BEGIN_SRC emacs-lisp
  (defvar user-cache-directory (concat user-emacs-directory "cache/"))
  (defvar user-data-directory (concat user-emacs-directory "data/"))
#+END_SRC

* Bootstrap
** Native compilation
I want to make use of the native compilation system introduced in emacs 28.
#+BEGIN_SRC emacs-lisp
  ;; do we have native compilation available?
  (defconst have-native-compilation
    (and (fboundp 'native-comp-available-p)
         (native-comp-available-p)))

  (when have-native-compilation
    (setq comp-async-jobs-number 4))
#+END_SRC
** init.el
On checking out this repo =init.el= will have temporary code in it to tangle / load this org file (=README.org=), overwriting itself. On this initial run we will have loaded both core =org-mode= and melpa =org-mode= so emit a warning that a restart is needed.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; load core emacs `org-mode', but don't native compile it
  (let ((comp-deferred-compilation nil))
    (require 'org))

  ;; tangle/load our init file
  (let* ((base-dir (file-name-directory load-file-name))
         (org-file (concat base-dir "README.org"))
         (el-file (concat base-dir "init.el")))
    (org-babel-tangle-file org-file el-file)
    ;; on first load we shadow the core emacs org-mode and when trying to quit
    ;; emacs calls the non-existent function `org-clocking-buffer'. Define a dummy
    ;; to allow us to exit cleanly on initial run
    (defun org-clocking-buffer (&rest _))
    (load-file el-file)
    (warn "This is the first load of init.el so core emacs `org-mode' is loaded.
   Restart emacs to use newest version."))
#+END_SRC

We also need to tell =git= to ignore changes to =init.el= so the following command was run:
#+BEGIN_SRC shell :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

This file (=README.org=) should be tangled into the startup config file (=init.el=) along with compiling (either native or byte). I want that to happen automatically.
#+BEGIN_SRC emacs-lisp
  (defun ic-maybe-tangle-init-file ()
    "Tangle/compile my emacs configuration."
    (let ((org-files (list
                      (expand-file-name "~/src/emacs/README.org")
                      (concat user-emacs-directory "README.org")))
          (init-file (concat user-emacs-directory "init.el")))
      (when (member (buffer-file-name) org-files)
        (save-restriction
          (widen)
          (org-babel-tangle nil init-file))
        ;; (byte-compile init-file)
        ;; (when have-native-compilation
        ;;   (native-compile init-file))
        )))

  (add-hook 'after-save-hook 'ic-maybe-tangle-init-file)
#+END_SRC

Let's also tell emacs where =init.el= lives so packages can find it. =straight.el= requires it for updating packages.
#+BEGIN_SRC emacs-lisp
  (setq user-init-file (concat user-emacs-directory "init.el"))
#+END_SRC

** straight.el
I use =straight.el= for package management so install this early.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integrate =straight.el= with =use-package=.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
#+END_SRC

I want to check in my packages to git so store the version file under =user-data-directory=.
#+BEGIN_SRC emacs-lisp
  (setq straight-profiles `((nil . ,(concat user-data-directory "straight-default.el"))))
#+END_SRC

** Theme
Load my custom theme early so if we have errors emacs still looks pretty.

#+BEGIN_SRC emacs-lisp
  (use-package themian-theme
    :straight (themian :type git :host github :repo "turbana/themian")
    :init
    (setq themian-org-mode-variable-pitch t)
    (setq themian--show-unknowns t)
    (set-face-attribute 'default nil :family "Iosevka Extended" :height 110 :weight 'normal)
    (set-face-attribute 'fixed-pitch nil :family "Iosevka Extended" :height 110 :weight 'normal)
    (set-face-attribute 'variable-pitch nil :family "DejaVu Sans Condensed" :height 120 :weight 'normal)
    :config
    (load-theme 'themian-dark t))
#+END_SRC

** Debugging
*** Tracing
Some functions to trace the changing of variables.

#+BEGIN_SRC emacs-lisp
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
    (ic/watch-variable-call-func symbol 'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (sym value operation buffer)
      (let ((msg (ic//watch-variable-format sym buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol 'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol 'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (sym value operation buffer)
        (when (member operation ops)
          (apply func (list sym value operation buffer))))
      (add-variable-watcher symbol 'watch-change)
      (push (cons symbol 'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC

*** Profiling
Some profiler keybindings.

#+BEGIN_SRC emacs-lisp
  (require 'profiler)

  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))

  (defun ic/start-cpu-mem-profiler ()
    "Start both CPU and memory profiling."
    (interactive)
    (profiler-start 'cpu+mem))
#+END_SRC

** Keybinds
I like the spacemacs idea of having both a leader key (=SPC=) and a (mode-specific) local leader key (=,=). The leader key being how all the major functions are accessed, such as buffers/files/windows/etc. Where the local leader is how mode-specific functions are accessed, such as =org-mode= bindings or =mu4e=, etc.

There are a few things I don't care for though: I don't need emacs bindings, nor do I want access to the local leader map from the leader map (=SPC m=). So I want a dual leader key system without the cruft.

The package =general.el= makes all of the above rather simple. Here we ensure it's installed and activated with =:demand t=. We then setup two =definers=, one for the leader key (=leader-keys=) and one for the local leader key (=local-leader-keys=). Both =definers= define their keys in the =general-override-mode-map= keymap. This keymap has a high priority, but only when =general-override-mode= is active so ensure it is with =(general-override-mode 1)=.

#+BEGIN_SRC emacs-lisp
  (use-package general
      :demand t
      :config
      ;; ensure `general-override-mode-map' is active
      (general-override-mode 1)

      ;; create leader (SPC) definer
      (general-create-definer leader-keys
        :states '(normal motion insert emacs)
        :keymaps 'general-override-mode-map
        :prefix "SPC"
        :non-normal-prefix "C-SPC")

      ;; create local leader (,) definer
      (general-create-definer local-leader-keys
        :states '(normal motion insert emacs)
        :keymaps 'general-override-mode-map
        :prefix ","
        :non-normal-prefix "C-,"))
#+END_SRC

** Secrets
I keep certain information out of source control: email addresses, account information, etc. I have a small python program called =secret= that I use to retrieve these secrets, let's expose that to emacs.

#+BEGIN_SRC emacs-lisp
  (defvar ic/secret-cmd "secret")

  (defun ic/get-secret (secret)
    "Retrieve `secret' using the `ic/secret-cmd' program."
    (nth 0 (process-lines ic/secret-cmd secret)))
#+END_SRC

* Packages
** all-the-icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** auto-dim-other-buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for color customization.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
      :config
      (defun ic-dont-auto-dim-helm-windows (buffer)
        "Return `t' if inside a helm buffer, so `auto-dim-other-buffers' won't dim the current helm window."
        (equal "*helm" (substring (buffer-name buffer) 0 5)))
      (setq auto-dim-other-buffers-dim-on-focus-out t)
      (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
      (push #'ic-dont-auto-dim-helm-windows
            auto-dim-other-buffers-never-dim-buffer-functions)
      (auto-dim-other-buffers-mode t))
#+END_SRC

** company-mode
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :config

    ;; company-show-location
    ;; company-show-doc-buffer

    (setq company-tooltip-align-annotations nil)
    (setq company-abort-on-unique-match t)

    ;; (company-search-candidates)
    ;; (company-filter-candidates)
    :general
    (general-define-key
     :keymaps 'company-active-map
     "C-l" 'company-show-location
     "C-h" 'company-show-doc-buffer
     "C-w" 'backward-kill-word
     "C-s" 'company-search-candidates
     "C-f" 'company-filter-candidates
     )
    )
#+END_SRC

** csharp-mode
Minimal setup for viewing =C#= code.

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode)
#+END_SRC

** evil
*** use-package
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package evil
      :ensure evil
      :init
      <<evil-init>>
      :config
      <<evil-config>>
      )
#+END_SRC

*** evil-init
:PROPERTIES:
:header-args: :noweb-ref evil-init :tangle no
:END:

The following are needed for =evil-collection=:
#+BEGIN_SRC emacs-lisp
  ;; needed for evil-collection
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
#+END_SRC

Misc setup
#+BEGIN_SRC emacs-lisp
  ;; don't bind anything under C-g
  (setq evil-want-C-g-bindings nil)

  ;; C-u/d should scroll up/down
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-d-scroll t)

  ;; C-w should backwards delete work in insert mode
  (setq evil-want-C-w-delete t)

  ;; Y should only yank from point to eol
  (setq evil-want-Y-yank-to-eol t)

  ;; movement commands should respect `visual-line-mode'
  (setq evil-respect-visual-line-mode t)
#+END_SRC

*** evil-config
:PROPERTIES:
:header-args: :noweb-ref evil-config :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

** evil-collection
Some basic community =evil-mode= bindings for various modes. See =evil-collection--supported-modes= for a list.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
      :after evil
      :init
      (setq evil-collection-company-use-tng nil)
      :config
      (evil-collection-init))
#+END_SRC

** evil-org-mode
Some basic community =evil-mode= key bindings for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
      :demand t
      :after (evil org)
      :hook (org-mode . evil-org-mode)
      :config
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    )
#+END_SRC

** haskell-mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :demand t)
#+END_SRC

** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :config
    (helm-mode 1)

    ;; bring up helm full width below other windows
    (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))

    ;; short window by default
    (setq helm-display-buffer-default-height 20)

    :general
    (general-define-key
     :keymaps 'helm-map
     ;; I'm too used to C-w killing a word backwards
     "C-w" 'backward-kill-word
     ;; TAB should be more useful than bringing up actions
     "<tab>" 'helm-execute-persistent-action
     "C-i" 'helm-execute-persistent-action
     ;; C-, should start actions
     "C-," 'helm-select-action
     ;; C-. to paste into buffer
     "C-." 'helm-copy-to-buffer
     ;; <left/right> should move the point
     "<left>" 'backward-char
     "<right>" 'forward-char
     )

    ;; set some helm-grep keys
    (general-define-key
     :states '(normal)
     :keymaps 'helm-grep-mode-map
     "RET" 'helm-grep-mode-jump
     "o" 'helm-grep-mode-jump-other-window)

    (general-define-key
     "M-x" 'helm-M-x)

    (general-define-key
     :states '(normal)
     "gi" 'helm-semantic-or-imenu)

    (leader-keys
      "R" 'helm-resume)
    )
#+END_SRC

** helm-org-ql
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-ql)
#+END_SRC

** helm-posframe
Let's try having =helm= popup in a frame. I'd like it to cover to full screen width and have minimal styling.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package helm-posframe
    :config
    (setq helm-posframe-poshandler
          #'posframe-poshandler-frame-bottom-center)
    (setq helm-posframe-min-width (+ 1 (frame-width)))
    (setq helm-posframe-width helm-posframe-min-width)
    (setq helm-posframe-min-height 20)
    (setq helm-posframe-height helm-posframe-min-height)
    (setq helm-posframe-border-width 0)
    (helm-posframe-enable))
#+END_SRC

** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :demand t
    :after (helm projectile)
    :config
    (helm-projectile-on)

    (defmacro ic/defproject-call-switch (name-sym proj-func-sym non-proj-func-sym)
      "Bind function NAME and have it call PROJ-FUNC when inside a
  `projectile-mode' project, or NON-PROJ-FUNC otherwise."
      (declare (indent defun))
      (let ((proj-func (cadr proj-func-sym))
            (non-proj-func (cadr non-proj-func-sym))
            (name (cadr name-sym)))
        (cond ((not (fboundp proj-func))
               (error "Function `%s' not bound" (symbol-name proj-func)))
              ((not (fboundp non-proj-func))
               (error "Function `%s' not bound" (symbol-name non-proj-func)))
              (t
               `(defun ,name ()
                  ,(format "Call `%s' when inside a project, `%s' otherwise."
                           (symbol-name proj-func) (symbol-name non-proj-func))
                  (interactive)
                  (if (and (fboundp 'projectile-project-p) (projectile-project-p))
                      (call-interactively ,proj-func-sym)
                    (call-interactively ,non-proj-func-sym)))))))

    (defun ic//helm-find-files ()
      "Call `(help-find-files nil)'."
      (interactive "P")
      (call-interactively 'helm-find-files nil))

    (ic/defproject-call-switch 'ic/helm-buffers
      'helm-projectile-switch-to-buffer 'helm-mini)

    (ic/defproject-call-switch 'ic/helm-find-files
      'helm-projectile-find-file 'helm-find-files)

    (ic/defproject-call-switch 'ic/helm-recentf
      'helm-projectile-recentf 'helm-recentf)

    (ic/defproject-call-switch 'ic/projectile-ibuffer
      'projectile-ibuffer 'ibuffer)
    )
#+END_SRC

** helm-rg
#+BEGIN_SRC emacs-lisp
  (use-package helm-rg
    :after (helm))
#+END_SRC

** lsp
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :demand t
    :commands lsp

    :init
    (setq lsp-keymap-prefix "C-c l")

    ;; don't show the top breadcrumbs by default
    (setq lsp-headerline-breadcrumb-enable nil)

    :hook
    ((lsp-mode . lsp-enable-which-key-integration))

    :general
    (local-leader-keys
      :keymaps 'prog-mode-map
      "l" lsp-command-map)
    )
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    ;; don't use magit's default key bindings
    (setq magit-define-global-key-bindings nil)

    :general
    (general-define-key
     :keymaps 'magit-status-mode-map
     "<up>" 'magit-section-backward
     "<down>" 'magit-section-forward))
#+END_SRC

** mu4e
*** Install
=mu4e= is installed as part of the =guix= package =mu=, so rather than use =(use-package mu4e)= to install, we just setup the =load-path= and load it the old fashioned way.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.config/guix/profiles/desktop/desktop/share/emacs/site-lisp/"))
  (require 'mu4e)
#+END_SRC

*** Initial setup
First, setup mu.
#+BEGIN_SRC emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-maildir "~/mail")
  ;; (setq mu4e-mu-binary "/usr/local/bin/mu")
  (setq mu4e-get-mail-command "offlineimap -o")
#+END_SRC

We can only check our gmail accounts once every 10 minutes or we risk a ban.
#+BEGIN_QUOTE
Make sure your mail app isn't set to check for new email too frequently. If your mail app checks for new messages more than once every 10 minutes, the app’s access to your account could be blocked.
#+END_QUOTE
More information [[https://support.google.com/mail/answer/7126229?p=BadCredentials&visit_id=636868193607658613-796315695&rd=2#cantsignin][here]].

#+BEGIN_SRC emacs-lisp
  (setq mu4e-update-interval 600)
#+END_SRC

Then, some common variables.
#+BEGIN_SRC emacs-lisp
  ;; show images inline
  (setq mu4e-view-show-images t)
  (setq mu4e-show-images t)
  ;; show addresses rather than names
  (setq mu4e-view-show-addresses t)
  ;; strip html when viewing emails...
  ;; (setq mu4e-html2text-command "w3m -dump -T text/html")
  (setq mu4e-html2text-command "iconv -c -t utf-8 | pandoc -f html -t plain")
  ;; ... and allow me to open an email in a browser
  (add-to-list 'mu4e-view-actions '("view in browser" . mu4e-action-view-in-browser) t)
  ;; don't keep message buffers around
  (setq message-kill-buffer-on-exit t)
  ;; quit silently
  (setq mu4e-confirm-quit nil)
#+END_SRC

*** Header view
Have a slightly different layout when showing an inbox.
#+BEGIN_SRC emacs-lisp
  ;; different date format
  (setq mu4e-headers-date-format "%Y-%m-%d %H:%M")
  (setq mu4e-headers-time-format "%H:%M")
  ;; set header fields
  (setq mu4e-headers-fields
        '((:maildir    . 12)
          (:flags      . 6)
          (:human-date . 17)
          (:from       . 20)
          (:subject    . nil)))
#+END_SRC

I like having each section of the header view it's own color. The following code
was taken from [[https://github.com/djcb/mu/issues/1355][github]] and modified to my taste.
#+BEGIN_SRC emacs-lisp
  (defface mu4e-maildirs-extension-maildir-face
    '((t (:inherit font-lock-function-name-face)))
    "Face for `mu4e' maildir.")
  (defface mu4e-maildirs-extension-maildir-hl-face
    '((t (:inherit font-lock-function-name-face)))
    "Face for `mu4e' highlighted maildir.")

  (defun mu4e~headers-line-apply-flag-face (msg line)
    line)

  (defun mu4e~headers-field-apply-basic-properties (msg field val width)
    (cl-case field
      (:subject
       (propertize
        (concat
         (mu4e~headers-thread-prefix (mu4e-message-field msg :thread))
         (truncate-string-to-width val 600))
        'face
        (let ((flags (mu4e-message-field msg :flags))
              (spam (string-suffix-p "spam" (mu4e-message-field msg :maildir)))
              (trash (string-suffix-p "trash" (mu4e-message-field msg :maildir))))
          (cond
           ((or (memq 'trashed flags) spam trash) 'mu4e-trashed-face)
           ((memq 'draft flags) 'mu4e-draft-face)
           ((or (memq 'unread flags) (memq 'new flags))
            'mu4e-unread-face)
           ((memq 'flagged flags) 'mu4e-flagged-face)
           ((memq 'replied flags) 'mu4e-replied-face)
           ((memq 'passed flags) 'mu4e-forwarded-face)
           (t 'mu4e-header-face)))))
      (:thread-subject
       (propertize
        (mu4e~headers-thread-subject msg)
        'face 'font-lock-doc-face))
      ((:maildir :path :message-id)
       (let* ((parts (split-string val "/")))
         (concat (propertize "/"
                             'face 'mu4e-maildirs-extension-maildir-face)
                 (propertize (cadr parts)
                             'face 'mu4e-maildirs-extension-maildir-hl-face)
                 (propertize (concat "/" (mapconcat #'identity (cddr parts) "/"))
                             'face 'mu4e-maildirs-extension-maildir-face)))
       )
      ((:to :from :cc :bcc)
       (propertize
        (mu4e~headers-contact-str val)
        'face 'mu4e-contact-face))
      (:from-or-to (mu4e~headers-from-or-to msg))
      (:date
       (propertize
        (format-time-string mu4e-headers-date-format val)
        'face 'org-sexp-date))
      (:mailing-list (mu4e~headers-mailing-list val))
      (:human-date
       (propertize
        (mu4e~headers-human-date msg)
        'help-echo (format-time-string
                    mu4e-headers-long-date-format
                    (mu4e-msg-field msg :date))
        'face 'org-sexp-date))
      (:flags
       (propertize (mu4e~headers-flags-str val)
                   'help-echo (format "%S" val)
                   'face 'mu4e-url-number-face))
      (:tags
       (propertize
        (mapconcat 'identity val ", ")
        'face 'font-lock-builtin-face))
      (:size (mu4e-display-size val))
      (t (mu4e~headers-custom-field msg field))))
#+END_SRC

*** Contexts
We need a helper function to determine what context we're in automatically.
#+BEGIN_SRC emacs-lisp
  ;; taken from: https://notanumber.io/2016-10-03/better-email-with-mu4e/
  (defun ic//mu4e-maildir-matches (msg rx)
    (when rx
      (if (listp rx)
            ;; If rx is a list, try each one for a match
            (or (ic//mu4e-maildir-matches msg (car rx))
                (ic//mu4e-maildir-matches msg (cdr rx)))
          ;; Not a list, check rx
          (string-match rx (mu4e-message-field msg :maildir)))))
#+END_SRC

Choose the first context when starting =mu4e=.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-context-policy 'pick-first)
#+END_SRC

Now some account specific setup
#+BEGIN_SRC emacs-lisp
  ;; This sets up my two different context for my personal and work emails.
  (setq mu4e-contexts
        (let ((professional-address (ic/get-secret "email.professional.address"))
              (professional-name (ic/get-secret "email.professional.name"))
              (personal-address (ic/get-secret "email.personal.address"))
              (personal-name (ic/get-secret "email.personal.name")))
          `( ,(make-mu4e-context
               :name "professional-gmail"
               :enter-func `(lambda () (mu4e-message (concat "Switch to " ,professional-address)))
               :match-func (lambda (msg)
                             (when msg
                               (ic//mu4e-maildir-matches msg "^/pro/")))
               :leave-func (lambda () (mu4e-clear-caches))
               :vars `((user-mail-address     . ,professional-address)
                       (user-full-name        . ,professional-name)
                       (mu4e-sent-folder      . "/pro/sent")
                       (mu4e-drafts-folder    . "/pro/drafts")
                       (mu4e-trash-folder     . "/pro/trash")
                       (mu4e-refile-folder    . "/pro/archive")
                       (smtpmail-smtp-user    . ,professional-address)
                       ))
              ,(make-mu4e-context
                :name "home-gmail"
                :enter-func (lambda () `(mu4e-message (concat "Switch to " ,personal-address)))
                :match-func (lambda (msg)
                              (when msg
                                (ic//mu4e-maildir-matches msg "^/per/")))
                :leave-func (lambda () (mu4e-clear-caches))
                :vars `((user-mail-address     . ,personal-address)
                        (user-full-name        . ,personal-name)
                        (mu4e-sent-folder      . "/per/sent")
                        (mu4e-drafts-folder    . "/per/drafts")
                        (mu4e-trash-folder     . "/per/trash")
                        (mu4e-refile-folder    . "/per/archive")
                        (smtpmail-smtp-user    . ,personal-address)
                        )))))
#+END_SRC

*** Sending mail
Some default gmail setup.
#+BEGIN_SRC emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it)
  (setq smtpmail-smtp-server "smtp.gmail.com")
  (setq smtpmail-smtp-service 587)
#+END_SRC

For each of our gmail accounts we need an application specific password to use
to send email. To create one go [[https://security.google.com/settings/u/1/security/apppasswords][here]]. Be sure and insert a line into
=~/.authinfo.gpg= for each account with the following format:
#+BEGIN_EXAMPLE
machine smtp.gmail.com port 587 login <user>@gmail.com password <account password>
#+END_EXAMPLE

*** Composing
Message composing should be done in =org-mode= format and sent as html.
#+BEGIN_SRC emacs-lisp
  ;; compose under the current context
  (setq mu4e-compose-context-policy nil)

  ;; automatically flow text when sending
  (setq mu4e-compose-format-flowed t)

  ;; enter org-mode when composing
  (add-hook 'message-mode-hook 'org-msg-mode)

  ;; export org-mode into html when sending
  (setq org-mu4e-convert-to-html t)

  ;; (setq org-mu4e-link-query-in-headers-mode nil)
#+END_SRC

*** Bookmarks
Setup some bookmarks
#+BEGIN_SRC emacs-lisp
  (setq mu4e-bookmarks
        (list
         (make-mu4e-bookmark
          :name "All Inboxes"
          :query "maildir:/per/inbox or maildir:/pro/inbox"
          :key ?i)
         (make-mu4e-bookmark
          :name "All Unread"
          :query (concat "flag:unread"
                         " and not maildir:/per/spam"
                         " and not maildir:/per/trash"
                         " and not maildir:/pro/spam"
                         " and not maildir:/pro/trash")
          :key ?u)
         (make-mu4e-bookmark
          :name "Sent"
          :query "maildir:/per/sent or maildir:/pro/sent"
          :key ?s)
         (make-mu4e-bookmark
          :name "Spam"
          :query "maildir:/per/spam or maildir:/pro/spam"
          :key ?S)
         ))
#+END_SRC

*** Org capture
I want to be able to save a TODO item for the current email and archive in one swoop.
#+BEGIN_SRC emacs-lisp
  (defun ic//org-capture-email ()
    "For email at point: call `org-capture' and mark for refile."
    (interactive)
    (org-store-link nil)
    (org-capture nil "r")
    (cond ((eq major-mode 'mu4e-headers-mode)
           (mu4e-headers-mark-for-refile))
          ((eq major-mode 'mu4e-view-mode)
           (mu4e-view-mark-for-refile))))
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps '(mu4e-headers-mode-map mu4e-view-mode-map)
   :states '(normal motion emacs)
   "a" #'mu4e-headers-mark-for-refile
   "r" #'ic//org-capture-email
   )
#+END_SRC

** oauth2
Mostly needed for google authentication in =org-caldav=.

#+BEGIN_SRC emacs-lisp
  (use-package oauth2
    :ensure t)
#+END_SRC

** org
=org-mode= is a large part of my daily emacs usage so it takes a large amount of my configuration as well. Let's go...

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
      :mode (("\\.org$" . org-mode))
      :ensure org-plus-contrib
      :after (all-the-icons yasnippet)
      :config
      <<org-config>>
      :general
      <<org-keybinds>>
      )
#+END_SRC

*** org-config
:PROPERTIES:
:header-args: :noweb-ref org-config :tangle no
:END:

**** Basic Setup
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (append
         '("~/org/home/home.org"
           "~/org/home/calendar.org"
           "~/org/home/birthdays.org"
           "~/org/home/jobs.org"
           "~/org/home/mobileinbox.org")
         (directory-files "~/org" t "\\.org$")))
  (setq org-default-notes-file "~/org/inbox.org")
  (setq org-archive-location "%s_archive::")
#+END_SRC

**** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp
  (defun ic/org-jump ()
    "Jump to an `org-refile-targets' heading."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-refile)))

  (defun ic/org-jump-in-buffer ()
    "Jump to a heading in the current buffer."
    (interactive)
    ;; `org-refile-targets' needs to be dynamically bound
    (defvar org-refile-targets)
    (let ((org-refile-targets '((nil :maxlevel . 999))))
      (ic/org-jump)))
#+END_SRC

**** Normal mode navigation
#+BEGIN_SRC emacs-lisp
  (defun ic/outline-current-heading-or-up ()
    "When point is on an org-mode heading: move to parent heading;
  otherwise: move to current heading."
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'outline-up-heading
                          'outline-previous-heading)))

  (defun ic/outline-current-heading-or-backward ()
    "when point is on an org-mode heading: move to previous heading;
  otherwise: move to previous heading"
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'org-backward-heading-same-level
                          'outline-previous-heading)))
#+END_SRC

**** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation t)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: \Delta{}v \ne \pi
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t)
  ;; don't use super/sub-scripts as they mess with headings
  (setq org-pretty-entities-include-sub-superscripts nil)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Because =org-mode= is mostly prose use =buffer-face-mode= (along with setting the face =org-default=) to get variable pitch text. See the variable =themian-force-fixed-faces= for a list of faces that will remain fixed.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'buffer-face-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]]. See [[*org-bullets][org-bullets]] setup as well.
#+BEGIN_SRC emacs-lisp
  ;; ⚫•⦾⦿—⬎⌄⌵
  (setq org-ellipsis " ⌵")

  ;; replace certain org-mode text with symbols
  (defun ic/org-mode-pretty-symbols ()
    "Enable `prettify-symbols-mode' and set `prettify-symbols-alist' for certain
  `org-mode' symbols."
    (setq prettify-symbols-alist
          '(("[#A]" . ?)
            ("[#B]" . ?)
            ("[#C]" . ?)
            ("[ ]" . ?)
            ("[X]" . ?)
            ("[-]" . ?)
            ("SCHEDULED:" . ?)
            ("DEADLINE:" . ?)))
    (prettify-symbols-mode 1))

  (add-hook 'org-mode-hook #'ic/org-mode-pretty-symbols)
  (add-hook 'org-agenda-mode-hook #'ic/org-mode-pretty-symbols)
#+END_SRC

Change list items to symbol. Code inspired by [[https://emacs.stackexchange.com/questions/59882/how-to-change-color-of-font-lock-add-keywords][this]] stack exchange question.
#+BEGIN_SRC emacs-lisp
  (require 'org-element)

  (setq ic/org-list-icon (propertize "" 'face 'themian-subtle))

  (defun org+-match-item-marker (bound)
    "Match the bullet of itemizations."
    (and
     (re-search-forward "^ *\\(-\\) " bound t)
     (save-match-data
       (save-excursion
         (goto-char (match-end 1))
         (eq (org-element-type (org-element-at-point)) 'item)))))

  ;; change list dashes
  (font-lock-add-keywords
   'org-mode
   `((org+-match-item-marker
      (1
       '(face default display ,ic/org-list-icon)
       append)))
   t)
#+END_SRC

Color priorities based on how important they are.
#+BEGIN_SRC emacs-lisp
  (setq org-priority-faces '((?A . '(:inherit (themian-error org-priority)))
                             (?B . 'org-priority)
                             (?C . '(:inherit (themian-weak org-priority)))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

**** org-src
Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

When editing an =org-src= block =:w= should save the parent buffer.
#+BEGIN_SRC emacs-lisp
  (evil-define-operator ic/evil-write (&rest args)
    "When editing an org-src block `:w' should call `(org-edit-src-save)'."
    :motion nil
    :move-point nil
    :type line
    :repeat nil
    (interactive "<R><fsh><!>")
    (if (bound-and-true-p org-src-mode)
        (org-edit-src-save)
      (call-interactively 'evil-write args)))

  (evil-ex-define-cmd "w" 'ic/evil-write)
#+END_SRC

**** org-babel
Allow us to execute various languages in =org-src= blocks.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (shell . t)))
#+END_SRC

**** Agenda
***** Setup
#+BEGIN_SRC emacs-lisp
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(
          ;; work agenda
          ("w" "Work Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile/"
            ;;       ((org-agenda-overriding-header "Archive tasks:")
            ;;        (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            )
           ((org-agenda-tag-filter-preset '("-HOME"))))

          ;; home agenda
          ("h" "Home agenda"
           ((agenda ""
                    ((org-agenda-skip-function 'ic/skip-old-meal-plans)))
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile"
            ;;       ((org-agenda-overriding-header "\nArchive tasks:")
            ;;        (org-agenda-skip-function 'ic/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "\nNext Steps:")))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores-PRIORITY=\"A\"|jobs-PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))
                        ))
            (tags "+HOME"
                  ((org-agenda-overriding-header "\nStuck Projects")
                   (org-agenda-skip-function 'ic/org-skip-nonstuck-projects)
                   ))
            )
           ((org-agenda-tag-filter-preset '("+HOME"))))

          ;; archives
          ("a" . "Archiving")
          ("ah" "Home archive"
           ((tags "+HOME-noarchive/DONE|CANCELLED|APPLIED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ("aw" "Work archive"
           ((tags "-HOME-noarchive+TIMESTAMP_IA<=\"<-2w>\"/DONE|CANCELLED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ))
#+END_SRC

***** Appearance
#+BEGIN_SRC emacs-lisp
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)

  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)

  ;; show weekly agenda by default
  (setq org-agenda-span 'week)

  ;; don't have a separator between agenda sections
  (setq org-agenda-compact-blocks t)

  ;; show agenda icons
  (setq org-agenda-prefix-format "  %i %?-2 t%s")
#+END_SRC

***** Test icons (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disable
  ;;; DISABLED ;;;

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (setq tab-width 2)
  ;;                                         ; (setq tab-stop-list '(2 3 5))
  ;;             ))

  (require 'all-the-icons)

  ;; (let ((font (find-font (font-spec :name "FontAwesome"))))
  ;;   (font-put font :spacing 100)
  ;;   (font-get font :spacing)
  ;;   )

  (defun ic/org-agenda-icon (family icon-name)
    (let* ((icon-func (cdr (assoc family
                                  '((ati . all-the-icons-alltheicon)
                                    (faicon . all-the-icons-faicon)
                                    (fileicon . all-the-icons-fileicon)
                                    (octicon . all-the-icons-octicon)
                                    (wicon . all-the-icons-wicon)))))
           (face-func (cdr (assoc family
                                  '((ati . all-the-icons-icon-family)
                                    (faicon . all-the-icons-faicon-family)
                                    (fileicon . all-the-icons-fileicon-family)
                                    (octicon . all-the-icons-octicon-family)
                                    (wicon . all-the-icons-wicon-family)))))
           (all-the-icons-scale-factor 1.0)
           ;; (font (concat (apply face-func nil) ":spacing=monospace"))
           (font "FontAwesomeMono:spacing=100")
           ;; (font (apply face-func nil))
           (face `(:family ,font :height 1.0))
           ;; (icon (apply icon-func (list icon-name :face 'default)))
           (icon (cdr (assoc icon-name all-the-icons-data/fa-icon-alist)))
           )
      (propertize icon
                  'face face
                  'font-lock-face face
                  ;; 'display '(space :width (50) :height 7)
                  ;; 'display '(space-width 5)
                  'rear-nonsticky t
                  )
      ))

  ;; (ic/org-agenda-icon 'faicon "calendar")

  ;; (let ((icon (all-the-icons-faicon "calendar")))
  ;;   (string-to-char icon))

  ;; setup agenda icons
  (setq org-agenda-category-icon-alist
        (let ((icon-mapping
               '(
                 ("annivers" faicon "calendar")
                 ("birthdays" faicon "birthday-cake")
                 ("chores" faicon "home")
                 ("computer" faicon "keyboard-o")
                 ("cpu" faicon "fax")
                 ("holidays" faicon "calendar-o")
                 ("cooking" faicon "cutlery")
                 ("health" faicon "heartbeat")
                 ("jobs" faicon "building-o")
                 ("life" faicon "male")
                 )))
          (mapcar (lambda (config)
                    ;; `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)) :width (50)) nil nil :ascent center :mask heuristic))
                    `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)))))
                  icon-mapping
                  )))

  (defun blaenk/set-char-widths (alist)
    (while (char-table-parent char-width-table)
      (setq char-width-table (char-table-parent char-width-table)))
    (dolist (pair alist)
      (let ((width (car pair))
            (chars (cdr pair))
            (table (make-char-table nil)))
        (dolist (char chars)
          (set-char-table-range table char width))
        (optimize-char-table table)
        (set-char-table-parent table char-width-table)
        (setq char-width-table table))))

  (defconst old-char-width-table char-width-table)

  ;; argument is an alist of width and list of RANGEs,
  ;; which is the same as the RANGE that set-char-table-range accepts
  ;; (blaenk/set-char-widths
  ;;  `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;           ,(string-to-char (all-the-icons-faicon "home"))
  ;;           ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;           ))))

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (message "set-char-widths")
  ;;             (blaenk/set-char-widths
  ;;              `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;                       ,(string-to-char (all-the-icons-faicon "home"))
  ;;                       ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;                       ))))
  ;;                            ))




  ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping
  ;;              '(
  ;;                ("annivers" (all-the-icons-faicon "calendar"))
  ;;                ("birthdays" (all-the-icons-faicon "birthday-cake"))
  ;;                ("chores" (all-the-icons-faicon "home"))
  ;;                ("computer" (all-the-icons-faicon "keyboard-o"))
  ;;                ("cpu" (all-the-icons-faicon "fax"))
  ;;                ("holidays" (all-the-icons-faicon "calendar-o"))
  ;;                ("cooking" (all-the-icons-faicon "cutlery"))
  ;;                ("health" (all-the-icons-faicon "heartbeat"))
  ;;                ("jobs" (all-the-icons-faicon "building-o"))
  ;;                ("life" (all-the-icons-faicon "male"))
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (car config))
  ;;                         (icon (apply (caadr config) (cdadr config))))
  ;;                     `(,category (list ,icon :width (100)) nil nil :ascent center :mask heuristic :width (100))))
  ;;                 icon-mapping)))



  ;; ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping-alist
  ;;              '(
  ;;                ("annivers" 'faicon "calendar")
  ;;                ("birthdays" 'faicon "birthday-cake")
  ;;                ("chores" 'faicon "home")
  ;;                ("computer" 'faicon "keyboard-o")
  ;;                ("cpu" 'faicon "fax")
  ;;                ("holidays" 'faicon "calendar-o")
  ;;                ("cooking" 'faicon "cutlery")
  ;;                ("health" 'faicon "heartbeat")
  ;;                ("jobs" 'faicon "building-o")
  ;;                ("life" 'faicon "male")
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (first config))
  ;;                         (icon-family (second config))
  ;;                         (icon-name (third config))
  ;;                         (ati-family-alist
  ;;                          '(('ati . all-the-icons-alltheicon)
  ;;                            ('faicon . all-the-icons-faicon)
  ;;                            ('fileicon . all-the-icons-fileicon)
  ;;                            ('octicon . all-the-icons-octicon)
  ;;                            ('wicon . all-the-icons-wicon))))
  ;;                 `(,category (list ,(apply (cdr (assoc icon-family ati-family-alist)) (list icon-name :height 0.9 :v-adjust 0))) nil nil :ascent center :mask heuristic)))
  ;;                   icon-mapping-alist)))
#+END_SRC

***** Functions
****** Stuck Projects
I have a somewhat loose definition of what constitutes a project. I consider any org heading a project if:
- It has a todo state and none of it's ancestors do
- It has one or more immediate children with todo states

Furthermore I consider a stuck project:
- A project with no descendants having a NEXT todo state

#+BEGIN_SRC emacs-lisp
  (defun ic/org-is-active-task-p (&optional state)
    "Returns `t' if the current task is a member of
  `org-not-done-keywords'. When specified, use STATE as the active
  state, defaulting to `org-not-done-keywords'."
    (member (org-get-todo-state)
            (if state (list state) org-not-done-keywords)))

  (defun ic/org-any-active-parent-p ()
    "Return `t' if any parent task is an active task."
    (save-excursion
      (widen)
      (let (active-parent)
        (while (and (not active-parent)
                    (org-up-heading-safe))
          (when (ic/org-is-active-task-p)
            (setq active-parent t)))
        active-parent)))

  (defun ic/org-any-active-children-p (&optional state)
    "Return `t' when any descendant is an active task. When
    specified, use STATE as the active state, defaulting to
    `org-not-done-keywords'."
    (save-excursion
      (let ((subtree-end (save-excursion
                           (org-end-of-subtree t)))
            (child-regex (format "^\\*\\{%d,\\} "
                                 (+ 1 (org-current-level))))
            active-child)
        (while (and (not active-child)
                    (re-search-forward child-regex
                                       subtree-end t))
          (when (ic/org-is-active-task-p state)
            (setq active-child t)))
        active-child)))

  (defun ic/org-is-project-p ()
    "Return `t' when the current task is considered a project."
    (and (ic/org-is-active-task-p)
         (not (ic/org-any-active-parent-p))
         (ic/org-any-active-children-p)))

  (defun ic/org-is-stuck-project-p ()
    "Return `t' when the current task is considered a stuck
  project."
    (and (ic/org-is-project-p)
         (not (ic/org-any-active-children-p "NEXT"))))

  (defun ic/org-skip-nonstuck-projects ()
    (let ((debug-on-error t))
      (save-excursion
        (widen)
        (unless (ic/org-is-stuck-project-p)
          (or (outline-next-heading) (point-max))))))
#+END_SRC

**** Habits
#+BEGIN_SRC emacs-lisp
  (setq org-habit-preceding-days 5)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 1)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today nil)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC

**** Todo
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC

**** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC

**** Capture
***** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("r" "reply" entry (file org-default-notes-file)
           "* TODO Reply to %:from on %:subject\nSCHEDULED: %t\n%u\n%a\n"
           :immediate-finish t
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")))

  ;; start capture in insert mode
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

***** Full Frame
The standard =org-capture= behavior is to split the window before capturing a task. When this is started from outside emacs a random buffer occupies half the frame. What I want is the capture buffer to take the full frame when starting the capture from outside emacs. My window manager will start the capture task with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook where it splits the frame we'll need to advise it to ~(delete-other-windows)~ when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC

**** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disabled
  (require 'org-clock)

  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  ;; persist open clocks
  (setq org-clock-persist-file (concat user-cache-directory "org-clock-save.el"))
  (org-clock-persistence-insinuate)

  (defun ic/org-clock-jump-to-current-clock ()
    "Jump to the currently active clock."
    (interactive)
    ;; why isn't this (interactive) already, ugh
    (org-clock-jump-to-current-clock))
#+END_SRC

**** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
  ;; save id locations in a nicer place
  (setq org-id-locations-file (concat user-cache-directory "org-id-locations"))
#+END_SRC

**** Code Execution
Don't prompt for code execution if we're in a file in certain locations.

#+BEGIN_SRC emacs-lisp
  (defvar ic/allow-babel-evaluate-directories
        '("~/org" "~/.etc"))

  (defun ic/org-confirm-babel-evaluate (_lang _body)
    (let ((filename (buffer-file-name))
          match)
      (dolist (path ic/allow-babel-evaluate-directories (not match))
        (when (string-prefix-p (expand-file-name path) filename)
          (setq match t)))))

  (setq org-confirm-babel-evaluate #'ic/org-confirm-babel-evaluate)
#+END_SRC

**** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want to see most everything else.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC

**** Snippets
By convention I title most of my snippets ={snippet}>= so I would like the =>= key to try and expand snippets automatically. When no snippet is found a regular =>= should be entered.
#+BEGIN_SRC emacs-lisp
  (defun ic/yas-expand-> ()
    (interactive)
    (insert ">")
    (yas-expand))
#+END_SRC

Based on [[https://emacs.stackexchange.com/questions/29758/yasnippets-and-org-mode-yas-next-field-or-maybe-expand-does-not-expand][this]] stackexchange post =org-mode= binds the tab key in such a way that =yas-snippets= can't use it. So we need the following to allow =TAB= to expand snippets while in =org-mode=.
#+BEGIN_SRC emacs-lisp
  (defun ic/set-org-mode-tab-key ()
    (add-to-list 'org-tab-first-hook 'yas-expand)
    ;; XXX is this needed?
    ;; (general-define-key yas-keymap
    ;;   "<tab>" 'yas-next-field)
    )

  (add-hook 'org-mode-hook 'ic/set-org-mode-tab-key)
#+END_SRC

**** Weekly Review
#+BEGIN_SRC emacs-lisp
  (defvar ic/weekly-reviews-directory "~/org/home/weekly-reviews")

  (defun ic/org-completed-date (heading)
    "Return the date of completion for HEADING."
    (org-timestamp-format (org-element-property :closed heading)
                          "%s"))

  (defun ic/org-completed-date-< (heading-left heading-right)
    "Return non-nil when the completed date of HEADING-LEFT is earlier than the
  completed date of HEADING-RIGHT."
    (let ((left-ts (ic/org-completed-date heading-left))
          (right-ts (ic/org-completed-date heading-right)))
      (cond ((and left-ts right-ts)
             (string< left-ts right-ts))
            (left-ts t)
            (right-ts nil))))

  (defun ic/org-element-get-link (elem &optional link-title)
    "Get a link (as a string) to the org-element ELEM."
    (let* ((marker (org-element-property :org-marker elem))
           (level (org-element-property :level elem))
           (title (org-element-property :raw-value elem))
           (search (org-with-point-at marker
                     (org-link-heading-search-string)))
           (file (buffer-file-name (marker-buffer marker)))
           (link 
            (format "[[%s][%s]]"
                    (format "file:%s::%s" file search)
                    (or link-title title))))
      (set-text-properties 0 (length link) nil link)
      link))

  (defun ic/weekly-review-items ()
    "Return a string containing all items needed for the weekly review in a form
  for direct insertion into a `yasnippit'."
    (let ((org-files (seq-filter #'file-exists-p
                                 (mapcar #'expand-file-name org-agenda-files)))
          current-date)
      (mapconcat (lambda (heading)
                   (let* ((ts (org-element-property :closed heading))
                          (date (format "%s-%s-%s"
                                        (org-element-property :year-start ts)
                                        (org-element-property :month-start ts)
                                        (org-element-property :day-start ts)))
                          (link (ic/org-element-get-link heading)))
                     (concat
                      (when (not (equal current-date date))
                        (setq current-date date)
                        (format-time-string "%A, %d %B %Y\n"
                                            (org-timestamp-to-time ts)))
                      "- " link)))
                 (org-ql-select org-files
                   '(and (tags "HOME")
                         (not (tags "noarchive"))
                         (todo "DONE" "APPLIED"))
                   :action 'element-with-markers
                   :sort #'ic/org-completed-date-<)
                 "\n")))

  (defun ic/weekly-review ()
    "Create a weekly review `org-mode' buffer with all completed tasks."
    (interactive)
    (let* ((year (format-time-string "%Y"))
           (week (format-time-string "%U"))
           (directory (format "%s/%s" ic/weekly-reviews-directory year))
           (filename (format "%s/weekly-review-%s.org" directory week)))
      (unless (file-directory-p directory)
        (make-directory directory t))
      (when (or (not (file-exists-p filename))
                (yes-or-no-p (format "Weekly review for week %s of %s already exists. Delete and re-create? "
                                     week year)))
        (find-file filename)
        (erase-buffer)
        (org-mode)
        (yas-expand-snippet (yas-lookup-snippet "weekly review"))
        (save-buffer))))
#+END_SRC

**** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/skip-non-archivable-tasks ()
    "Skip tasks that I don't want to archive"
    (or (ic/skip-old-meal-plans)
        (bh/skip-non-archivable-tasks)))


  (defun ic/skip-old-meal-plans ()
    "Skip over a task if it's 1) a meal plan and 2) scheduled before today."
    (save-restriction
      (widen)
      (let* ((tags (org-get-tags))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (scheduled (org-get-scheduled-time (point)))
             (yesterday (* 60 60 24 1))
             ;; HACK we check 24 hours ago rather than previous midnight
             (now (time-subtract (current-time) (seconds-to-time yesterday))))
        (if (and (member "cooking" tags)
                 (member "plan" tags)
                 scheduled
                 (time-less-p scheduled now))
            subtree-end
          nil))))


  (defun ic/org-recipe-publish-to-html (_plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC

*** org-keybinds
:PROPERTIES:
:header-args: :noweb-ref org-keybinds :tangle no
:END:

**** local-leader
Main =local-leader= key binds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "'" 'org-edit-special
    ":" 'org-set-tags-command
    "^" 'org-sort
    "A" 'org-archive-subtree
    "D" 'org-insert-drawer
    "d" 'org-deadline
    "f" 'org-set-effort
    "H" 'org-shiftleft
    "J" 'org-shiftdown
    "K" 'org-shiftup
    "L" 'org-shiftright
    "l" 'org-open-at-point
    "N" 'widen
    "n" 'org-narrow-to-subtree
    "p" 'org-priority
    "P" 'org-set-property
    "r" 'org-refile
    "s" 'org-schedule
    "t" 'org-todo
    "w" 'org-save-all-org-buffers
    )
#+END_SRC

=,c= clocks keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "c"
    "" '(nil :which-key "clocks")
    "i" 'org-clock-in
    "j" 'ic/org-clock-jump-to-current-clock
    "o" 'org-clock-out
    "q" 'org-clock-cancel)
#+END_SRC

=,e= export keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "e"
    "" '(nil :which-key "export")
    "e" 'org-export-dispatch
    "T" 'org-babel-tangle-file
    "t" 'org-babel-tangle)
#+END_SRC

=,i= insert keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "i"
    "" '(nil :which-key "insert")
    "a" 'org-attach
    "f" 'org-footnote-new
    "l" 'org-insert-link
    "t" 'org-time-stamp
    "T" 'org-time-stamp-inactive
    "s" 'org-download-screenshot
    "y" 'org-download-yank
    )
#+END_SRC

TODO =,T= tables keybinds
#+BEGIN_SRC emacs-lisp

#+END_SRC

**** org-agenda-mode
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-agenda-mode-map
    "d" 'org-agenda-deadline
    "f" 'org-agenda-set-effort
    "p" 'org-agenda-priority
    "P" 'org-agenda-set-property
    "r" 'org-agenda-refile
    "s" 'org-agenda-schedule
    "t" 'org-agenda-todo
    "w" 'org-save-all-org-buffers
    )
#+END_SRC

**** org-src
=org-src-mode= bindings:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
      :definer 'minor-mode
      :states 'normal
      :keymaps 'org-src-mode
      ;; ,c has which-key information from "clocks"
      "c" '(org-edit-src-exit :which-key "org-edit-src-exit")
      "k" 'org-edit-src-abort
      )
#+END_SRC

**** leader-key
=leader-key= keybinds:
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "o"
    "" '(nil :which-key "org-mode")
    "j" 'ic/org-jump-in-buffer
    "J" 'ic/org-jump)

  (leader-keys
    :infix "oc"
    "" '(nil :which-key "clocks")
    "f" 'org-clock-modify-effort-estimate
    "i" 'org-clock-in
    "g" 'org-clock-goto
    "o" 'org-clock-out
    "l" 'org-clock-in-last
    "r" 'org-clock-report)
#+END_SRC

**** global
global keybinds:
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<f12>" 'org-agenda
   "M-<f12>" 'org-clock-goto)
#+END_SRC

**** normal mode
Here I have some custom normal mode navigation.
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states 'normal
    :keymaps 'org-mode-map

    "<left>"      'ic/outline-current-heading-or-up
    "<up>"        'ic/outline-current-heading-or-backward
    "<down>"      'org-forward-heading-same-level
    "<right>"     'outline-next-visible-heading

    "S-<left>"    'org-promote-subtree
    "S-<up>"      'org-move-subtree-up
    "S-<down>"    'org-move-subtree-down
    "S-<right>"   'org-demote-subtree

    "C-S-<left>"  'org-do-promote
    "C-S-<right>" 'org-do-demote
    )
#+END_SRC

**** insert mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
      :states 'insert
      :keymaps 'org-mode-map
      ">" 'ic/yas-expand->)
#+END_SRC

** org-bullets
Let's have some fancy heading bullets.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("•"))
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-caldav
I want my google calendar sync'd with =org-mode=.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org-caldav
    :after oauth2
    :ensure t
    :config
    <<org-caldav-config>>
    :general
    <<org-caldav-keybinds>>
  )
#+END_SRC

*** org-caldav-config
:PROPERTIES:
:header-args: :noweb-ref org-caldav-config :tangle no
:END:

Some basic =org-icalendar= setup. Add my timezone, and use scheduled time for event times as much as possible.
#+BEGIN_SRC emacs-lisp
  (setq org-icalendar-timezone "America/Los_Angeles")
  (setq org-icalendar-use-scheduled '(event-if-todo event-if-not-todo))
  (setq org-icalendar-use-deadline '(todo-due))
#+END_SRC

=epa-pinentry-mode= let's us talk with =gpg= from the minibuffer. =plstore-cache-passphrase-for-symmetric-encryption= is so that we only need to enter the store password once (for the life of emacs). I should probably populate the secure plist from my secrets files someday.
#+BEGIN_SRC emacs-lisp
  ;; needed for gpg
  (setf epa-pinentry-mode 'loopback)
  ;; needed to shutup secure plstore
  (setq plstore-cache-passphrase-for-symmetric-encryption t)
#+END_SRC

I currently have my calendar on google, so setup some basic authentication.
#+BEGIN_SRC emacs-lisp
  (setq org-caldav-url 'google)
  (setq org-caldav-oauth2-client-id
        (ic/get-secret "calendar.personal.clientid"))
  (setq org-caldav-oauth2-client-secret
        (ic/get-secret "calendar.personal.secret"))
#+END_SRC

Now the calendar setup.
#+BEGIN_SRC emacs-lisp
  ;; don't use a built in calendar
  (setq org-caldav-inbox nil)
  (setq org-caldav-files nil)

  (setq org-caldav-calendars
        `((:calendar-id ,(ic/get-secret "calendar.personal.main-id")
                        :inbox "~/org/inbox.org"
                        :files ("~/org/home/home.org"
                                "~/org/home/home.org_archive"
                                "~/org/home/historical-calendar.org"))
          (:calendar-id ,(ic/get-secret "calendar.personal.birthdays-id")
                        :inbox "~/org/home/birthdays.org")))
#+END_SRC

For me, =org= data takes precedence over google. So I want events that are removed from =org-mode= to be silently deleted from google, but events removed in google to be prompted prior to removal from =org-mode=.
#+BEGIN_SRC emacs-lisp
  (setq org-caldav-delete-calendar-entries 'always)
  (setq org-caldav-delete-org-entries 'ask)
  (setq org-caldav-sync-changes-to-org 'title-and-timestamp)
#+END_SRC

Only sync items with =cal= tag.
#+BEGIN_SRC emacs-lisp
  (setq org-caldav-select-tags '("cal"))
#+END_SRC

Keep backup and cache files in a sane location.
#+BEGIN_SRC emacs-lisp
  (setq org-caldav-backup-file (concat user-cache-directory "org-caldav-backup.org"))
  (setq org-caldav-save-directory user-cache-directory)
#+END_SRC

Now, for the dumb stuff.

=org-icalendar= prepends certain strings to each event summary (title). It adds ="S: "= before scheduled events, and ="DL: "= for deadline events. This is bizarre, so strip those out before sending to google.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-icalendar-remove-title-junk (orig-fun &rest args)
    "Remove \"S: \" and \"DL: \" from the start of calendar event titles."
    (setf (nth 3 args)
          (replace-regexp-in-string (rx bol (or "S: " "DL: ")) "" (nth 3 args)))
    (apply orig-fun args))

  (advice-add 'org-icalendar--vevent :around #'ic/org-icalendar-remove-title-junk)
#+END_SRC

*** org-caldav-keybinds
:PROPERTIES:
:header-args: :noweb-ref org-caldav-keybinds :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "ec" 'org-caldav-sync)
#+END_SRC

** org-msg
=org-msg= let's us compose html email.

#+BEGIN_SRC emacs-lisp
  (use-package org-msg
    :config
    (setq org-msg-default-alternatives
          '((new           . (text html))
            (reply-to-html . (text html))
            (reply-to-text . (text))))
    )
#+END_SRC

** org-ql
Let's try having a nice search interface for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package org-ql)
#+END_SRC

** TODO projectile
=projectile= makes it easy to perform actions on a project, like grepping or listing relevant files or running tests/compiling. It also keeps buffers grouped by project so navigating between them is pleasant inside a project.

One thing I wish it did was restore the window layout when opening a project. I've tried to use =persp-mode= for that, but it's heavy-weight and difficult to configure for my use. The author's =persp-mode-projectile-bridge= package has some design choices I don't care for. Such as prefixing perspectives with =[p]= (configurable at least), and /setting the window config to not permit saving to disk/ (huh?).

All I want is to restore the window layout, as best as possible, to as close as it was to the previous time I visited the project. Luckily, emacs has a couple of functions to save/restore the window configuration builtin.

So, we can save the window configuration when either moving to a new project or closing emacs, then we can load the new project's layout. When loading, any buffer that is a part of the window configuration, but not active will cause that window to not load. So we need to make sure we re-visit any buffers that were active when that configuration was saved.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package projectile
    :demand t
    :init
    ;; ensure projectile saves its files in a nice location
    (setq projectile-cache-file
          (concat user-cache-directory "projectile.cache"))
    (setq projectile-known-projects-file
          (concat user-cache-directory "projectile-bookmarks.eld"))
    ;; ensure we save window config files in a nice location
    (defvar ic/projectile-window-default-name "default")
    (defvar ic/projectile-window-save-dir
      (concat user-cache-directory "projectile-windows/"))

    :config
    <<projectile-config>>

    :hook
    ;; we want to save window config when switching projects and closing emacs
    ((kill-emacs projectile-before-switch-project) . #'ic/projectile-window-save-layout)

    :general
    ;; XXX
    (leader-keys
      "p" 'projectile-command-map)
    )
#+END_SRC

*** projectile-config
:PROPERTIES:
:header-args: :noweb-ref projectile-config :tangle no
:END:

We need a couple of functions to walk through the window state data structure as returned by =(window-state-get)=. Shamelessly stolen from [[https://depp.brause.cc/eyebrowse/][eyebrowse]].
#+BEGIN_SRC emacs-lisp
  ;; eyebrowse functions taken from: https://depp.brause.cc/eyebrowse/
  (defun eyebrowse--dotted-list-p (list)
    "Non-nil if LIST is terminated by a non-nil value."
    (cdr (last list)))

  (defun eyebrowse--walk-window-config (window-config function)
    "Walk through WINDOW-CONFIG and apply FUNCTION to each leaf."
    (dolist (item window-config)
      (when (consp item)
        (when (symbolp (car item))
          (funcall function item))
        (when (and (consp (cdr item))
                   (not (eyebrowse--dotted-list-p (cdr item))))
          (eyebrowse--walk-window-config (cdr item) function)))))
#+END_SRC

Next, a couple functions to walk through the window state data structure. The first, will replace any buffers that are in the (loading) window state, but are not active are replace with the =*scratch*= buffer. This is because when emacs encounters a buffer that is in the window state, but is not active that window is not loaded. I at least want a window restored, so replace the buffer with something harmless.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--replace-dead-buffers (layout)
    "Replace any unloadable buffers in LAYOUT with *scratch*."
    (let ((replaced-buffers '()))
      (eyebrowse--walk-window-config
       layout
       (lambda (item)
         (when (eq 'buffer (car item))
           (let ((buffer-name (cadr item)))
             (unless (get-buffer buffer-name)
                 (add-to-list 'replaced-buffers buffer-name)
                 (message "Replaced %s buffer with *scratch*" buffer-name)
                 (setf (cadr item) "*scratch*"))))))
      (when replaced-buffers
        (let ((n (length replaced-buffers)))
          (message "Unable to restore %d buffer%s: %s"
                   n
                   (if (> n 1) "s" "")
                   (s-join ", " replaced-buffers))))))
#+END_SRC

The next function will return a list of full paths for any visible buffer (i.e. it exists in the window state) that is visiting a file. We want to save these paths along with the window state so that we can restore the buffers upon loading.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--full-buffer-paths (layout)
    "Return a list of full paths for any visible buffer in LAYOUT
  visiting a file."
    (let ((full-paths '()))
      (eyebrowse--walk-window-config
       layout
       (lambda (item)
         (when (eq 'buffer (car item))
           (when-let ((buffer (get-buffer (cadr item))))
             (when-let ((path (buffer-file-name buffer)))
               (add-to-list 'full-paths path))))))
      full-paths))
#+END_SRC

A helper function to return the filename of where we should store the project's window state.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--get-filename ()
    "Return the filename for the active project."
    (let ((project (and projectile-mode
                        (projectile-project-name))))
      (concat ic/projectile-window-save-dir
              (or project ic/projectile-window-default-name))))
#+END_SRC

Finally the pair of function to save/restore the window state. Here we store a cons cell of the format =(<full paths of active buffers> . <window state>)= in the file specified by =ic/projectile-window--get-filename=. When loading, we ensure we visit any files listed and then restore the window state.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window-save-layout ()
    "Save the active window's layout to disk. The filename is based
  on the active `projectile' project."
    (interactive)
    ;; make parent directory, if needed
    (unless (file-directory-p ic/projectile-window-save-dir)
      (make-directory ic/projectile-window-save-dir t))
    (let* ((layout (window-state-get nil t))
           (paths (ic/projectile-window--full-buffer-paths layout))
           (filename (ic/projectile-window--get-filename)))
      (with-temp-file filename
        (insert (prin1-to-string
                 (cons paths layout))))))

  (defun ic/projectile-window-load-layout ()
    "Restore the current `projectile' project's window layout from
  disk."
    (interactive)
    (let ((filename (ic/projectile-window--get-filename))
          (project (or (and projectile-mode (projectile-project-name))
                       ic/projectile-window-default-name)))
      (if (file-exists-p filename)
          (with-temp-buffer
            (insert-file-contents-literally filename)
            (let* ((data (read (current-buffer)))
                   (paths (car data))
                   (layout (cdr data)))
              ;; ensure known files are loaded
              (mapc #'find-file paths)
              ;; and any buffers not know are replaced with *scratch*
              (ic/projectile-window--replace-dead-buffers layout)
              ;; ensure we start from a single window
              (delete-other-windows)
              ;; and restore what we had
              (window-state-put layout (frame-root-window) 'safe)
              t))
        (message "No layout found for '%s' project" project)
        nil)))
#+END_SRC

When we open a new project =projectile= will call =projectile-switch-project-action=, by default it's bound to =projectile-find-file=. If we were able to load a saved layout then we already have open buffers. So we only need to prompt for a file if this is a new project (i.e. no layout found).
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--find-file-maybe ()
    "Call `projectile-find-file' if we couldn't load a window config,
  do nothing if we did."
    (interactive)
    (unless (ic/projectile-window-load-layout)
      (call-interactively 'projectile-find-file)
      (delete-other-windows)))

  (setq projectile-switch-project-action 'ic/projectile-window--find-file-maybe)
#+END_SRC

Now we can finally enable =projectile=.
#+BEGIN_SRC emacs-lisp
  (projectile-mode 1)
#+END_SRC

*** TODO save layout when =find-file='ing away 

** smartparens
Keep my toe-nail clippings in balance.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :demand t
    :config
    (require 'smartparens-config)
    (smartparens-global-strict-mode 1)
    ;; don't run smartparens in the minibuffer
    (add-hook 'minibuffer-mode-hook 'turn-off-smartparens-strict-mode)

    :general
    (general-define-key
     :keymaps '(emacs-lisp-mode-map list-interaction-mode-map)
     :states '(normal motion)
     "^" #'sp-backward-up-sexp))
#+END_SRC

** spaceline
I want a pretty mode-line. Note: most of the configuration happens in the =spaceline-all-the-icons= package.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
      :config
      ;; use a custom mode-line while in helm
      (spaceline-helm-mode 1)

      ;; use pretty separators
      (setq powerline-default-separator 'contour)

      ;; change face based on evil state
      (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)
      )
#+END_SRC

** spaceline-all-the-icons
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package spaceline-all-the-icons
      :after (all-the-icons spaceline)
      :config
      <<spaceline-ati-config>>
      )
#+END_SRC

*** spaceline-ati-config
:PROPERTIES:
:header-args: :noweb-ref spaceline-ati-config :tangle no
:END:

By default =all-the-icons= returns an object without an =:inherit= property. You can pass a face to inherit from, but can't specify a bare =:inherit=. This has the issue where an icon has the wrong background color based on which section of the modeline it occupies. So we need a function that will both apply a bare =:inherit= property along with some default scaling values.
#+BEGIN_SRC emacs-lisp
  (defun ic/icon (name &optional group)
    (setf group (or group 'alltheicon))
    (let* ((icon (funcall (intern (format "all-the-icons-%s" group))
                          name))
           (family (plist-get (plist-get (text-properties-at 0 icon)
                                         'face)
                              :family))
           (face `(:family ,family :inherit)))
      (propertize icon 'face face 'font-lock-face face 'display '(raise 0.1))))
#+END_SRC

For the version control segment I would like the see the git icon along with the current file's status if we're in the master branch. If we're in a non-master branch I want to see the git branch icon along with the branch name and current file's status.
#+BEGIN_SRC emacs-lisp
  (defun ic//vc-icon-git ()
    (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
           ;; (project-name (second (nreverse (split-string (projectile-project-root) "/"))))
           (vc-state-icon (pcase (vc-state (buffer-file-name))
                            ('up-to-date "-")
                            ('edited "*")
                            ('added "^")
                            ('removed' "v")
                            ('conflict "!")
                            ('missing "m")
                            ('ignored "i")
                            ('unregistered "x")
                            (_ "?")))
           (branch-icon (if (string= branch "master")
                            (ic/icon "git")
                          (concat
                           (ic/icon "git-branch" 'octicon)
                           " "
                           branch))))
      (concat vc-state-icon " " branch-icon)))

  (spaceline-define-segment
      ic-vc-icon "A segment for the Version Control icon"
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode) (ic//vc-icon-git))
              (t (propertize (format "%s" vc-mode))))))
#+END_SRC

I want to see when our current =projectile= differs from the active =persp-mode= perspective. This shouldn't happen, but I am seeing it when first getting the two to work together.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-project-name "A segment for the active projectile project."
      (let ((project (projectile-project-name))
            (persp (safe-persp-name (get-frame-persp))))
        (if (equal project persp)
            project
          (concat project "|" persp))))
#+END_SRC

Set the mode line.
#+BEGIN_SRC emacs-lisp
  ;; bring in bundled segments
  (require 'spaceline-segments)

  ;; and define our custom mode-line
  (spaceline-compile
   'main
   ;; left side
   '((window-number
      :priority 100
      :fallback evil-state
      :face highlight-face)
     ((buffer-modified
       all-the-icons-mode-icon
       remote-host)
      :priority 95)
     ((buffer-id)
       :priority 96)
     ((anzu
       selection-info)
      :priority 90)
     ((flycheck-error
       flycheck-warning
       flycheck-info)
      :priority 85)
     process)

   ;; right side
   '(((org-clock) :when active)
     ((ic-vc-icon)
      :priority 87)
     all-the-icons-git-status
     ;; XXX (projectile-root) is really slow outside a project
     ;; (projectile-root)
     ;; ((buffer-encoding-abbrev buffer-size
     ;;   input-method)
     ;;  :priority 5)
     (buffer-position
      :priority 91)))

  ;; and enable it
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
#+END_SRC

=mode-line-format= is buffer-local and there are some buffers that have set it prior to us generating the mode-line, so we need to reset their values:
#+BEGIN_SRC emacs-lisp
  (save-excursion
    (dolist (name '("*Messages*" "*scratch*" "*straight-process*"))
      (if-let ((buffer (get-buffer name)))
          (with-current-buffer buffer
            (setq mode-line-format (default-toplevel-value 'mode-line-format))))))
#+END_SRC

** visual-fill-column
I want emacs to wrap long lines automatically and refill when modifying text. =visual-fill-column= does just that.
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :init (setq-default fill-column 80)
    :hook (visual-line-mode . visual-fill-column-mode))
#+END_SRC

** wgrep
=wgrep= is a package that let's us live edit a =helm-occur= buffer.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :init
    (add-hook 'helm-occur-mode-hook #'wgrep-change-to-wgrep-mode))
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
      :config
      (which-key-mode 1))
#+END_SRC

** winum
For numbering and jumping to windows.
#+BEGIN_SRC emacs-lisp
  (use-package winum
      :demand t
      :config
      ;; I want frames numbered only within a frame, not globally
      (setq winum-scope 'frame-local)
      ;; spaceline handles window numbers
      (setq winum-auto-setup-mode-line nil)
      (winum-mode)

      (defun ic/winum-delete-window-0-or-10 (&optional _arg)
        "Delete window 0 if assigned or 10 if exists."
        (interactive "P")
        (winum-select-window-0-or-10 '(4)))

      (defmacro defun-ic--winum-delete-window-num (n)
        "Create function for calling `winum-select-window-by-number'
  so that it kills window N."
        `(defun ,(intern (format "ic/winum-delete-window-%d" n)) (&optional _arg)
           ,(format "Delete window %d." n)
           (interactive "P")
           (winum-select-window-by-number ,(- n))))

      (defun-ic--winum-delete-window-num 1)
      (defun-ic--winum-delete-window-num 2)
      (defun-ic--winum-delete-window-num 3)
      (defun-ic--winum-delete-window-num 4)
      (defun-ic--winum-delete-window-num 5)
      (defun-ic--winum-delete-window-num 6)
      (defun-ic--winum-delete-window-num 7)
      (defun-ic--winum-delete-window-num 8)
      (defun-ic--winum-delete-window-num 9)

      :general
      (leader-keys
       "0" '(winum-select-window-0-or-10 :which-key ("0..9" . "winum-window 0..9"))
       "1" '(winum-select-window-1 :which-key t)
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t)
       "C-0" '(ic/winum-delete-window-0-or-10 :which-key ("C-0..9" . "ic/winum-delete-window 0..9"))
       "C-1" '(ic/winum-delete-window-1 :which-key t)
       "C-2" '(ic/winum-delete-window-2 :which-key t)
       "C-3" '(ic/winum-delete-window-3 :which-key t)
       "C-4" '(ic/winum-delete-window-4 :which-key t)
       "C-5" '(ic/winum-delete-window-5 :which-key t)
       "C-6" '(ic/winum-delete-window-6 :which-key t)
       "C-7" '(ic/winum-delete-window-7 :which-key t)
       "C-8" '(ic/winum-delete-window-8 :which-key t)
       "C-9" '(ic/winum-delete-window-9 :which-key t)
       )
      )
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :demand t
    )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :init
      (setq yas-snippet-dirs (list (concat user-data-directory "snippets")))
      (yas-global-mode 1))
#+END_SRC

* Modes
** info-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

** lisp-mode
Setup tab width.
#+BEGIN_SRC emacs-lisp
  (defun ic/lisp-mode-setup ()
    (setq indent-tabs-mode nil)
    (setq tab-width 8)
    (setq lisp-indent-function 'common-lisp-indent-function))

  (add-hook 'lisp-mode-hook #'ic/lisp-mode-setup)
#+END_SRC

Some useful functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/eval-outer-sexp-dwim ()
    "Evaluate the outermost sexp at POINT, stopping at any (def*) found."
    (interactive)
    (save-excursion
      (condition-case nil
          ;; move up as much as possible
          (while (not (looking-at "(def"))
            (up-list -1 t))
        (error nil))
      ;; are we on a left paren?
      (if (eq ?\( (following-char))
          (progn
            ;; move to the end
            (forward-sexp)
            ;; and evaluate
            (call-interactively 'eval-last-sexp))
        (message "Cannot evaluate: not inside an sexp"))))

  (defun ic/eval-enclosing-sexp ()
    "Evaluate the sexp enclosing POINT."
    (interactive)
    (save-excursion
      (condition-case nil
          (progn
            (up-list -1 t)
            (forward-sexp)
            (backward-char))
        (error
         (message "Cannot evaluate: not inside an sexp"))
        (:success
         (call-interactively 'eval-last-sexp)))))
#+END_SRC

Setup keybinds
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "e" '(ic/eval-enclosing-sexp :which-key "ic/eval-enclosing-sexp")
    "E" 'ic/eval-outer-sexp-dwim
    "B" 'eval-buffer
    "M" 'emacs-lisp-macroexpand
    )
#+END_SRC

** prog-mode
#+BEGIN_SRC emacs-lisp
  (defun ic/prog-mode-setup ()
    (flyspell-prog-mode)
    (auto-fill-mode)
    (company-mode 1)
    (setq indent-tabs-mode nil)
    (setq tab-width 4))
  (add-hook 'prog-mode-hook #'ic/prog-mode-setup)
#+END_SRC

** python-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'python))

  (defun ic/python-mode-setup ()
    (setq python-indent-offset tab-width)
    (lsp))

  (add-hook 'python-mode-hook #'ic/python-mode-setup)
#+END_SRC

** text-mode
Let's have automatic spell checking for text heavy buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

** winner-mode
I like being able to undo/redo window changes.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

* Misc
** Misc cruft
Turn off some default emacs settings I don't like, such as the menu bar, scroll
bar, etc.

#+BEGIN_SRC emacs-lisp
  ;; disable unwanted UI elements
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  ;; static cursor
  (blink-cursor-mode -1)

  ;; don't show the initial emacs screen
  (setq inhibit-startup-screen t)
  ;; start in the *Messages* buffer
  (setq initial-buffer-choice (lambda () (get-buffer "*Messages*")))
  ;; let me use y/n in prompts
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** user-emacs-directory
Try and keep the =user-emacs-directory= somewhat clean.
#+BEGIN_SRC emacs-lisp
  ;; cache/ directory
  (setq recentf-save-file (concat user-cache-directory "recentf"))
  (setq transient-history-file (concat user-cache-directory "transient-history.el"))
  (setq bookmark-default-file (concat user-cache-directory "bookmarks"))
  (setq tramp-persistency-file-name (concat user-cache-directory "tramp"))

  ;; cache/{backups,auto-saves}
  (let ((backup-dir (concat user-cache-directory "backups/"))
        (autosave-dir (concat user-cache-directory "auto-saves/")))
    ;; create directories if needed
    (dolist (path (list backup-dir autosave-dir))
      (unless (file-directory-p path)
        (make-directory path t)))
    (setq backup-directory-alist `((".*" . ,backup-dir)))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq auto-save-list-file-prefix (concat autosave-dir "saves-"))
    (setq tramp-backup-directory-alist `((".*" ,backup-dir)))
    (setq tramp-auto-save-directory autosave-dir))

  ;; data/ directory
  (setq abbrev-file-name (concat user-data-directory "abbrev"))
#+END_SRC

** Buffers
Some useful buffer related functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/yank-buffer-to-clipboard ()
    "Yank contents of current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun ic/paste-clipboard-to-buffer ()
    "Overwrite the current buffer with the clipboard contents."
    (interactive)
    (when (yes-or-no-p "Overwrite current buffer with clipboard?")
      (widen)
      (erase-buffer)
      (clipboard-yank)))

  (defun ic/yank-current-filename ()
    "Yank the full filename of the currently active buffer. Return
  `nil' if no underlying file."
    (interactive)
    (let ((filename (or (buffer-file-name) "nil")))
      (kill-new filename)
      (message filename)))

  (defun ic/switch-to-scratch-buffer ()
    "Switch to the `*scratch*' buffer."
    (interactive)
    (switch-to-buffer (startup--get-buffer-create-scratch)))
#+END_SRC

** display-buffer configuration
#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
          ;; display help windows on the right
          ("^\\*\\(Help\\|info\\)"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . right)
           (slot . 1)
           (window-width . 80)
           (reusable-frames . nil))

          ;; display compile errors on the bottom
          ("^\\*\\(Compile\\|Backtrace\\)"
           (display-buffer-reuse-window display-buffer-at-bottom)
           (window-width . 0.5)
           (window-height . 15)
           (reusable-frames . nil))

          ;; display magit windows on the left
          ("^magit:"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . left)
           (slot . 1)
           (window-width . 80)
           (window-height . 1.0)
           (reusable-frames . nil))
          ))
#+END_SRC

** Customize
I don't like =customize= so discard all settings.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat (temporary-file-directory) "emacs-customize-settings"))
#+END_SRC

** Tab Width
Use 4 spaces by default for tabs. Note: these are commonly overwritten in mode hooks.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].

#+BEGIN_SRC emacs-lisp
  (defun ic/save-and-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (save-buffer)
    (ic/kill-buffer-and-window))

  (defun ic/maybe-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (save-buffers-kill-emacs)))

  (defun ic/kill-buffer-and-window ()
    "Destroy the current buffer and window, if it was the sole window also delete
  the frame."
    (interactive)
    (condition-case-unless-debug nil
        (kill-buffer-and-window)
      (error
       (spacemacs/frame-killer))))

  ;; from spacemacs
  (defun spacemacs/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error
       (make-frame-invisible nil 1))))
#+END_SRC

Set evil ex commands:
#+BEGIN_SRC emacs-lisp
  (evil-ex-define-cmd "q[uit]" 'ic/kill-buffer-and-window)
  (evil-ex-define-cmd "wq" 'ic/save-and-kill-buffer-and-window)
#+END_SRC

And some =leader-key= bindings:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "q"
   "" '(nil :which-key "quit")
   "q" 'spacemacs/frame-killer
   "Q" 'ic/maybe-kill-emacs)
#+END_SRC

** Frame title
Set the frame title to something meaningful.

#+BEGIN_SRC emacs-lisp
  (defun ic/short-persp-name ()
    "Return a shortened name for currently active perspective. Returns `nil'
  when `persp-mode' not enabled."
    ;; we guard calls to `get-frame-persp' and `safe-persp-name' behind a
    ;; check for `\'persp-mode' so shutup the compiler about unknown functions.
    (eval-when-compile
      (unless (fboundp 'get-frame-persp)
        (defun get-frame-persp ()))
      (unless (fboundp 'safe-persp-name)
        (defun safe-persp-name (_))))
    (when (and (boundp 'persp-mode) (get-frame-persp))
      (let ((name (safe-persp-name (get-frame-persp))))
        (concat " <"
                (if (file-directory-p name)
                    (file-name-nondirectory (directory-file-name name))
                  name)
                "> "))))

  (setq frame-title-format
        '((:eval (buffer-name (window-buffer (minibuffer-selected-window))))
          (:eval (ic/short-persp-name))))
#+END_SRC

** Spelling
When typing in insert mode I want to hit =C-e= to automatically correct the previous misspelled word.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(insert normal)
   "C-e" #'flyspell-auto-correct-previous-word)
#+END_SRC

** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of the re-display code so can run only when needed. Lisp implementations such as =linum= and =nlinum= have to run over an entire window as they can't know which part of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain text-heavy modes.
#+BEGIN_SRC emacs-lisp
  (global-linum-mode -1)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp
  ;; use lines displayed on screen rather than new line characters; so folds work
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 3 ...
  (setq-default display-line-numbers-width 3)
  ;; ... and allow it to shrink :(
  (setq-default display-line-numbers-grow-only nil)
#+END_SRC

I would really like to set =display-line-numbers-grow-only= to =t= so that it only grows and prevents shrinkage, but it seems there is a significant performance cost associated with it. I've increased the default width slightly to offset it, but that will waste a bit more space on small files.

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like =linum-mode=, instead it uses the =text-area= where the main buffer text is. This means that anything in the fringe (=display-margin=) now shows up to the left of the line numbers. I'm not a fan of that, but I guess I'll live with it as there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of =display-line-numbers= for more info.

** Web Browser
=firefox=, duh.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program "firefox")
#+END_SRC

** Minibuffer / completion testing (disabled)
:PROPERTIES:
:header-args: :tangle no
:END:

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (defun ic/ignore-marginalia-annotate-binding (&_))
    (advice-add 'marginalia-annotate-binding :override 'ic/ignore-marginalia-annotate-binding)
    (marginalia-mode 1)
    )

#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    ;; (add-to-list 'display-buffer-alist
    ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
    ;;                nil
    ;;                (window-parameters (mode-line-format . none))))

    (add-hook 'embark-post-action-hook #'embark-collect--update-linked)
    ;; (remove-hook 'embark-post-action-hook #'embark-collect--update-linked)

    (add-hook 'minibuffer-setup-hook #'embark-collect-completions)
    ;; (remove-hook 'minibuffer-setup-hook #'embark-collect-completions)

    (defun ic/embark-act-noexit ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'embark-act)))

    :general
    (leader-keys
      "hdb" 'embark-bindings)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-," 'embark-act
     "C-<" 'ic/embark-act-noexit
     "C-." 'embark-become)
    )

#+END_SRC

*** Minibuffer
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'minibuffer-local-map
   "C-w" 'evil-delete-backward-word)

#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :config
    ;; use TAB for previewing
    (setq consult-preview-key (kbd "<tab>"))
    (setq consult-narrow-key "<")

    (defun ic/consult-unfocus-lines ()
      "Reset any current focus from `consult-focus-lines'."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-focus-lines)))

    :general
    (leader-keys
      "bb" 'consult-buffer
      "fb" 'consult-bookmark
      "pi" 'consult-project-imenu
      "ha" 'consult-apropos
      "sf" 'consult-find
      "sL" 'consult-locate
      "sg" 'consult-grep
      "sG" 'consult-git-grep
      "sm" 'consult-multi-occur
      "sr" 'consult-ripgrep
      "su" 'consult-focus-lines
      "sU" 'ic/consult-unfocus-lines
      )

    (general-define-key
     :states '(normal)
     "go" 'consult-outline
     "gh" 'consult-org-heading
     "gi" 'consult-imenu
     "gl" 'consult-line
     )

    )

#+END_SRC

*** Selectrum (not used)
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand nil
    :after (orderless embark)
    :config
    (selectrum-mode 1)

    ;; window should be exactly 20 lines always
    (setq selectrum-max-window-height 20)
    (setq selectrum-fix-vertical-window-height selectrum-max-window-height)

    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (setq selectrum-refine-candidates-function #'orderless-filter)

    ;; when we have an embark collect: only show the current selectrum item
    (defun ic/single-line-selectrum ()
      (when (eq embark-collect--kind :live)
        (with-selected-window (active-minibuffer-window)
          (setq-local selectrum-num-candidates-displayed 1)
          (setq-local selectrum-display-style
                      '(horizontal :before-candidates "[" :after-candidates "]"
                                   :more-candidates "" :candidates-separator "")))))
    (add-hook 'embark-collect-mode-hook #'ic/single-line-selectrum)

    ;; selectrum should have a decoration-less window on the bottom
    (setq selectrum-display-action '(display-buffer-in-side-window
                                     (side . bottom)
                                     (slot . -1)
                                     (window-parameters (mode-line-format . none))))
    )
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t
    :demand t
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :config
    (defun ic/orderless-bang-prefix (pattern _index _total)
      (when (string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))

    (defun ic/orderless-bang-suffix (pattern _index _total)
      (when (string-suffix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 0 -1))))

    (defun ic/orderless-carrot-suffix (pattern _index _total)
      (when (string-suffix-p "^" pattern)
        `(orderless-regexp . ,(concat "^" (substring pattern 0 -1)))))

    (setq completion-styles '(orderless))
    (setq orderless-matching-styles '(orderless-regexp))
    (setq orderless-style-dispatchers '(ic/orderless-bang-prefix
                                        ic/orderless-bang-suffix
                                        ic/orderless-carrot-suffix))
    )
#+END_SRC

** Movement
Some misc functions to support moving around.

#+BEGIN_SRC emacs-lisp
  (defun ic/move-to-outline-dwim ()
    "Prompt for, and move to, an outline heading."
    (interactive)
    (cond ((eq major-mode 'org-mode)
           (ic/org-jump-in-buffer))
          (t
           (message (format "No outline command found for mode `%s'" major-mode)))))
#+END_SRC

** Garbage Collection
I have problems typing in =org-mode= documents with the default garbage collector settings. So let's give the GC 100mb to work with and call it when emacs is idle.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 (expt 2 20)))
  (setq gc-cons-percentage 0.5)
  (run-with-idle-timer 5 t #'garbage-collect)
  (setq garbage-collection-messages nil)
#+END_SRC

** Shell replace
I'd like a way to call =shell-command-on-region= and have it replace the current region without using a prefix arg.

#+BEGIN_SRC emacs-lisp
  (defun ic/shell-command-on-region-replace ()
    "Call `shell-command-on-region' with prefix arg set."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'shell-command-on-region)))
#+END_SRC

* Keybindings
Here we copy the spacemacs keybindings, more or less.

** main
#+BEGIN_SRC emacs-lisp
  (leader-keys
    "|" 'ic/shell-command-on-region-replace
    "C-|" 'shell-command-on-region
    "TAB" 'evil-switch-to-windows-last-buffer
    "u" 'universal-argument)
#+END_SRC

** normal mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal)
   :keymaps 'general-override-mode-map
   "go" 'ic/move-to-outline-dwim
   "gl" 'helm-occur)
#+END_SRC

** Escape Key
Make  =<escape>= quit as much as possible.

XXX should these go in an override map?

#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map
                 minibuffer-local-must-match-map
                 minibuffer-local-isearch-map)
      "<escape>" 'keyboard-escape-quit)
#+END_SRC

** a :: applications

** b :: buffers
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "b"
   "" '(nil :which-key "buffers")
   "b" 'ic/helm-buffers
   "B" 'helm-mini
   "d" 'kill-this-buffer
   "i" 'ic/projectile-ibuffer
   "I" 'ibuffer
   "P" 'ic/paste-clipboard-to-buffer
   "R" 'revert-buffer
   "s" 'ic/switch-to-scratch-buffer
   "w" 'read-only-mode
   "Y" 'ic/yank-buffer-to-clipboard)
#+END_SRC

** B :: build

** e :: errors

** E :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys "E" '(nil :which-key "emacs"))
#+END_SRC

** Ep :: Emacs profiler
Profiler bindings.
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "Ep"
   "" '(nil :which-key "emacs profiler")
   "c" #'ic/start-cpu-profiler
   "m" #'ic/start-mem-profiler
   "p" #'ic/start-cpu-mem-profiler
   "s" #'profiler-stop
   "r" #'profiler-report)
#+END_SRC

** f :: Files
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "f"
   "" '(nil :which-key "files")
   "b" 'helm-bookmarks
   "c" 'copy-file
   "D" 'delete-current-buffer-file
   "E" 'sudo-edit
   "f" 'ic/helm-find-files
   "F" 'helm-find-files
   "L" 'helm-locate-library
   "M" 'rename-current-buffer-file
   "r" 'ic/helm-recentf
   "R" 'helm-recentf
   "y" 'ic/yank-current-filename)
#+END_SRC

** fC :: Convert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fC"
   "" '(nil :which-key "convert")
   "d" 'unix-to-dos
   "u" 'dos-to-unix)
#+END_SRC

** fe :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fe"
   "" '(nil :which-key "emacs")
   "i" 'edit-init-file
   "o" 'edit-org-config
   "l" 'helm-locate-library)
#+END_SRC

** g :: git/vc
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "g"
    "" '(nil :which-key "git")
    "i" 'magit-gitignore
    "s" 'magit-status
    "S" 'magit-stage-file
    "U" 'magit-unstage-file
    )
#+END_SRC

** h :: help
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "h"
   "" '(nil :which-key "help")
   "a" 'apropos
   "k" 'which-key-show-top-level
   "i" 'info
   "I" 'helm-info
   "m" 'helm-man-woman)
#+END_SRC

** hd :: help describe
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "hd"
   "" '(nil :which-key "describe")
   "b" 'describe-bindings
   "c" 'describe-char
   "f" 'describe-function
   "F" 'describe-face
   "K" 'describe-keymap
   "k" 'describe-key
   "l" 'describe-last-keys
   "m" 'describe-mode
   "p" 'describe-package
   "s" 'describe-system-info
   "t" 'describe-theme
   "v" 'describe-variable)
#+END_SRC

** i :: insert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "i"
   "" '(nil :which-key "insert")
   "8" 'helm-ucs
   )
#+END_SRC
** l :: layouts

** m :: major mode

** p :: projects

** r :: registers

** s :: search

** S :: snippets
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "S"
    "" '(nil :which-key "snippets")
    "e" #'yas-visit-snippet-file
    "i" #'yas-insert-snippet
    "n" #'yas-new-snippet)
#+END_SRC

** t :: toggle

** w :: windows
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "w"
   "" '(nil :which-key "windows")
   "=" 'balance-windows
   "d" 'delete-window
   "F" 'make-frame
   "f" 'follow-mode
   "H" 'evil-window-move-far-left
   "h" 'evil-window-left
   "J" 'evil-window-move-very-bottom
   "j" 'evil-window-down
   "K" 'evil-window-move-very-top
   "k" 'evil-window-up
   "L" 'evil-window-move-far-right
   "l" 'evil-window-right
   "m" 'delete-other-windows
   "S" 'split-window-below-and-focus
   "s" 'split-window-below
   "U" 'winner-redo
   "u" 'winner-undo
   "V" 'split-window-right-and-focus
   "v" 'split-window-right
   )
#+END_SRC

** x :: text

