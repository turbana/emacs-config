# -*- lexical-binding: t; -*-
#+TITLE: Emacs Config
#+STARTUP: content

Welcome to my emacs configuration.

* Initial Setup
All right-thinking people use lexical binding.
#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-
#+END_SRC

I want to be able to potentially load separate emacs configurations so set the base emacs directory to where the currently loading configuration is.
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory load-file-name))
#+END_SRC

I also want to keep my =user-emacs-directory= somewhat clean, so let's define a few sub directories that we'll try to keep the plethora of emacs files in:
- =user-cache-directory= :: files that contain transient data (history, projectile, etc).
- =user-data-directory= :: files that contain version controlled data (snippets, etc)

#+BEGIN_SRC emacs-lisp
  (defvar user-cache-directory (concat user-emacs-directory "cache/"))
  (defvar user-data-directory (concat user-emacs-directory "data/"))
#+END_SRC

I want my config to be portable between machines. So I'll need some variables to key on for various changes

#+BEGIN_SRC emacs-lisp
  (setq on-linux (string-equal system-type "gnu/linux"))
  (setq on-windows (string-equal system-type "windows-nt"))
  (setq on-mac (string-equal system-type "darwin"))

  ;; at_home/at_work are bash functions defined in ~/.bashrc
  (setq at-home (= 0 (shell-command "source ~/.bashrc && at_home")))
  (setq at-work (= 0 (shell-command "source ~/.bashrc && at_work")))

  (setq on-tablet (string-equal (system-name) "DESKTOP-F6Q3GN2"))
  (setq on-old-imac (string-equal (system-name) "Michaels-iMac.local"))
#+END_SRC

* Bootstrap
** Native compilation
I want to make use of the native compilation system introduced in emacs 28.
#+BEGIN_SRC emacs-lisp
  ;; do we have native compilation available?
  (defconst have-native-compilation
    (and (fboundp 'native-comp-available-p)
         (native-comp-available-p)))

  (when have-native-compilation
    (setq comp-async-jobs-number 4))
#+END_SRC
** straight.el
I use =straight.el= for package management so install this early.
#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

Integrate =straight.el= with =use-package=.
#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
#+END_SRC

I want to check in my packages to git so store the version file under =user-data-directory=.
#+BEGIN_SRC emacs-lisp
  (setq straight-profiles `((nil . ,(concat user-data-directory "straight-default.el"))))
#+END_SRC
** async
I use the =async= package in my =init.el= tangling function, so we need to load it early.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC

** init.el
On checking out this repo =init.el= will have temporary code in it to tangle / load this org file (=README.org=), overwriting itself. On this initial run we will have loaded both core =org-mode= and melpa =org-mode= so emit a warning that a restart is needed.
#+BEGIN_SRC emacs-lisp :tangle no
  ;; load core emacs `org-mode', but don't native compile it
  (let ((comp-deferred-compilation nil))
    (require 'org))

  ;; tangle/load our init file
  (let* ((base-dir (file-name-directory load-file-name))
         (org-file (concat base-dir "README.org"))
         (el-file (concat base-dir "init.el")))
    (org-babel-tangle-file org-file el-file)
    ;; on first load we shadow the core emacs org-mode and when trying to quit
    ;; emacs calls the non-existent function `org-clocking-buffer'. Define a dummy
    ;; to allow us to exit cleanly on initial run
    (defun org-clocking-buffer (&rest _))
    (load-file el-file)
    (warn "This is the first load of init.el so core emacs `org-mode' is loaded.
   Restart emacs to use newest version."))
#+END_SRC

We also need to tell =git= to ignore changes to =init.el= so the following command was run:
#+BEGIN_SRC shell :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

Let's also tell emacs where =init.el= lives so packages can find it. =straight.el= requires it for updating packages.
#+BEGIN_SRC emacs-lisp
  (setq user-init-file (concat user-emacs-directory "init.el"))
#+END_SRC

This file (=README.org=) should be tangled into the startup config file (=init.el=) along with compiling (either native or byte). I want that to happen automatically and asynchronously.
#+BEGIN_SRC emacs-lisp
  (defvar ic--tangle-init-async-cookie nil
    "Used to keep track of the async org-tangle process for init.el")

  (defun ic-maybe-tangle-init-file ()
    "Tangle/compile my emacs configuration."
    (let ((org-files (list
              (expand-file-name "~/src/emacs/README.org")
              (concat user-emacs-directory "README.org"))))
      (when (member (buffer-file-name) org-files)
    (when (process-live-p ic--tangle-init-async-cookie)
      (kill-process ic--tangle-init-async-cookie))
    (message "Async tangling %s..." (buffer-file-name))
    (setq
     ic--tangle-init-async-cookie
     (async-start
      `(lambda ()
         (require 'ob-tangle)
         (require 'subr-x)
         (let ((start-time (current-time)))
           (when-let (ret (org-babel-tangle-file ,(buffer-file-name)
                             ,user-init-file))
         ;; (byte-compile-file ,user-init-file)
         ;; (when ,have-native-compilation
         ;;   (native-compile ,user-init-file))
         (cons ret (float-time (time-since start-time))))))
      `(lambda (ret)
         (unless ret
           (error "error in org-babel-tangle for %S"
              ,(buffer-file-name)))
         (message "Tangled %s in %.2f seconds"
              (caar ret) (cdr ret))))))))

  (add-hook 'after-save-hook 'ic-maybe-tangle-init-file)
#+END_SRC

** Theme
Load my custom theme early so if we have errors emacs still looks pretty.

#+BEGIN_SRC emacs-lisp
  (use-package themian-theme
    :straight (themian :type git :host github :repo "turbana/themian")
    :init
    (setq themian-org-mode-variable-pitch t)
    (setq themian--show-unknowns nil)
    (cond (on-old-imac
           (set-face-attribute 'default nil
                               :family "Iosevka Extended" :height 160 :weight 'ultra-light)
           (set-face-attribute 'fixed-pitch nil
                               :family "Iosevka Extended" :height 160 :weight 'ultra-light)
           (set-face-attribute 'variable-pitch nil
                               :family "DejaVu Sans ExtraLight" :height 150 :weight 'ultra-light))
          (t
           (set-face-attribute 'default nil
                               :family "Iosevka Extended" :height 110 :weight 'normal)
           (set-face-attribute 'fixed-pitch nil
                               :family "Iosevka Extended" :height 110 :weight 'normal)
           (set-face-attribute 'variable-pitch nil
                               :family "DejaVu Sans Condensed" :height 120 :weight 'normal)))
    (defun themian--reload-dark-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-dark 'dark)
      (load-theme 'themian-dark t))
    (defun themian--reload-light-theme ()
      (interactive)
      (load-file "~/src/themian/themian-theme.el")
      (themian-create-color-theme 'themian-light 'light)
      (load-theme 'themian-light t))

    :config
    (defun themian--load-theme-on-frame-create (frame)
      "Enable default theme on FRAME, but only when graphics are enabled and no
    other theme is loaded."
      (with-selected-frame frame
        (when (and (display-graphic-p)
                   (not custom-enabled-themes))
          (load-theme (if (or on-tablet on-old-imac) 'themian-light 'themian-dark) t))))
    (add-hook 'after-make-frame-functions 'themian--load-theme-on-frame-create)

    ;; don't use `general' to bind keys as it's not loaded yet
    :bind (("M-<f5>" . 'themian--reload-dark-theme)
           ("M-<f6>" . 'themian--reload-light-theme)))
#+END_SRC

** Debugging
*** Tracing
Some functions to trace the changing of variables.

#+BEGIN_SRC emacs-lisp
  ;; use when live editing
  ;; (setq lexical-binding t)

  (defvar ic/watch-variable-message-fmt "%s(%s): %s %S"
    "Format to use when displaying variable changes. Equivalent to
  `(format ic/watch-variable-message-fmt symbol buffer operation value)'.")

  (defun ic/watch-variable (symbol &rest ops)
    "Watch for any OPS operations on SYMBOL and call `message'. OPS defaults to
  '(set), see `add-variable-watcher' for all possible values."
    (defun watch-variable-call-message (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
    (ic/watch-variable-call-func symbol 'watch-variable-call-message ops)))

  (defun ic/watch-variable-raise-debug (symbol &rest ops)
    "Watch for any changes to SYMBOL and raise on error."
    (defun watch-variable-raise-debug (sym value operation buffer)
      (let ((msg (ic//watch-variable-format sym buffer operation value)))
        (message msg)
        (debug nil msg)))
    (ic/watch-variable-call-func symbol 'watch-variable-raise-debug ops))

  (defun ic/watch-variable-print-stack (symbol &rest ops)
    "Watch for any changes to SYMBOL and print a stack trace."
    (defun watch-variable-print-stack (sym value operation buffer)
      (message (ic//watch-variable-format sym buffer operation value))
      (if-let ((stack-trace (with-output-to-string (backtrace))))
          (progn
            (message ">>>>>>>>>>")
            (message "%S" stack-trace)
            (message "<<<<<<<<<<"))
        (message "(no stack trace found)")))
    (ic/watch-variable-call-func symbol 'watch-variable-print-stack ops))

  (defvar ic//variable-watchers nil "a-list of variable watchers")

  (defun ic/watch-variable-call-func (symbol func &rest ops)
    "Watch for any OPS on SYMBOL and call FUNC."
    (unless (assq symbol ic//variable-watchers)
      (when (equal ops (list nil))
        (setq ops '(set let unlet makunbound defvaralias)))
      (defun watch-change (sym value operation buffer)
        (when (member operation ops)
          (apply func (list sym value operation buffer))))
      (add-variable-watcher symbol 'watch-change)
      (push (cons symbol 'watch-change) ic//variable-watchers)))

  (defun ic/unwatch-variable (symbol)
    "Remove any `ic/watch-variable-*' watchers from SYMBOL."
    (let ((watcher (alist-get symbol ic//variable-watchers)))
      (when watcher
        (remove-variable-watcher symbol watcher)
        (setq ic//variable-watchers
              (assq-delete-all symbol ic//variable-watchers))
        t)))

  (defun ic//watch-variable-format (symbol value operation buffer)
    "Generate printable string."
    (format "%s(%s): %s %S" symbol buffer operation value))
#+END_SRC

*** Profiling
Some profiler keybindings.

#+BEGIN_SRC emacs-lisp
  (require 'profiler)

  (defun ic/start-cpu-profiler ()
    "Start the CPU profiler."
    (interactive)
    (profiler-start 'cpu))

  (defun ic/start-mem-profiler ()
    "Start the memory profiler."
    (interactive)
    (profiler-start 'mem))

  (defun ic/start-cpu-mem-profiler ()
    "Start both CPU and memory profiling."
    (interactive)
    (profiler-start 'cpu+mem))
#+END_SRC

** Keybinds
I like the spacemacs idea of having both a leader key (=SPC=) and a (mode-specific) local leader key (=,=). The leader key being how all the major functions are accessed, such as buffers/files/windows/etc. Where the local leader is how mode-specific functions are accessed, such as =org-mode= bindings or =mu4e=, etc.

There are a few things I don't care for though: I don't need emacs bindings, nor do I want access to the local leader map from the leader map (=SPC m=). So I want a dual leader key system without the cruft.

The package =general.el= makes all of the above rather simple. Here we ensure it's installed and activated with =:demand t=. We then setup two =definers=, one for the leader key (=leader-keys=) and one for the local leader key (=local-leader-keys=). Both =definers= define their keys in the =general-override-mode-map= keymap. This keymap has a high priority, but only when =general-override-mode= is active so ensure it is with =(general-override-mode 1)=.

#+BEGIN_SRC emacs-lisp
  (use-package general
      :demand t
      :config
      ;; ensure `general-override-mode-map' is active
      (general-override-mode 1)

      ;; create leader (SPC) definer
      (general-create-definer leader-keys
        :states '(normal motion insert emacs)
        :keymaps 'general-override-mode-map
        :prefix "SPC"
        :non-normal-prefix "C-SPC")

      ;; create local leader (,) definer
      (general-create-definer local-leader-keys
        :states '(normal motion insert emacs)
        :keymaps 'general-override-mode-map
        :prefix ","
        :non-normal-prefix "C-,"))
#+END_SRC

* Packages
** all-the-icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

** auto-dim-other-buffers
Turn on  =auto-dim-other-buffers-mode=. Dim when the frame loses focus, but don't dim when the mini buffer is active. See the face =auto-dim-other-buffers-face= for color customization.

#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
      :config
      (defun ic-dont-auto-dim-helm-windows (buffer)
        "Return `t' if inside a helm buffer, so `auto-dim-other-buffers' won't dim the current helm window."
        (string-match-p "^\*helm" (buffer-name buffer)))
      (push #'ic-dont-auto-dim-helm-windows
            auto-dim-other-buffers-never-dim-buffer-functions)
      (setq auto-dim-other-buffers-dim-on-focus-out t)
      (setq auto-dim-other-buffers-dim-on-switch-to-minibuffer nil)
      ;; ensure org-indent face is properly hidden
      (push '(org-indent . auto-dim-other-buffers-hide-face)
            auto-dim-other-buffers-affected-faces)
      (auto-dim-other-buffers-mode t))
#+END_SRC

** company-mode
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :config

    ;; company-show-location
    ;; company-show-doc-buffer

    (setq company-tooltip-align-annotations nil)
    (setq company-abort-on-unique-match t)

    ;; (company-search-candidates)
    ;; (company-filter-candidates)
    :general
    (general-define-key
     :keymaps 'company-active-map
     "C-l" 'company-show-location
     "C-h" 'company-show-doc-buffer
     "C-w" 'backward-kill-word
     "C-s" 'company-search-candidates
     "C-f" 'company-filter-candidates
     )
    )
#+END_SRC

** csharp-mode
Minimal setup for viewing =C#= code.

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode)
#+END_SRC

** evil
*** use-package
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package evil
      :ensure evil
      :init
      <<evil-init>>
      :config
      <<evil-config>>
      )
#+END_SRC

*** evil-init
:PROPERTIES:
:header-args: :noweb-ref evil-init :tangle no
:END:

The following are needed for =evil-collection=:
#+BEGIN_SRC emacs-lisp
  ;; needed for evil-collection
  (setq evil-want-integration t)
  (setq evil-want-keybinding nil)
#+END_SRC

Misc setup
#+BEGIN_SRC emacs-lisp
  ;; don't bind anything under C-g
  (setq evil-want-C-g-bindings nil)

  ;; C-u/d should scroll up/down
  (setq evil-want-C-u-scroll t)
  (setq evil-want-C-d-scroll t)

  ;; C-w should backwards delete work in insert mode
  (setq evil-want-C-w-delete t)

  ;; Y should only yank from point to eol
  (setq evil-want-Y-yank-to-eol t)

  ;; movement commands should respect `visual-line-mode'
  (setq evil-respect-visual-line-mode t)
#+END_SRC

*** evil-config
:PROPERTIES:
:header-args: :noweb-ref evil-config :tangle no
:END:

#+BEGIN_SRC emacs-lisp
  (evil-mode 1)
#+END_SRC

** evil-collection
Some basic community =evil-mode= bindings for various modes. See =evil-collection--supported-modes= for a list.

#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
      :after evil
      :init
      (setq evil-collection-company-use-tng nil)
      :config
      (evil-collection-init))
#+END_SRC

** evil-org-mode
Some basic community =evil-mode= key bindings for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
      :demand t
      :after (evil org)
      :hook (org-mode . evil-org-mode)
      :init
      ;; don't make a new list item when using o/O
      (setq evil-org-special-o/O '(table-row))
      :config
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    )
#+END_SRC

** haskell-mode
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :demand t)
#+END_SRC

** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :config
    (helm-mode 1)

    ;; bring up helm full width below other windows
    (setq helm-default-display-buffer-functions '(display-buffer-in-side-window))

    ;; short window by default
    (setq helm-display-buffer-default-height 20)

    :general
    (general-define-key
     :keymaps 'helm-map
     ;; I'm too used to C-w killing a word backwards
     "C-w" 'backward-kill-word
     ;; TAB should be more useful than bringing up actions
     "<tab>" 'helm-execute-persistent-action
     "C-i" 'helm-execute-persistent-action
     ;; C-, should start actions
     "C-," 'helm-select-action
     ;; C-. to paste into buffer
     "C-." 'helm-insert-or-copy
     ;; <left/right> should move the point
     "<left>" 'backward-char
     "<right>" 'forward-char
     )

    ;; set some helm-grep keys
    (general-define-key
     :states '(normal)
     :keymaps 'helm-grep-mode-map
     "RET" 'helm-grep-mode-jump
     "o" 'helm-grep-mode-jump-other-window)

    (general-define-key
     "M-x" 'helm-M-x)

    (general-define-key
     :states '(normal)
     "gi" 'helm-semantic-or-imenu)

    (leader-keys
      "R" 'helm-resume)
    )
#+END_SRC

** helm-org-ql
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-ql)
#+END_SRC

** helm-posframe
Let's try having =helm= popup in a frame. I'd like it to cover to full screen width and have minimal styling.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package helm-posframe
    :config
    (setq helm-posframe-poshandler
          #'posframe-poshandler-frame-bottom-center)
    (setq helm-posframe-min-width (+ 1 (frame-width)))
    (setq helm-posframe-width helm-posframe-min-width)
    (setq helm-posframe-min-height 20)
    (setq helm-posframe-height helm-posframe-min-height)
    (setq helm-posframe-border-width 0)
    (helm-posframe-enable))
#+END_SRC

** helm-projectile
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :demand t
    :after (helm projectile)
    :config
    (helm-projectile-on)

    (defmacro ic/defproject-call-switch (name-sym proj-func-sym non-proj-func-sym)
      "Bind function NAME and have it call PROJ-FUNC when inside a
  `projectile-mode' project, or NON-PROJ-FUNC otherwise."
      (declare (indent defun))
      (let ((proj-func (cadr proj-func-sym))
            (non-proj-func (cadr non-proj-func-sym))
            (name (cadr name-sym)))
        (cond ((not (fboundp proj-func))
               (error "Function `%s' not bound" (symbol-name proj-func)))
              ((not (fboundp non-proj-func))
               (error "Function `%s' not bound" (symbol-name non-proj-func)))
              (t
               `(defun ,name ()
                  ,(format "Call `%s' when inside a project, `%s' otherwise."
                           (symbol-name proj-func) (symbol-name non-proj-func))
                  (interactive)
                  (if (and (fboundp 'projectile-project-p) (projectile-project-p))
                      (call-interactively ,proj-func-sym)
                    (call-interactively ,non-proj-func-sym)))))))

    (defun ic//helm-find-files ()
      "Call `(help-find-files nil)'."
      (interactive "P")
      (call-interactively 'helm-find-files nil))

    (ic/defproject-call-switch 'ic/helm-buffers
      'helm-projectile-switch-to-buffer 'helm-mini)

    (ic/defproject-call-switch 'ic/helm-find-files
      'helm-projectile-find-file 'helm-find-files)

    (ic/defproject-call-switch 'ic/helm-recentf
      'helm-projectile-recentf 'helm-recentf)

    (ic/defproject-call-switch 'ic/projectile-ibuffer
      'projectile-ibuffer 'ibuffer)
    )
#+END_SRC

** helm-rg
#+BEGIN_SRC emacs-lisp
  (use-package helm-rg
    :after (helm))
#+END_SRC

** lsp
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :demand t
    :commands lsp

    :init
    (setq lsp-keymap-prefix "C-c l")

    ;; don't show the top breadcrumbs by default
    (setq lsp-headerline-breadcrumb-enable nil)

    :hook
    ((lsp-mode . lsp-enable-which-key-integration))

    :general
    (local-leader-keys
      :keymaps 'prog-mode-map
      "l" lsp-command-map)
    )
#+END_SRC

** magit
For some reason on the Surface Pro 4 tablet we need to manually load =magit-section= before loading =magit= proper.
#+BEGIN_SRC emacs-lisp
  (when (or on-tablet on-old-imac)
    (use-package magit-section))
#+END_SRC

Main =magit= config.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    ;; don't use magit's default key bindings
    (setq magit-define-global-key-bindings nil)

    :general
    (general-define-key
     :keymaps 'magit-status-mode-map
     "<up>" 'magit-section-backward
     "<down>" 'magit-section-forward))
#+END_SRC

** org
=org-mode= is a large part of my daily emacs usage so it takes a large amount of my configuration as well. Let's go...

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
      :mode (("\\.org$" . org-mode))
      :ensure org-plus-contrib
      :after (all-the-icons yasnippet)
      :config
      <<org-config>>
      :general
      <<org-keybinds>>
      )
#+END_SRC

*** org-config
:PROPERTIES:
:header-args: :noweb-ref org-config :tangle no
:END:

**** Basic Setup
#+BEGIN_SRC emacs-lisp
  (defvar org-home-file "~/org/home/home.org"
    "Default org file for home related items.")
  (defvar org-work-file "~/org/work.org"
    "Default org file for work related items.")
  (defvar org-default-file (if at-home org-home-file org-work-file)
    "Default org file.")
  (setq org-default-notes-file
        (if at-home "~/org/home/inbox.org" "~/org/inbox.org"))
  (setq org-agenda-files
        (append (list org-default-file
                      org-default-notes-file)
                (if at-home
                    '("~/org/home/mobileinbox.org"
                      "~/org/home/jobs.org"))
                (directory-files "~/org" t "\\.org$")))
  (setq org-archive-location "%s_archive::")
#+END_SRC

**** Refile
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        '((nil :maxlevel . 6)
          (org-agenda-files :maxlevel . 2)))
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Refile jump
Add ability to jump to any org heading with SPC-aoj
#+BEGIN_SRC emacs-lisp
  (defun ic/org-jump ()
    "Jump to an `org-refile-targets' heading."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'org-refile)))

  (defun ic/org-jump-in-buffer ()
    "Jump to a heading in the current buffer."
    (interactive)
    ;; `org-refile-targets' needs to be dynamically bound
    (defvar org-refile-targets)
    (let ((org-refile-targets '((nil :maxlevel . 999))))
      (ic/org-jump)))
#+END_SRC

**** Normal mode navigation
#+BEGIN_SRC emacs-lisp
  (defun ic/outline-current-heading-or-up ()
    "When point is on an org-mode heading: move to parent heading;
  otherwise: move to current heading."
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'outline-up-heading
                          'outline-previous-heading)))

  (defun ic/outline-current-heading-or-backward ()
    "when point is on an org-mode heading: move to previous heading;
  otherwise: move to previous heading"
    (interactive)
    (call-interactively (if (org-at-heading-p)
                            'org-backward-heading-same-level
                          'outline-previous-heading)))
#+END_SRC

**** Appearance
Basic heading setup
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-folded nil)
  (setq org-hide-leading-stars t)
  (setq org-odd-levels-only nil)

  (setq org-adapt-indentation nil)
  (setq org-indent-indentation-per-level 2)

  (setq org-fontify-whole-heading-line t)
  (setq org-fontify-done-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
#+END_SRC

Let's use some fancy LaTeX symbols.
Example: \Delta{}v \ne \pi
#+BEGIN_SRC emacs-lisp
  (setq org-pretty-entities t)
  ;; don't use super/sub-scripts as they mess with headings
  (setq org-pretty-entities-include-sub-superscripts nil)
#+END_SRC

Use =visual-line-mode= as =org-mode= is mostly prose.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'visual-line-mode)
#+END_SRC

Because =org-mode= is mostly prose use =buffer-face-mode= (along with setting the face =org-default=) to get variable pitch text. See the variable =themian-force-fixed-faces= for a list of faces that will remain fixed.
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'buffer-face-mode)
#+END_SRC

Change some characters to unicode icons. Some good icons [[http://csbruce.com/software/utf-8.html][here]]. See [[*org-bullets][org-bullets]] setup as well.
#+BEGIN_SRC emacs-lisp
  ;; ‚ö´‚Ä¢‚¶æ‚¶ø‚Äî‚¨é‚åÑ‚åµ‚Ü¥‚§µ‚Üò‚Üì‚Ü∑ÓèáÓóèÓÉÉÔÑÄÔÑÅÓåõÓåñÓóáÔÉâÔÑÇÔÖÇÔÖâ‚îÖ
  (setq org-ellipsis (if on-tablet " ‚Ä¶" " ‚åµ"))

  ;; replace certain org-mode text with symbols
  (defun ic/org-mode-pretty-symbols ()
    "Enable `prettify-symbols-mode' and set `prettify-symbols-alist' for certain
  `org-mode' symbols."
    (setq prettify-symbols-alist
          `(("[#A]" . ?üÖê)
            ("[#B]" . ?üÖë)
            ("[#C]" . ?üÖí)
            ("[ ]" . ?ÔÇñ)
            ("[X]" . ?ÔÅÜ)
            ("[-]" . ?ÔÖá)
            ("SCHEDULED:" . ?ÔÅ≥)
            ("DEADLINE:" . ?ÔÅ±)))
    (prettify-symbols-mode 1))

  (add-hook 'org-mode-hook #'ic/org-mode-pretty-symbols)
  (add-hook 'org-agenda-mode-hook #'ic/org-mode-pretty-symbols)
#+END_SRC

Change list items to symbol. Code inspired by [[https://emacs.stackexchange.com/questions/59882/how-to-change-color-of-font-lock-add-keywords][this]] stack exchange question.
#+BEGIN_SRC emacs-lisp
  (require 'org-element)

  (setq ic/org-list-icon (propertize "‚Äî" 'face 'themian-subtle))

  (defun org+-match-item-marker (bound)
    "Match the bullet of itemizations."
    (and
     (re-search-forward "^ *\\(-\\) " bound t)
     (save-match-data
       (save-excursion
         (goto-char (match-end 1))
         (eq (org-element-type (org-element-at-point)) 'item)))))

  ;; change list dashes
  (font-lock-add-keywords
   'org-mode
   `((org+-match-item-marker
      (1
       '(face default display ,ic/org-list-icon)
       append)))
   t)
#+END_SRC

Color priorities based on how important they are.
#+BEGIN_SRC emacs-lisp
  (setq org-priority-faces '((?A . '(:inherit (themian-error org-priority)))
                             (?B . 'org-priority)
                             (?C . '(:inherit (themian-weak org-priority)))))
#+END_SRC

XXX what do these do?
#+BEGIN_SRC emacs-lisp
  (setq org-completion-use-ido t)
  (setq org-return-follows-link t)
  ;; (setq org-blank-before-new-entry nil)
#+END_SRC

Hide emphasis markers such as *bold*, /italic/, etc.
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

**** org-src
Use current window to edit =org-src= blocks. Don't indent.
#+BEGIN_SRC emacs-lisp
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 2)
  (setq org-src-window-setup 'current-window)
#+END_SRC

When editing an =org-src= block =:w= should save the parent buffer.
#+BEGIN_SRC emacs-lisp
  (evil-define-operator ic/evil-write (&rest args)
    "When editing an org-src block `:w' should call `(org-edit-src-save)'."
    :motion nil
    :move-point nil
    :type line
    :repeat nil
    (interactive "<R><fsh><!>")
    (if (bound-and-true-p org-src-mode)
        (org-edit-src-save)
      (call-interactively 'evil-write args)))

  (evil-ex-define-cmd "w" 'ic/evil-write)
#+END_SRC

**** org-babel
Allow us to execute various languages in =org-src= blocks.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (shell . t)))
#+END_SRC

**** Agenda
***** Setup
#+BEGIN_SRC emacs-lisp
  ;; custom agenda views
  (setq org-agenda-custom-commands
        '(
          ;; work agenda
          ("w" "Work Agenda"
           ((agenda "" nil)
            (tags "refile"
                  ((org-agenda-overriding-header "Refile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile/"
            ;;       ((org-agenda-overriding-header "Archive tasks:")
            ;;        (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            )
           ((org-agenda-tag-filter-preset '("-HOME"))))

          ;; home agenda
          ("h" "Home agenda"
           ((agenda ""
                    ((org-agenda-skip-function 'ic/skip-old-meal-plans)))
            (tags "refile"
                  ((org-agenda-overriding-header "\nRefile tasks:")
                   (org-tags-match-list-sublevels nil)))
            ;; (tags "-refile"
            ;;       ((org-agenda-overriding-header "\nArchive tasks:")
            ;;        (org-agenda-skip-function 'ic/skip-non-archivable-tasks)
            ;;        (org-tags-match-list-sublevels nil)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "\nNext Steps:")))
            (tags-todo "chores+PRIORITY=\"A\"|jobs+PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nImportant Chores:")))
            (tags-todo "chores-PRIORITY=\"A\"|jobs-PRIORITY=\"A\""
                       ((org-agenda-overriding-header "\nChores:")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled 'deadline))
                        ))
            (tags "+HOME"
                  ((org-agenda-overriding-header "\nStuck Projects")
                   (org-agenda-skip-function 'ic/org-skip-nonstuck-projects)
                   ))
            )
           ((org-agenda-tag-filter-preset '("+HOME"))))

          ;; archives
          ("a" . "Archiving")
          ("ah" "Home archive"
           ((tags "+HOME-noarchive/DONE|CANCELLED|APPLIED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ("aw" "Work archive"
           ((tags "-HOME-noarchive+TIMESTAMP_IA<=\"<-2w>\"/DONE|CANCELLED"
                  ((org-agenda-overriding-header "Archive Tasks (*x$ to archive all):")))))
          ))
#+END_SRC

***** Appearance
#+BEGIN_SRC emacs-lisp
  ;; don't show completed DEADLINE and SCHEDULED in agenda
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 't)

  ;; first day in agenda should be today
  (setq org-agenda-start-on-weekday nil)

  ;; show weekly agenda by default
  (setq org-agenda-span 'week)

  ;; don't have a separator between agenda sections
  (setq org-agenda-compact-blocks t)

  ;; show agenda icons
  (setq org-agenda-prefix-format "  %i %?-2 t%s")

  ;; highlight the current line
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+END_SRC

***** Test icons (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disable
  ;;; DISABLED ;;;

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (setq tab-width 2)
  ;;                                         ; (setq tab-stop-list '(2 3 5))
  ;;             ))

  (require 'all-the-icons)

  ;; (let ((font (find-font (font-spec :name "FontAwesome"))))
  ;;   (font-put font :spacing 100)
  ;;   (font-get font :spacing)
  ;;   )

  (defun ic/org-agenda-icon (family icon-name)
    (let* ((icon-func (cdr (assoc family
                                  '((ati . all-the-icons-alltheicon)
                                    (faicon . all-the-icons-faicon)
                                    (fileicon . all-the-icons-fileicon)
                                    (octicon . all-the-icons-octicon)
                                    (wicon . all-the-icons-wicon)))))
           (face-func (cdr (assoc family
                                  '((ati . all-the-icons-icon-family)
                                    (faicon . all-the-icons-faicon-family)
                                    (fileicon . all-the-icons-fileicon-family)
                                    (octicon . all-the-icons-octicon-family)
                                    (wicon . all-the-icons-wicon-family)))))
           (all-the-icons-scale-factor 1.0)
           ;; (font (concat (apply face-func nil) ":spacing=monospace"))
           (font "FontAwesomeMono:spacing=100")
           ;; (font (apply face-func nil))
           (face `(:family ,font :height 1.0))
           ;; (icon (apply icon-func (list icon-name :face 'default)))
           (icon (cdr (assoc icon-name all-the-icons-data/fa-icon-alist)))
           )
      (propertize icon
                  'face face
                  'font-lock-face face
                  ;; 'display '(space :width (50) :height 7)
                  ;; 'display '(space-width 5)
                  'rear-nonsticky t
                  )
      ))

  ;; (ic/org-agenda-icon 'faicon "calendar")

  ;; (let ((icon (all-the-icons-faicon "calendar")))
  ;;   (string-to-char icon))

  ;; setup agenda icons
  (setq org-agenda-category-icon-alist
        (let ((icon-mapping
               '(
                 ("annivers" faicon "calendar")
                 ("birthdays" faicon "birthday-cake")
                 ("chores" faicon "home")
                 ("computer" faicon "keyboard-o")
                 ("cpu" faicon "fax")
                 ("holidays" faicon "calendar-o")
                 ("cooking" faicon "cutlery")
                 ("health" faicon "heartbeat")
                 ("jobs" faicon "building-o")
                 ("life" faicon "male")
                 )))
          (mapcar (lambda (config)
                    ;; `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)) :width (50)) nil nil :ascent center :mask heuristic))
                    `(,(car config) (list ,(apply #'ic/org-agenda-icon (cdr config)))))
                  icon-mapping
                  )))

  (defun blaenk/set-char-widths (alist)
    (while (char-table-parent char-width-table)
      (setq char-width-table (char-table-parent char-width-table)))
    (dolist (pair alist)
      (let ((width (car pair))
            (chars (cdr pair))
            (table (make-char-table nil)))
        (dolist (char chars)
          (set-char-table-range table char width))
        (optimize-char-table table)
        (set-char-table-parent table char-width-table)
        (setq char-width-table table))))

  (defconst old-char-width-table char-width-table)

  ;; argument is an alist of width and list of RANGEs,
  ;; which is the same as the RANGE that set-char-table-range accepts
  ;; (blaenk/set-char-widths
  ;;  `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;           ,(string-to-char (all-the-icons-faicon "home"))
  ;;           ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;           ))))

  ;; (setq org-agenda-mode-hook nil)
  ;; (add-hook 'org-agenda-mode-hook
  ;;           (lambda ()
  ;;             (message "set-char-widths")
  ;;             (blaenk/set-char-widths
  ;;              `((5 . (,(string-to-char (all-the-icons-faicon "male"))
  ;;                       ,(string-to-char (all-the-icons-faicon "home"))
  ;;                       ,(string-to-char (all-the-icons-faicon "building-o"))
  ;;                       ))))
  ;;                            ))




  ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping
  ;;              '(
  ;;                ("annivers" (all-the-icons-faicon "calendar"))
  ;;                ("birthdays" (all-the-icons-faicon "birthday-cake"))
  ;;                ("chores" (all-the-icons-faicon "home"))
  ;;                ("computer" (all-the-icons-faicon "keyboard-o"))
  ;;                ("cpu" (all-the-icons-faicon "fax"))
  ;;                ("holidays" (all-the-icons-faicon "calendar-o"))
  ;;                ("cooking" (all-the-icons-faicon "cutlery"))
  ;;                ("health" (all-the-icons-faicon "heartbeat"))
  ;;                ("jobs" (all-the-icons-faicon "building-o"))
  ;;                ("life" (all-the-icons-faicon "male"))
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (car config))
  ;;                         (icon (apply (caadr config) (cdadr config))))
  ;;                     `(,category (list ,icon :width (100)) nil nil :ascent center :mask heuristic :width (100))))
  ;;                 icon-mapping)))



  ;; ;; setup agenda icons
  ;; (setq org-agenda-category-icon-alist
  ;;       (let ((icon-mapping-alist
  ;;              '(
  ;;                ("annivers" 'faicon "calendar")
  ;;                ("birthdays" 'faicon "birthday-cake")
  ;;                ("chores" 'faicon "home")
  ;;                ("computer" 'faicon "keyboard-o")
  ;;                ("cpu" 'faicon "fax")
  ;;                ("holidays" 'faicon "calendar-o")
  ;;                ("cooking" 'faicon "cutlery")
  ;;                ("health" 'faicon "heartbeat")
  ;;                ("jobs" 'faicon "building-o")
  ;;                ("life" 'faicon "male")
  ;;                )))
  ;;         (mapcar (lambda (config)
  ;;                   (let ((category (first config))
  ;;                         (icon-family (second config))
  ;;                         (icon-name (third config))
  ;;                         (ati-family-alist
  ;;                          '(('ati . all-the-icons-alltheicon)
  ;;                            ('faicon . all-the-icons-faicon)
  ;;                            ('fileicon . all-the-icons-fileicon)
  ;;                            ('octicon . all-the-icons-octicon)
  ;;                            ('wicon . all-the-icons-wicon))))
  ;;                 `(,category (list ,(apply (cdr (assoc icon-family ati-family-alist)) (list icon-name :height 0.9 :v-adjust 0))) nil nil :ascent center :mask heuristic)))
  ;;                   icon-mapping-alist)))
#+END_SRC

***** Functions
****** Open agenda
I want to open the correct agenda (home/work) automatically.
#+BEGIN_SRC emacs-lisp
  (defun ic-open-org-agenda ()
    "Open the correct org agenda based on location (home/work)."
    (interactive)
    (cond (at-home (org-agenda nil "h"))
          (at-work (org-agenda nil "w"))
          (t (org-agenda))))
#+END_SRC

****** Stuck Projects
I have a somewhat loose definition of what constitutes a project. I consider any org heading a project if:
- It has a todo state and none of it's ancestors do
- It has one or more immediate children with todo states

Furthermore I consider a stuck project:
- A project with no descendants having a NEXT todo state

#+BEGIN_SRC emacs-lisp
  (defun ic/org-is-active-task-p (&optional state)
    "Returns `t' if the current task is a member of
  `org-not-done-keywords'. When specified, use STATE as the active
  state, defaulting to `org-not-done-keywords'."
    (member (org-get-todo-state)
            (if state (list state) org-not-done-keywords)))

  (defun ic/org-any-active-parent-p ()
    "Return `t' if any parent task is an active task."
    (save-excursion
      (widen)
      (let (active-parent)
        (while (and (not active-parent)
                    (org-up-heading-safe))
          (when (ic/org-is-active-task-p)
            (setq active-parent t)))
        active-parent)))

  (defun ic/org-any-active-children-p (&optional state)
    "Return `t' when any descendant is an active task. When
    specified, use STATE as the active state, defaulting to
    `org-not-done-keywords'."
    (save-excursion
      (let ((subtree-end (save-excursion
                           (org-end-of-subtree t)))
            (child-regex (format "^\\*\\{%d,\\} "
                                 (+ 1 (org-current-level))))
            active-child)
        (while (and (not active-child)
                    (re-search-forward child-regex
                                       subtree-end t))
          (when (ic/org-is-active-task-p state)
            (setq active-child t)))
        active-child)))

  (defun ic/org-is-project-p ()
    "Return `t' when the current task is considered a project."
    (and (ic/org-is-active-task-p)
         (not (ic/org-any-active-parent-p))
         (ic/org-any-active-children-p)))

  (defun ic/org-is-stuck-project-p ()
    "Return `t' when the current task is considered a stuck
  project."
    (and (ic/org-is-project-p)
         (not (ic/org-any-active-children-p "NEXT"))))

  (defun ic/org-skip-nonstuck-projects ()
    (let ((debug-on-error t))
      (save-excursion
        (widen)
        (unless (ic/org-is-stuck-project-p)
          (or (outline-next-heading) (point-max))))))
#+END_SRC

**** Habits
#+BEGIN_SRC emacs-lisp
  (setq org-habit-preceding-days 7)
  (setq org-habit-following-days 1)
  (setq org-habit-graph-column 2)
  (setq org-habit-show-habits-only-for-today t)
  (setq org-habit-show-all-today t)

  ;; only show the first occurrence of a repeating task
  (setq org-agenda-show-future-repeats 'next)
#+END_SRC

**** Todo
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
    (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|"
              "CANCELLED(c@/!)" "PHONE" "MEETING" "HABIT(a)")))
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+END_SRC

**** Logging
Create a log on certain state changes inside the =LOGBOOK= drawer.
#+BEGIN_SRC emacs-lisp
  ;; log status changes
  (setq org-log-done 'time)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC

**** Capture
***** Templates
#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order nil)
  (setq ic/org-clock-in nil)
  (setq ic/org-clock-resume nil)

  (defun ic/org-capture-prompt (prompt symbol choices)
    "Call `(completing-read PROMPT CHOICES)' and save into SYMBOL.
  Inspired from: http://storax.github.io/blog/2016/05/02/org-capture-tricks/"
    (make-local-variable symbol)
    (set symbol (completing-read prompt choices)))

  (setq org-capture-templates
        `(("t" "todo" entry (file org-default-notes-file)
           "* TODO %?\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("T" "test org-protocol" entry (file org-default-notes-file)
           "* TODO %:description\n%U\n\n#+begin_quote\n%:initial\n#+end_quote\n/From: [[%:link][here]]./\n\n%?"
           :immediate-finish t
           )
          ("r" "reply" entry (file org-default-notes-file)
           "* TODO Reply to %:from on %:subject\nSCHEDULED: %t\n%u\n%a\n"
           :immediate-finish t
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("n" "note" entry (file org-default-notes-file)
           "* %? :note:\n%u\n"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("m" "meeting" entry (file org-default-notes-file)
           "* MEETING with %? :meeting:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("p" "phone call" entry (file org-default-notes-file)
           "* PHONE %? :phone:\n%u"
           ;; :clock-in ic/org-clock-in :clock-resume ic/org-clock-resume
           )
          ("b" "books")
          ("bp" "pleasure" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bP" "pleasure (already read)" entry (file+olp org-home-file "Books" "Pleasure")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("be" "enrichment" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bE" "enrichment (already read)" entry (file+olp org-home-file "Books" "Enrichment")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("bt" "technical" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book)
           :immediate-finish t
           :empty-lines-after 1)
          ("bT" "technical (already read)" entry (file+olp org-home-file "Books" "Technical")
           (function ic/org-capture-book-read)
           :immediate-finish t
           :empty-lines-after 1)
          ("H" "habit" entry (file org-default-notes-file)
           "* TODO %?\n%u\nscheduled: %(format-time-string \"<%y-%m-%d %a .+1d/3d>\")\n:properties:\n:style: habit\n:repeat_to_state: next\n:end:\n")
          ("R" "recipe" entry (file org-default-notes-file)
           "* %^{name}\n:PROPERTIES:\n:SOURCE: %^{source}\n:SERVINGS: %^{servings}\n:END:\n%U\n** Ingredients\n- %?\n** Steps\n-\n** Notes")
          ("J" "job" entry (file org-default-notes-file)
           "* TOAPPLY %^{company} - %^{title}\n%U\n[[%^{url}][Submission]]\n%?\n** Description\n%^{description}\n** Contact Info\n** Log\n")))

  ;; start capture in insert mode
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

***** Books
I want a system to pull in book information (isbn, authors, etc) based on a search query and generate an =org-mode= item.

****** Open Library
As =Goodreads= is no longer offering API access I had to research where to pull down book information. [[https://openlibrary.org/][OpenLibrary]] seems to be the best option currently. So let's create some functions to query it for book information.

First, we need some variables defined:
#+BEGIN_SRC emacs-lisp
  (defconst ic/openlibrary-base-endpoint
    "http://openlibrary.org")

  (defvar ic/openlibrary-max-results 100
    "Maximum results requested from OpenLibrary.")

  (defvar ic/openlibrary--use-cached-data nil
    "Store results from OpenLibrary in cache?")

  (defvar ic/openlibrary--query-string ""
    "Query string to search OpenLibrary for. Internal use only.")
#+END_SRC

We'll need some functions to query =OpenLibrary= and parse the results. We can get most of the data from the search query, only missing the description found in the =Work=, so we can make that call only when needed (after selecting an item in helm).
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--request (url &optional args)
    (let (result)
      (request
        url
        :params args
        :parser 'json-read
        :sync t
        :timeout 10
        :error (cl-function
                (lambda (&key error-thrown &allow-other-keys)
                  (error "error fetching (%s): %s"
                         url
                         (cdr error-thrown))))
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (setq result data))))
      result))
#+END_SRC

Now we'll need a function to take the raw data returned from =OpenLibrary= and translate it into a format more useful to us.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-search-results (data)
    "Take DATA in OpenLibrary search.json format and parse it into a list of
  ALISTs."
    (mapcar
     (lambda (doc)
       (cl-flet*
           ((to-list (vec) (append vec nil))
            (get (attr &optional alist) (assoc-default attr (or alist doc)))
            (get-list (attr &optional alist) (to-list (get attr (or alist doc))))
            (get-first (attr &optional alist) (car (get-list attr (or alist doc)))))
         `((title . ,(get 'title))
           (query-title . ,(s-replace-regexp " " "+" (get 'title)))
           (ol-work-id . ,(get 'key))
           (ol-author-ids . ,(get-list 'author_key))
           (edition-count . ,(get 'edition_count))
           (first-year-published . ,(get 'first_publish_year))
           (pages-median . ,(get 'number_of_pages_median))
           (public-scan . ,(not (eq (get 'public_scan_b) ':json-false)))
           (authors . ,(get-list 'author_name))
           (goodreads-id . ,(get-first 'id_goodreads))
           (librarything-id . ,(get-first 'id_librarything)))))
     (assoc-default 'docs data)))
#+END_SRC

Now, make another call to =LibraryThing= and check for =Work= data to add in.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--add-work-data (doc)
    "Query OpenLibrary for the work contained in DOC and add in any needed data."
    (let* ((data (ic/openlibrary--request
                  (concat "http://openlibrary.org"
                          (assoc-default 'ol-work-id doc)
                          ".json")))
           (desc-raw (assoc-default 'description data))
           (desc-value (if (eq (type-of desc-raw) 'cons)
                           (assoc-default 'value desc-raw)
                         desc-raw))
           (desc-clean (if desc-value
                           (replace-regexp-in-string
                            ;; OL links in [title](link format)
                            "\\[\\(.*\\)](\\(.*\\))"
                            ;; replace with org-mode format
                            "[[\\2][\\1]]"
                            ;; remove windows new lines
                            (replace-regexp-in-string "\u000d" "" desc-value))
                         nil)))
      (cons (cons 'description desc-clean)
            doc)))
#+END_SRC

****** Helm
We'll be using =helm= to narrow the results and provide fuzzy matching. Before we call =helm= though we need to prompt the user for a query string to send to =OpenLibrary=. Since =helm= takes over the minibuffer, we need to do this prior to calling =helm=. We also need to ensure the query string is available to the actual request function and =helm= expects it's =:candidates= function to accept zero parameters. So we'll set the global variable :( =ic/openlibrary--query-string= to the user's query and use that in the fetching function.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary-helm-find-book ()
    "Prompt user for query string to search OpenLibrary, then display helm buffer
  to select book. Returns an ALIST with OpenLibrary data."
    (interactive)
    (setq ic/openlibrary--query-string
          (read-from-minibuffer "Search OpenLibrary: "))
    (helm :sources
          (helm-build-sync-source
              (format "OpenLibrary (%s)" ic/openlibrary--query-string)
            :candidates 'ic/openlibrary--helm-candidates
            :candidate-number-limit ic/openlibrary-max-results
            :fuzzy-match t
            :coerce 'ic/openlibrary--add-work-data)
          :buffer "*helm openlibrary*"))
#+END_SRC

Now we need a function to query the search page from =OpenLibrary=. It uses the global variable =ic/openlibrary--query-string= to determine the query.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--helm-candidates ()
    "Searches OpenLibrary for `ic/openlibrary--query-string', returning data in
  `((DISPLAY . DATA) ...)' format for use as a helm source."
    (mapcar 'ic/openlibrary--parse-helm-format
            (ic/openlibrary--parse-search-results
             (ic/openlibrary--request
              (concat ic/openlibrary-base-endpoint "/search.json")
              `(("q" . ,(split-string ic/openlibrary--query-string " " t))
                ("limit" . ,ic/openlibrary-max-results)
                ("mode" . "everything"))))))
#+END_SRC

Finally, we need a function to take the data from =OpenLibrary= and return it in a (pretty) format that =helm= will use to display to the user.
#+BEGIN_SRC emacs-lisp
  (defun ic/openlibrary--parse-helm-format (doc)
    "Take data in OpenLibrary format and return in `(DISPLAY . DATA)' format
  needed for helm."
    (cons
     (concat (propertize (assoc-default 'title doc) 'face 'helm-ol-title)
             (propertize " :: " 'face 'helm-ol-separator)
             (propertize (string-join (assoc-default 'authors doc) ", ")
                         'face 'helm-ol-author)
             (propertize " [" 'face 'helm-ol-separator)
             (format "%s" (assoc-default 'first-year-published doc))
             (propertize "] -- " 'face 'helm-ol-separator)
             (propertize (format "%s editions" (assoc-default 'edition-count doc))
                         'face 'helm-ol-editions))
     doc))
#+END_SRC

****** Capture
Now, we need a function that takes the data from =OpenLibrary= and generates an =org-mode= element for us to use.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-capture-book (&optional already-read)
    "`org-capture' task for a new book. Prompts the user for a query string to
  search OpenLibrary against and generate an `org-mode' element from the resulting
    data."
    (let* ((result "")
           (doc (ic/openlibrary-helm-find-book)))
      (cl-flet* ((add (fmt &rest args)
                      (when (-all? 'identity args)
                        (setq result (concat result
                                             (apply 'format fmt args))))))
        (add "* %s %s :: %s [%s]\n"
             (if already-read "DONE" "TODO")
             (assoc-default 'title doc)
             (string-join (assoc-default 'authors doc) ", ")
             (assoc-default 'first-year-published doc))
        (add ":PROPERTIES:\n")
        (add ":TITLE: %s\n" (assoc-default 'title doc))
        (add ":AUTHORS: %S\n" (assoc-default 'authors doc))
        (add ":PAGES_MEDIAN: %s\n" (assoc-default 'pages-median doc))
        (add ":FIRST_YEAR_PUBLISHED: %s\n" (assoc-default 'first-year-published doc))
        (add ":PUBLIC_SCAN: %s\n" (assoc-default 'public-scan doc))
        (add ":OL_AUTHOR_IDS: %S\n" (assoc-default 'ol-author-ids doc))
        (add ":OL_WORK_ID: %s\n" (assoc-default 'ol-work-id doc))
        (add ":GOODREADS_ID: %s\n" (assoc-default 'goodreads-id doc))
        (add ":LIBRARYTHING_ID: %s\n" (assoc-default 'librarything-id doc))
        (add ":END:\n")
        (add "%%u\n\n")
        (add "#+BEGIN_QUOTE\n%s\n#+END_QUOTE\n\n" (assoc-default 'description doc))
        (add "** Links\n")
        (add "- [[http://openlibrary.org%s][OpenLibrary]]\n"
             (assoc-default 'ol-work-id doc))
        (dolist (tuple (-zip (assoc-default 'authors doc)
                             (assoc-default 'ol-author-ids doc)))
          (add "- [[http://openlibrary.org/authors/%s][OpenLibrary - %s]]\n"
               (cdr tuple) (car tuple)))
        (add (concat "- [[https://librarything.com"
                     (if-let (id (assoc-default 'librarything-id doc))
                         (format "/work/%s" id)
                       (format "/search.php?search=%s"
                               (assoc-default 'query-title doc)))
                     "][LibraryThing]]\n"))
        (when (assoc-default 'public-scan doc)
          (add (concat "- [[https://www.gutenberg.org/ebooks/search/?query=%s]"
                     "[Project Gutenberg]]\n")
             (assoc-default 'query-title doc)))
        (add "- [[https://www.overdrive.com/search?q=%s][Overdrive]]\n"
             (assoc-default 'query-title doc))
        (add (concat "- [[https://goodreads.com"
                     (if-let (id (assoc-default 'goodreads-id doc))
                         (format "/book/show/%s" id)
                       (format "/search?q=%s&search_type=books"
                               (assoc-default 'query-title doc)))
                     "][Goodreads]]\n"))
        (add "- [[https://amazon.com/s?k=%s][Amazon]]\n"
             (assoc-default 'query-title doc))
        (add "\n")
        (add "** Notes\n\n"))
      result))


  (defun ic/org-capture-book-read ()
    "Same as `ic/org-capture-book', but mark entry as DONE instead."
    (ic/org-capture-book t))
#+END_SRC

****** Faces
I like my =helm= searches to be pretty, so let's define some faces to use for that.
#+BEGIN_SRC emacs-lisp
  (defface helm-ol-title nil
    "Face used for OpenLibrary titles in a helm buffer.")

  (defface helm-ol-author nil
    "Face used for OpenLibrary authors in a helm buffer.")

  (defface helm-ol-editions nil
    "Face used for OpenLibrary edition counts in a helm buffer.")

  (defface helm-ol-seperator nil
    "Face used for OpenLibrary seperators in a helm buffer.")
#+END_SRC


***** Full Frame
The standard =org-capture= behavior is to split the window before capturing a task. When this is started from outside emacs a random buffer occupies half the frame. What I want is the capture buffer to take the full frame when starting the capture from outside emacs. My window manager will start the capture task with a frame name of =OrgCapture=. Because =org-capture= doesn't provide a hook where it splits the frame we'll need to advise it to ~(delete-other-windows)~ when our frame is =OrgCapture= and one of the following:

1. When choosing the capture template (buffer name: =*Org Select*=)
2. When inside the capture task (buffer name: =CAPTURE-<filename>=)

Finally, call ~(delete-frame)~ after the capture is finalized.

#+BEGIN_SRC emacs-lisp
  (defun ic/maybe-org-capture-delete-other-windows (buf)
    "Maximize frame when starting an external org-capture"
    (let* ((buffer-name (if (bufferp buf) (buffer-name buf) buf))
           (is-capture-frame (equal "OrgCapture" (frame-parameter nil 'name)))
           (is-capture-buffer (or (equal "*Org Select*" buffer-name)
                                  (string-match "^CAPTURE-" buffer-name))))
      (when (and is-capture-frame is-capture-buffer)
        (delete-other-windows))))
  (advice-add 'org-switch-to-buffer-other-window :after #'ic/maybe-org-capture-delete-other-windows)

  (defun ic/maybe-org-capture-delete-frame ()
    "Close the frame when finalizing an external org-capture"
    (when (equal "OrgCapture" (frame-parameter nil 'name))
      (delete-frame)))
  (add-hook 'org-capture-after-finalize-hook #'ic/maybe-org-capture-delete-frame)
#+END_SRC

**** Clocking (disabled)
#+BEGIN_SRC emacs-lisp :noweb-ref disabled
  (require 'org-clock)

  ;; resolve open clocks for any amount of time
  (setq org-clock-idle-time nil)
  ;; start new clocking immediatly after clocking out
  (setq org-clock-continuously t)
  ;; save current clock when emacs exits
  (setq org-clock-persist t)
  ;; change to NEXT state when starting a clock
  (setq org-clock-in-switch-to-state "NEXT")
  ;; change to TODO state when leaving a clock
  (setq org-clock-out-switch-to-state "TODO")
  ;; continue an open clock when checking into task
  (setq org-clock-in-resume t)
  ;; include current clock in reports
  (setq org-clock-report-include-clocking-task t)
  ;; save all clocks in the LOGBOOK drawer
  (setq org-clock-into-drawer "LOGBOOK")
  ;; only show today's clock in the modeline
  (setq org-clock-mode-line-total 'today)
  ;; persist open clocks
  (setq org-clock-persist-file (concat user-cache-directory "org-clock-save.el"))
  (org-clock-persistence-insinuate)

  (defun ic/org-clock-jump-to-current-clock ()
    "Jump to the currently active clock."
    (interactive)
    ;; why isn't this (interactive) already, ugh
    (org-clock-jump-to-current-clock))
#+END_SRC

**** Misc
Add some custom =<X= templates.
#+BEGIN_SRC emacs-lisp
  (mapc
   (lambda (struct)
     (push struct org-structure-template-alist))
   (list
    '("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
    '("y" "#+BEGIN_SRC yaml\n?\n#+END_SRC")
    ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; don't modify the task state when archiving
  (setq org-archive-mark-done nil)
  ;; catch modifying collapsed text
  (setq org-catch-invisible-edits 'error)
  ;; save id locations in a nicer place
  (setq org-id-locations-file (concat user-cache-directory "org-id-locations"))
#+END_SRC

It would be handy to have a function that would handle =org-mode= style time strings such as =+3d=, =-1w=, etc.
#+BEGIN_SRC emacs-lisp
  (defun ic-parse-org-date-string (time-str &optional next-day-when-no-time)
    "Translate TIME-STR into an emacs encoded time based on `org-read-date-*'
  syntax rules such as: +1d, -3w, etc. When NEXT-DAY-WHEN-NO-TIME is non-nil and
    TIME-STR does not contain a time component then use the next day. Returns nil
    on invalid time string."
    (setq org-time-was-given nil)
    (let* ((org-time (org-read-date-analyze
                      time-str
                      ;; encoded default time
                      (list 0 0 0 0)
                      ;; decoded default time
                      (list 0 0 0 0 0 0 0 0 0)))
           ;; `org-read-date-analyze' will return the default date if it failed to
           ;; parse a valid time string. We check for year 2000 because of the
           ;; following line in `org-read-date-analyze':
           ;;     (when (< year 100) (setq year (+ 2000 year)))
           (bad-time (list 0 0 0 0 0 2000))
           (encoded-time (apply #'encode-time org-time)))
      (cond ((equal org-time bad-time)
             (error "invalid time string: %s" time-str))
            ((or org-time-was-given (not next-day-when-no-time))
             ;; we either specified a time or we don't want to use the following day
             encoded-time)
            (t
             ;; we didn't specify a time and we want to use the *following* day
             (time-add encoded-time (* 24 60 60))))))
#+END_SRC

**** Code Execution
Don't prompt for code execution if we're in a file in certain locations.

#+BEGIN_SRC emacs-lisp
  (defvar ic/allow-babel-evaluate-directories
        '("~/org" "~/.etc"))

  (defun ic/org-confirm-babel-evaluate (_lang _body)
    (let ((filename (buffer-file-name))
          match)
      (dolist (path ic/allow-babel-evaluate-directories (not match))
        (when (string-prefix-p (expand-file-name path) filename)
          (setq match t)))))

  (setq org-confirm-babel-evaluate #'ic/org-confirm-babel-evaluate)
#+END_SRC

**** Exporting
Let's set some defaults. I don't want to see a table of contents, but I do want to see most everything else.
#+BEGIN_SRC emacs-lisp
  (setq org-export-with-toc nil)
  (setq org-export-with-timestamps t)
  (setq org-babel-default-header-args
        '((:session . "none")
          (:results . "replace")
          (:exports . "both")
          (:cache   . "no")
          (:noweb   . "no")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-publish-project-alist
        '(("recipes"
           :base-directory "~/org/home/food/"
           :base-extension "org"
           :publishing-directory "~/food/"
           :recursive t
           :publishing-function org-html-publish-to-html
           :headline-levels 4
           :auto-preamble t
           )))
  (add-hook 'org-export-before-parsing-hook 'ic/org-export-filter-recipes)
#+END_SRC

**** Snippets
By convention I title most of my snippets ={snippet}>= so I would like the =>= key to try and expand snippets automatically. When no snippet is found a regular =>= should be entered.
#+BEGIN_SRC emacs-lisp
  (defun ic/yas-expand-> ()
    (interactive)
    (insert ">")
    (yas-expand))
#+END_SRC

Based on [[https://emacs.stackexchange.com/questions/29758/yasnippets-and-org-mode-yas-next-field-or-maybe-expand-does-not-expand][this]] stackexchange post =org-mode= binds the tab key in such a way that =yas-snippets= can't use it. So we need the following to allow =TAB= to expand snippets while in =org-mode=.
#+BEGIN_SRC emacs-lisp
  (defun ic/set-org-mode-tab-key ()
    (add-to-list 'org-tab-first-hook 'yas-expand)
    ;; XXX is this needed?
    ;; (general-define-key yas-keymap
    ;;   "<tab>" 'yas-next-field)
    )

  (add-hook 'org-mode-hook 'ic/set-org-mode-tab-key)
#+END_SRC

**** Insert list item
I want to hit =M-RET= from either insert or normal mode and insert a new list item at the same level as the current item. The new item should also have a checkbox when the current item does.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-insert-item-dwim ()
    "Insert an org item, with optional checkbox, below current item."
    (interactive)
    (when-let (item-pos (org-in-item-p))
      (goto-char item-pos)
      (org-insert-item (org-at-item-checkbox-p))
      (org-metadown)))

  (defun ic/org-insert-item-dwim-go-insert-mode ()
    "Call `ic/org-insert-item-dwim' and enter insert mode."
    (interactive)
    (when (ic/org-insert-item-dwim)
      (evil-insert 0)))
#+END_SRC

**** Weekly Review
#+BEGIN_SRC emacs-lisp
  (defvar ic/weekly-reviews-directory "~/org/home/weekly-reviews")

  (defun ic/org-completed-date (heading)
    "Return the date of completion for HEADING."
    (org-timestamp-format (org-element-property :closed heading)
                          "%s"))

  (defun ic/org-completed-date-< (heading-left heading-right)
    "Return non-nil when the completed date of HEADING-LEFT is earlier than the
  completed date of HEADING-RIGHT."
    (let ((left-ts (ic/org-completed-date heading-left))
          (right-ts (ic/org-completed-date heading-right)))
      (cond ((and left-ts right-ts)
             (string< left-ts right-ts))
            (left-ts t)
            (right-ts nil))))

  (defun ic/org-element-get-link (elem &optional link-title)
    "Get a link (as a string) to the org-element ELEM."
    (let* ((marker (org-element-property :org-marker elem))
           (level (org-element-property :level elem))
           (title (org-element-property :raw-value elem))
           (search (org-with-point-at marker
                     (org-link-heading-search-string)))
           (file (buffer-file-name (marker-buffer marker)))
           (link 
            (format "[[%s][%s]]"
                    (format "file:%s::%s" file search)
                    (or link-title title))))
      (set-text-properties 0 (length link) nil link)
      link))

  (defun ic/weekly-review-items ()
    "Return a string containing all items needed for the weekly review in a form
  for direct insertion into a `yasnippit'."
    (let ((org-files (seq-filter #'file-exists-p
                                 (mapcar #'expand-file-name org-agenda-files)))
          current-date)
      (mapconcat (lambda (heading)
                   (let* ((ts (org-element-property :closed heading))
                          (date (format "%s-%s-%s"
                                        (org-element-property :year-start ts)
                                        (org-element-property :month-start ts)
                                        (org-element-property :day-start ts)))
                          (link (ic/org-element-get-link heading)))
                     (concat
                      (when (not (equal current-date date))
                        (setq current-date date)
                        (format-time-string "%A, %d %B %Y\n"
                                            (org-timestamp-to-time ts)))
                      "- " link)))
                 (org-ql-select org-files
                   '(and (tags "HOME")
                         (not (tags "noarchive"))
                         (todo "DONE" "APPLIED"))
                   :action 'element-with-markers
                   :sort #'ic/org-completed-date-<)
                 "\n")))

  (defun ic/weekly-review ()
    "Create a weekly review `org-mode' buffer with all completed tasks."
    (interactive)
    (let* ((year (format-time-string "%Y"))
           (week (format-time-string "%U"))
           (directory (format "%s/%s" ic/weekly-reviews-directory year))
           (filename (format "%s/weekly-review-%s.org" directory week)))
      (unless (file-directory-p directory)
        (make-directory directory t))
      (when (or (not (file-exists-p filename))
                (yes-or-no-p (format "Weekly review for week %s of %s already exists. Delete and re-create? "
                                     week year)))
        (find-file filename)
        (erase-buffer)
        (org-mode)
        (yas-expand-snippet (yas-lookup-snippet "weekly review"))
        (save-buffer))))
#+END_SRC

**** TODO Functions
Need to clean these up
#+BEGIN_SRC emacs-lisp
  ;;; functions taken from http://doc.norang.ca/org-mode.html

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))


  (defun ic/skip-non-archivable-tasks ()
    "Skip tasks that I don't want to archive"
    (or (ic/skip-old-meal-plans)
        (bh/skip-non-archivable-tasks)))


  (defun ic/skip-old-meal-plans ()
    "Skip over a task if it's 1) a meal plan and 2) scheduled before today."
    (save-restriction
      (widen)
      (let* ((tags (org-get-tags))
             (subtree-end (save-excursion (org-end-of-subtree t)))
             (scheduled (org-get-scheduled-time (point)))
             (yesterday (* 60 60 24 1))
             ;; HACK we check 24 hours ago rather than previous midnight
             (now (time-subtract (current-time) (seconds-to-time yesterday))))
        (if (and (member "cooking" tags)
                 (member "plan" tags)
                 scheduled
                 (time-less-p scheduled now))
            subtree-end
          nil))))


  (defun ic/org-recipe-publish-to-html (_plist org-filename target-dir)
    "Export ORG-FILENAME as html. Similar to `org-html-publish-to-html', but only exporting certain sections"
    (interactive)
    (let* ((base-name (file-name-sans-extension (file-name-nondirectory org-filename)))
           (target-filename (concat target-dir base-name ".html")))
      (with-temp-file target-filename
        (insert-file-contents org-filename)
        (goto-char (point-min))
        )
      )
    )


  (defun ic/org-export-filter-recipes (backend)
    "Filter out unwanted elements from org-mode recipes, but only when export as HTML."
    (when (equal backend 'html)
      (org-map-entries
       (lambda ()
         )
       ;; (lambda () (delete-region (point) (progn (forward-line) (point)))))
      )
    ))
#+END_SRC

*** org-keybinds
:PROPERTIES:
:header-args: :noweb-ref org-keybinds :tangle no
:END:

**** local-leader
Main =local-leader= key binds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    "'" 'org-edit-special
    ":" 'org-set-tags-command
    "^" 'org-sort
    "A" 'org-archive-subtree
    "D" 'org-insert-drawer
    "d" 'org-deadline
    "f" 'org-set-effort
    "H" 'org-shiftleft
    "J" 'org-shiftdown
    "K" 'org-shiftup
    "L" 'org-shiftright
    "l" 'org-open-at-point
    "N" 'widen
    "n" 'org-narrow-to-subtree
    "p" 'org-priority
    "P" 'org-set-property
    "r" 'org-refile
    "s" 'org-schedule
    "t" 'org-todo
    "w" 'org-save-all-org-buffers
    )
#+END_SRC

=,C= clocks keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "C"
    "" '(nil :which-key "clocks")
    "i" 'org-clock-in
    "j" 'ic/org-clock-jump-to-current-clock
    "o" 'org-clock-out
    "q" 'org-clock-cancel)
#+END_SRC

=,e= export keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "e"
    "" '(nil :which-key "export")
    "e" 'org-export-dispatch
    "T" 'org-babel-tangle-file
    "t" 'org-babel-tangle)
#+END_SRC

=,i= insert keybinds:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-mode-map
    :infix "i"
    "" '(nil :which-key "insert")
    "a" 'org-attach
    "f" 'org-footnote-new
    "l" 'org-insert-link
    "t" 'org-time-stamp
    "T" 'org-time-stamp-inactive
    "s" 'org-download-screenshot
    "y" 'org-download-yank
    )
#+END_SRC

TODO =,T= tables keybinds
#+BEGIN_SRC emacs-lisp

#+END_SRC

**** org-agenda-mode
#+BEGIN_SRC emacs-lisp
  (local-leader-keys org-agenda-mode-map
    "d" 'org-agenda-deadline
    "f" 'org-agenda-set-effort
    "p" 'org-agenda-priority
    "P" 'org-agenda-set-property
    "r" 'org-agenda-refile
    "s" 'org-agenda-schedule
    "t" 'org-agenda-todo
    )
#+END_SRC

**** org-src
=org-src-mode= bindings:
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
      :definer 'minor-mode
      :states 'normal
      :keymaps 'org-src-mode
      ;; ,c has which-key information from "clocks"
      "c" '(org-edit-src-exit :which-key "org-edit-src-exit")
      "k" 'org-edit-src-abort
      )
#+END_SRC

**** leader-key
=leader-key= keybinds:
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "o"
    "" '(nil :which-key "org-mode")
    "a" 'org-agenda
    "c" 'org-capture
    "j" 'ic/org-jump-in-buffer
    "J" 'ic/org-jump
    )

  (leader-keys
    :infix "oC"
    "" '(nil :which-key "clocks")
    "f" 'org-clock-modify-effort-estimate
    "i" 'org-clock-in
    "g" 'org-clock-goto
    "o" 'org-clock-out
    "l" 'org-clock-in-last
    "r" 'org-clock-report
    )
#+END_SRC

**** global
global keybinds:
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "<f12>" 'ic-open-org-agenda
   "M-<f12>" 'org-clock-goto
   )
#+END_SRC

**** normal mode
Here I have some custom normal mode navigation.
#+BEGIN_SRC emacs-lisp
  (general-define-key
    :states 'normal
    :keymaps 'org-mode-map

    "<left>"      'ic/outline-current-heading-or-up
    "<up>"        'ic/outline-current-heading-or-backward
    "<down>"      'org-forward-heading-same-level
    "<right>"     'outline-next-visible-heading

    "S-<left>"    'org-promote-subtree
    "S-<up>"      'org-move-subtree-up
    "S-<down>"    'org-move-subtree-down
    "S-<right>"   'org-demote-subtree

    "C-S-<left>"  'org-do-promote
    "C-S-<right>" 'org-do-demote

    "M-<return>" 'ic/org-insert-item-dwim-go-insert-mode
    )
#+END_SRC

**** insert mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
      :states 'insert
      :keymaps 'org-mode-map
      ">" 'ic/yas-expand->
      "M-<return>" 'ic/org-insert-item-dwim
      )
#+END_SRC

** org-bullets
Let's have some fancy heading bullets.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("‚Ä¢"))
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-protocol
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

** org-roam
Let's see what this is all about.
#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :demand t
    :init
    (setq org-roam-v2-ack t)

    :custom
    (org-roam-directory "~/org/home/roam")
    (org-roam-db-location
     (concat user-cache-directory "org-roam.db"))
    (org-roam-completion-everywhere t)

    :config
    (org-roam-setup)
    (require 'org-roam-protocol)
    (setq org-roam-capture-templates
          `(("p" "permanent zettel" plain "%U\n\n%?"
             :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}")
             :unnarrowed t)

            ("t" "task zettel" entry "* TODO ${title}\n:PROPERTIES:\n:ID: %(org-id-new)\n:END:\n%U\n\n%?"
             :target (file+head "zetian-tasks.org"
                                "#+title: All My Tasks\n#+category: task\n#+filetags: :%(if at-home \"HOME\" \"WORK\"):agenda:\n#+startup: content")
             :unnarrowed nil
             :empty-lines-before 1)

            ("b" "book" plain
             (function ic/org-capture-book)
             :target (file "%<%Y%m%d%H%M%S>-${slug}.org")
             :unnarrowed t)

            ("a" "author" plain "%U\n\n%?"
             :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+filetags: :author:")
             :unnarrowed t)

            ("l" "literature zettel" plain
             ,(concat "%U\n\n"
                      "#+begin_quote\n%i#+end_quote\n"
                      "/From %(ic/org-roam-node-string-immediate)/\n\n"
                      "%?"
                      )
             :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+filetags: :lit:")
             :unnarrowed t)

            ))

    (setq org-roam-capture-ref-templates
          `(("W" "web zettel (org-capture)" plain
             ,(concat "%U\n\n"
                      "#+begin_quote\n%:initial\n#+end_quote\n"
                      "/From the webpage [[%:link][${title}]]/\n\n%?"
                      )
             :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org%(ic/org-roam-set-link-props \"${title}\")"
                                ":PROPERTIES:\n:REF_NUMBER: %:ref-number\n\:END:\n#+title: ${title} [%:ref-number]\n#+filetags: :lit:web:")
             :unnarrowed t
             :immediate-finish t)))

    :general
    (general-define-key
     :states 'insert
     :keymaps 'org-mode-map
     "TAB" 'ic/org-roam-maybe-expand
     )
    (general-define-key
     :keymaps 'global-map
     "<f2>" 'org-roam-capture)
    (leader-keys
      :infix "on"
      "" '(nil :which-key "org-roam")
      "b" 'org-roam-buffer-toggle
      "c" 'org-roam-capture
      "D" 'org-roam-db-diagnose-node
      "f" 'org-roam-node-find
      "i" 'org-roam-node-insert
      "I" 'org-roam-node-insert-immediate
      "p" 'my/org-roam-find-project
      )
    (leader-keys
      :infix "z"
      "" '(nil :which-key "zetian")
      "b" 'org-roam-buffer-toggle
      "D" 'org-roam-db-diagnose-node
      "i" 'org-roam-node-insert
      "I" 'org-roam-node-insert-immediate
      "u" 'org-roam-ui-open
      "z" 'org-roam-node-find
      )
    (leader-keys
      :infix "zc"
      "" '(nil :which-key "capture")
      "c" 'org-roam-capture
      "b" 'ic/org-roam-capture-book
      )
    (leader-keys
      :infix "zf"
      "" '(nil :which-key "find")
      "f" #'zetian-node-find
      "a" #'zetian-find-author
      "b" #'zetian-find-book
      "l" #'zetian-find-link-to
      "L" #'zetian-find-link-from
      "t" #'zetian-find-task-open
      )
    (leader-keys
      :infix "zfT"
      "" '(nil :which-key "tasks")
      "a" #'zetian-find-task
      "l" #'zetian-find-task-open-link
      "n" #'zetian-find-task-next
      "o" #'zetian-find-task-open
      "p" #'zetian-find-task-open-project
      "T" #'zetian-find-task
      ))
#+END_SRC

When I call =org-roam-node-find= and the node is an =org-mode= element rather than a file. I want my view narrowed to that specific element.
#+BEGIN_SRC emacs-lisp
  (defun zetian-node-find (&optional node)
    "Act like `org-roam-node-find', but create a narrowed indirect buffer when
    visiting an element (as opposed to a file)."
    (interactive)
    (if node
        (org-roam-node-visit node nil t)
      (org-roam-node-find))
    (let ((elem (org-element-at-point)))
      (when (equal 'headline (org-element-type elem))
        (let* ((buf-name (format "zetian: %s" (org-element-property :title elem)))
               (buffer (get-buffer buf-name)))
          (if (buffer-live-p buffer)
              (pop-to-buffer-same-window buffer)
            (setq buffer (make-indirect-buffer (current-buffer) buf-name t))
            ;; hide parent buffer
            (bury-buffer)
            (pop-to-buffer-same-window buffer)
            (widen)
            (org-narrow-to-subtree))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun zetian-find-book ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find '(and (tag "book")
                              (not (tag "lit")))
                        "Zetian book: "))

  (defun zetian-find-author ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find '(tag "author")
                        "Zetian author: "))

  (defun zetian-find-task ()
    "Search zetian for a task and navigate to buffer."
    (interactive)
    (zetian-search-find '(category "task")
                        "Zetian task: "))

  (defun zetian-find-task-next ()
    "Search zetian for a task and navigate to buffer."
    (interactive)
    (zetian-search-find '(and (category "task")
                              (todo "NEXT"))))

  (defun zetian-find-task-open ()
    "Search zetian for a book and navigate to buffer."
    (interactive)
    (zetian-search-find '(and (category "task")
                              (or (todo "TODO")
                                  (todo "NEXT")))
                        "Zetian open task: "))

  (defun zetian-find-task-open-project (&optional project-name)
    "Find all open tasks that link to PROJECT-NAME. Prompt user if NIL."
    (interactive)
    (let ((project (or project-name
                       (org-roam-node-title
                        (zetian-search
                         '(tag "project")
                         "Zetian project: ")))))
      (zetian-search-find `(and (category "task")
                                (or (todo "TODO")
                                    (todo "NEXT"))
                                (links-to ,project))
                          (format "Zetian open tasks that link to %S: " project))))

  (defun zetian-find-task-open-link (&optional node-name)
    "Find all open tasks that link to NODE-NAME. Prompt user if NIL."
    (interactive)
    (let ((node (or node-name
                    (org-roam-node-title
                     (org-roam-node-read)))))
      (zetian-search-find `(and (category "task")
                                (or (todo "TODO")
                                    (todo "NEXT"))
                                (links-to ,node))
                          (format "Zetian open tasks that link to %S: " node))))

  (defun zetian-find-link-to (&optional node-name)
    "Search zetian for nodes that link to NODE-NAME, prompt for name if NIL."
    (interactive)
    (let ((node (or node-name
                    (org-roam-node-title (org-roam-node-read)))))
      (zetian-search-find `(links-to ,node)
                          (format "Zetian nodes that link to %S: " node))))

  (defun zetian-find-link-from (&optional node-name)
    "Search zetian for nodes that NODE-NAME links to, prompt for name if NIL."
    (interactive)
    (let ((node (or node-name
                    (org-roam-node-title (org-roam-node-read)))))
      (zetian-search-find `(links-from ,node)
                          (format "Zetian nodes that %S links to: " node))))
#+END_SRC

I want an easy way to define functions to search through =zetian= for specific content. These should be usable directly in =(leader-keys)= calls.
#+BEGIN_SRC emacs-lisp
  (defmacro ic/org-roam-node-func-find-by-tag (tag)
    "Return a function that will search `zetian' for nodes with tag TAG."
    (let ((func-name (format "zettel-tag-%s" tag))
          (func-doc (format "Search for all `zetian' nodes matching tag %S" tag)))
      `(defun ,(intern func-name) ()
         ,func-doc
         (interactive)
         (org-roam-node-find
          nil
          nil
          #'(lambda (node) (member ,tag (org-roam-node-tags node)))))))

  (defmacro ic/org-roam-node-func-find-by-property (prop value)
    "Return a function that will search `zetian' for nodes with property PROP
    matching VALUE."
    (let ((func-name (format "zettel-%s-%s" (downcase prop) (downcase value)))
          (func-doc (format "Search for all `zetian' nodes with property %S
    matching %S" prop value)))
      `(defun ,(intern func-name) ()
         ,func-doc
         (interactive)
         (org-roam-node-find
          nil
          nil
          #'(lambda (node)
              (equal ,value
                     (assoc-default
                      ,prop
                      (org-roam-node-properties node))))))))
#+END_SRC

I want a way to search through =zetian= in a fast, easy, and general manor.
#+BEGIN_SRC emacs-lisp
  (defvar zetian--readline-histories nil
    "An ALIST of histories to use with `completing-read'.")

  (defun zetian-search (query &optional prompt)
    "Search through all of `zetian', return all nodes matching QUERY."
    (let* ((nodes (zetian--perform-query query))
           (query-s (prin1-to-string query))
           (history-item (assoc query-s zetian--readline-histories))
           (history (cdr history-item))
           (real-completing-read (symbol-function 'completing-read)))
      (cl-letf (((symbol-function 'org-roam-node-list)
                 (lambda () nodes))
                ((symbol-function 'completing-read)
                 (lambda (&rest args)
                   ;; add our custom prompt
                   (setf (nth 0 args) (or prompt
                                        (format "Zetian %s: " query-s)))
                   ;; add our custom history
                   (setf (nth 5 args) history)
                   (prog1
                       (apply real-completing-read args)
                     ;; save history
                     (if history-item
                         (setcdr history-item history)
                       (push (cons query-s history)
                             zetian--readline-histories))))))
        (org-roam-node-read))))

  (defun zetian-search-find (query &optional prompt)
    "Search zetian for QUERY and navigate to chosen buffer."
    (interactive)
    (when-let ((node (zetian-search query prompt)))
      (zetian-node-find node)))

  (defun zetian--perform-query (query)
    "Run QUERY against `org-roam' database."
    (mapcar
     (lambda (id)
       (org-roam-populate (org-roam-node-create :id (car id))))
     (org-roam-db-query
      (zetian--unroll-query query))))

  (defun zetian--unroll-query (query)
    "Translate QUERY into a suitable `emacsql' query."
    `[:select [nodes:id]
      :from nodes
      :where ,(zetian--unroll-query-impl query)])

  (defun zetian--unroll-query-impl (query)
    (unless (and (listp query) query)
      (error "QUERY must be an sexp, received: %S" query))
    (pcase (car query)
      ('and
       (cons 'and (mapcar #'zetian--unroll-query-impl (cdr query))))
      ('or
       (cons 'or (mapcar #'zetian--unroll-query-impl (cdr query))))
      ('not
       (list 'not (zetian--unroll-query-impl (cadr query))))
      ('tag
       `(in nodes:id [:select [tags:node-id]
                      :from tags
                      :where (= tags:node-id nodes:id)
                      :and (= tags:tag ,(cadr query))]))
      ('title
       `(like title ,(zetian--query-quote-like (cadr query) t)))
      ('title-like
       `(like title ,(zetian--query-quote-like (cadr query))))
      ('todo
       `(like todo ,(zetian--query-quote-like (cadr query))))
      ('priority
       `(= priority ,(string-to-char (upcase (cadr query)))))
      ((or 'scheduled 'deadline)
       (let ((col (make-symbol (format "nodes:%s" (car query)))))
         (pcase (cadr query)
           ('after
            `(> ,col ,(zetian--query-parse-date (caddr query))))
           ('before
            `(< ,col ,(zetian--query-parse-date (caddr query))))
           ;; ('on-or-after
           ;;  `(>= ,col ,(zetian--query-parse-date (caddr query))))
           ;; ('on-or-before
           ;;  `(<= ,col ,(zetian--query-parse-date (caddr query))))
           (' on
              `(<= ,(zetian--query-parse-date (caddr query))
                   ,col
                   ,(zetian--query-parse-date (caddr query) t)))
           ('between
            `(<= ,(zetian--query-parse-date (caddr query))
                 ,col
                 ,(zetian--query-parse-date (cadddr query) t)))
           (_
            (error "invalid operation for %S: %S" (car query) (cadr query))))))
      ('prop
       `(like
         nodes:properties
         ,(zetian--query-quote-like (cons (cadr query) (caddr query)))))
      ('category
       (zetian--unroll-query-impl `(prop "CATEGORY" ,(cadr query))))
      ((or 'links-to 'links-from)
       (let ((col1 (if (eq 'links-to (car query)) 'links:source 'links:dest))
             (col2 (if (eq 'links-to (car query)) 'links:dest 'links:source)))
         `(in nodes:id [:select [,col1]
                        :from links
                        :where (= ,col1 nodes:id)
                        :and (= links:type "id")
                        ;; TODO this could be a sql sub-query
                        :and (= ,col2
                                ,(org-roam-node-id
                                  (org-roam-node-from-title-or-alias
                                   (cadr query))))])))
      (_
       (error "invalid search key: %S" (car query)))))

  (defun zetian--query-quote-like (obj &optional exact)
    "Return quoted OBJ in a form for `emacsql' query: (like column
  ,(zetian--query-quote-like (cons 'a 'b)))"
    (let ((double-quote "\"")
          (maybe-percent (unless exact "%")))
      `(quote ,(if (stringp obj)
                   (concat double-quote maybe-percent
                           obj
                           maybe-percent double-quote)
                 (concat maybe-percent
                         (prin1-to-string obj)
                         maybe-percent)))))

  (defun zetian--query-parse-date (date &optional next-day-when-no-time)
    (format-time-string "%Y-%m-%dT%H:%M:%S%z"
                        (ic-parse-org-date-string
                         date
                         next-day-when-no-time)))
#+END_SRC

I want a way to get the number of times I've made a =literature= zettel against a specific work. This will let me add a count to the title of each zettel. Hopefully that will make them easier to reference.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-roam-filter-by-title (title)
    "Create a filter for `ic/org-roam-filter' that will only list nodes with exact
  title TITLE."
    (lambda (node)
      (equal title (org-roam-node-title node))))

  (defun ic/org-roam-filter-by-title-prefix (prefix &optional case-sensitive)
    "Create a filter for `ic/org-roam-filter' that returns nodes whose title
  starts with PREFIX."
    (lambda (node)
      (string-prefix-p prefix
                       (org-roam-node-title node)
                       (not case-sensitive))))

  (defun ic/org-roam-filter (filter)
    "Returns all nodes that satisfy predicate FILTER."
    (seq-filter
     filter
     (org-roam-node-list)))

  (defun ic//org-roam-get-node-ref-number (node)
    "Return the org property 'REF_NUMBER' for NODE."
    (save-window-excursion
      (with-temp-buffer
        (insert-file-contents (org-roam-node-file node))
        (if-let (values (org-property-values "REF_NUMBER"))
            (string-to-number (car values))
          0))))

  (defun ic/org-roam-next-literature-number (title)
    "Return the next title number for capturing a literature zettel against
  TITLE."
    (if-let (refs (mapcar #'ic//org-roam-get-node-ref-number
                          (ic/org-roam-filter
                           (ic/org-roam-filter-by-title-prefix title))))
        (+ 1 (-max refs))
      1))

  (defun ic/org-roam-set-link-props (title)
    "Set any relevant org-link properties for TITLE, currently only `:ref-number'."
    (message (format "SETTING %S on %S"
                     (ic/org-roam-next-literature-number title)
                     title))
    (org-link-add-props
     :ref-number (number-to-string (ic/org-roam-next-literature-number title)))
    ;; return empty string so we don't mess up a template
    "")
#+END_SRC

Let's migrate my book importing code to =org-roam=.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-roam-format-book-template-header (doc)
    "Create a template header from DOC suitable for `org-roam-capture-templates'."
    (with-temp-buffer
      (unless (yas-minor-mode 1)
        (error "failed to load yas-minor-mode"))
      (let ((snippet-env
             (mapcar (lambda (c)
                       (list (car c)
                             (if (listp (cdr c))
                                 `(quote ,(cdr c))
                               (cdr c))))
                     book)))
        (yas-expand-snippet
         (concat
          ":PROPERTIES:\n"
          ":TITLE: `title`\n"
          ":AUTHORS: `(mapcar (lambda (a) (format \"%S\" a)) authors)`\n"
          ":PAGES_MEDIAN: `pages-median`\n"
          ":END:\n"
          "#+title: `title`\n"
          "#+filetags: :book:HOME:agenda:")
         nil
         nil
         snippet-env))
      (buffer-string)))

  (defun ic/org-roam-format-book-template-body (doc)
    "Create a template body from DOC suitable for `org-roam-capture-templates'."
    (with-temp-buffer
      (unless (yas-minor-mode 1)
        (error "failed to load yas-minor-mode"))
      (let ((snippet-env
             (append
              (mapcar (lambda (c)
                        (list (car c)
                              (if (listp (cdr c))
                                  `(quote ,(cdr c))
                                (cdr c))))
                      book)
              `((authors-pretty
                 ,(string-join (assoc-default 'authors doc)
                               ", and "))
                (authors-pretty-links
                 ,(string-join (mapcar
                                (lambda (author)
                                  (ic/org-roam-node-link-immediate author "a"))
                                (assoc-default 'authors doc))
                               ", and "))

                (author-ol-links
                 ,(string-join
                   (mapcar
                    (lambda (tuple)
                      (format "- [[https://openlibrary.org/authors/%s][OpenLibrary - %s]]"
                              (cdr tuple)
                              (car tuple)))
                    (-zip (assoc-default 'authors doc)
                          (assoc-default 'ol-author-ids doc)))
                   "\n"))
                (lt-uri
                 ,(if-let (id (assoc-default 'librarything-id doc))
                      (format "/work/%s" id)
                    (format "/search.php?search=%s"
                            (assoc-default 'query-title doc))))
                (gr-uri
                 ,(if-let (id (assoc-default 'goodreads-id doc))
                      (format "/book/show/%s" id)
                    (format "/search?q=%s&search_type=books")))))))
        (yas-expand-snippet
         (concat
          "\%U\n\n"
          "/`title`/ by `authors-pretty-links`.\n\n"
          "#+begin_quote\n`description`\n#+end_quote\n\n"
          "- [[https://librarything.com`lt-uri`][LibraryThing]]\n"
          "- [[https://openlibrary.org`ol-work-id`][OpenLibrary - `title`]]\n"
          "`author-ol-links`\n"
          "- [[https://www.overdrive.com/search?q=`query-title`][Overdrive]]\n"
          "- [[https://goodreads.com`gr-uri`][Goodreads]]\n"
          "- [[https://amazon.com/s?k=`query-title`][Amazon]]\n\n"
          "* TODO `title` :: `authors-pretty` [`first-year-published`]")
         nil
         nil
         snippet-env))
      (buffer-string)))

  (defun ic/org-roam-capture-book ()
    "`org-roam-capture' to import a new book from OpenLibrary."
    (interactive)
    (let* ((book (ic/openlibrary-helm-find-book))
           (title (assoc-default 'title book))
           (template `("X" "capture book template" plain
                      ,(ic/org-roam-format-book-template-body book)
                      :target (file+head
                               "%<%Y%m%d%H%M%S>-${slug}.org"
                               ,(ic/org-roam-format-book-template-header book)))))
      (cl-letf ((org-roam-capture-templates
                 (list template)))
        (if-let ((node (ic/org-roam-node-create title)))
            (find-file (org-roam-node-file node))))))
#+END_SRC

I want a way to know if we're editing an =org-roam= buffer:
#+BEGIN_SRC emacs-lisp
  (defun ic/org-roam-filename-p (file-name)
    "Return `t' if FILE-NAME refers to an `org-roam' file."
    (string-prefix-p (expand-file-name org-roam-directory)
                     (expand-file-name file-name)))
#+END_SRC

When I hit =TAB= and I'm in =org-roam-mode= I want to call =(company-expand)=, otherwise if I'm in =org-mode= I want to call the default =(org-cycle)=.
#+BEGIN_SRC emacs-lisp
  (defun ic/org-roam-maybe-expand (&optional arg)
    "Call `company-complete' when in `org-roam-mode' otherwise call `org-cycle'."
    (interactive "P")
    (if (not (ic/org-roam-filename-p (buffer-file-name (current-buffer))))
        (org-cycle arg)
      (unless company-mode
        (company-mode))
      (company-complete)))
#+END_SRC

Much inspiration was taken from [[https://systemcrafters.net/build-a-second-brain-in-emacs/5-org-roam-hacks/][here]].
#+BEGIN_SRC emacs-lisp :lexical yes
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))


  (defun ic/org-roam-node-create (title &optional template-key)
    "Return `org-roam' node for TITLE, creating it if necessary."
    (if-let (node (org-roam-node-from-title-or-alias title))
        node
      (let ((template (append
                       (if template-key
                           (assoc template-key org-roam-capture-templates)
                         (car org-roam-capture-templates))
                       '(:immediate-finish t))))
        (when (org-roam-capture-
               :node (org-roam-node-create :title title)
               :templates (list template))
          (org-roam-node-from-title-or-alias title)))))


  (defun ic/org-roam-node-link-immediate (title &optional template-key)
    "Create (if necessary) and return an `org-mode' link to TITLE node. Use
  TEMPLATE-KEY to choose a template from `org-roam-capture-templates' to use when creating."
    (when-let (node (ic/org-roam-node-create title template-key))
      (org-link-make-string
       (concat "id:" (org-roam-node-id node))
       (org-roam-node-formatted node))))


  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun ic/org-roam-refresh-agenda-list ()
    (interactive)
    (mapc (lambda (file-name)
            (add-to-list 'org-agenda-files file-name))
          (my/org-roam-list-notes-by-tag "agenda")))
  ;; update agenda files on load
  (ic/org-roam-refresh-agenda-list)

  (defun ic/org-roam-update-agenda-files-once-hook ()
    "Calls `ic/org-roam-refresh-agenda-list' and removes itself from
  `org-capture-after-finalize-hook'."
    (ic/org-roam-refresh-agenda-list)
    (remove-hook 'org-capture-after-finalize-hook
                 #'ic/org-roam-update-agenda-files-once-hook))

  (defun my/org-roam-find-project ()
    (interactive)
    (add-hook 'org-capture-after-finalize-hook
              #'ic/org-roam-update-agenda-files-once-hook)
    (org-roam-node-find
     nil
     nil
     (my/org-roam-filter-by-tag "project")
     :templates
     `(("p" "project" plain "\n\n%?\n\n* Tasks\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                           ,(concat "#+title: ${title}\n"
                                    "#+category: ${title}\n"
                                    "#+filetags: :project:agenda:\n"
                                    "#+startup: content\n"))
        :unnarrowed t))))
#+END_SRC

** org-roam-ui
#+BEGIN_SRC emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+END_SRC

** org-ql
Let's try having a nice search interface for =org-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package org-ql)
#+END_SRC

** TODO projectile
=projectile= makes it easy to perform actions on a project, like grepping or listing relevant files or running tests/compiling. It also keeps buffers grouped by project so navigating between them is pleasant inside a project.

One thing I wish it did was restore the window layout when opening a project. I've tried to use =persp-mode= for that, but it's heavy-weight and difficult to configure for my use. The author's =persp-mode-projectile-bridge= package has some design choices I don't care for. Such as prefixing perspectives with =[p]= (configurable at least), and /setting the window config to not permit saving to disk/ (huh?).

All I want is to restore the window layout, as best as possible, to as close as it was to the previous time I visited the project. Luckily, emacs has a couple of functions to save/restore the window configuration builtin.

So, we can save the window configuration when either moving to a new project or closing emacs, then we can load the new project's layout. When loading, any buffer that is a part of the window configuration, but not active will cause that window to not load. So we need to make sure we re-visit any buffers that were active when that configuration was saved.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package projectile
    :demand t
    :init
    ;; ensure projectile saves its files in a nice location
    (setq projectile-cache-file
          (concat user-cache-directory "projectile.cache"))
    (setq projectile-known-projects-file
          (concat user-cache-directory "projectile-bookmarks.eld"))
    ;; ensure we save window config files in a nice location
    (defvar ic/projectile-window-default-name "default")
    (defvar ic/projectile-window-save-dir
      (concat user-cache-directory "projectile-windows/"))

    :config
    <<projectile-config>>

    :hook
    ;; we want to save window config when switching projects and closing emacs
    ((kill-emacs projectile-before-switch-project) . #'ic/projectile-window-save-layout)

    :general
    ;; XXX
    (leader-keys
      "p" 'projectile-command-map)
    )
#+END_SRC

*** projectile-config
:PROPERTIES:
:header-args: :noweb-ref projectile-config :tangle no
:END:

We need a couple of functions to walk through the window state data structure as returned by =(window-state-get)=. Shamelessly stolen from [[https://depp.brause.cc/eyebrowse/][eyebrowse]].
#+BEGIN_SRC emacs-lisp
  ;; eyebrowse functions taken from: https://depp.brause.cc/eyebrowse/
  (defun eyebrowse--dotted-list-p (list)
    "Non-nil if LIST is terminated by a non-nil value."
    (cdr (last list)))

  (defun eyebrowse--walk-window-config (window-config function)
    "Walk through WINDOW-CONFIG and apply FUNCTION to each leaf."
    (dolist (item window-config)
      (when (consp item)
        (when (symbolp (car item))
          (funcall function item))
        (when (and (consp (cdr item))
                   (not (eyebrowse--dotted-list-p (cdr item))))
          (eyebrowse--walk-window-config (cdr item) function)))))
#+END_SRC

Next, a couple functions to walk through the window state data structure. The first, will replace any buffers that are in the (loading) window state, but are not active are replace with the =*scratch*= buffer. This is because when emacs encounters a buffer that is in the window state, but is not active that window is not loaded. I at least want a window restored, so replace the buffer with something harmless.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--replace-dead-buffers (layout)
    "Replace any unloadable buffers in LAYOUT with *scratch*."
    (let ((replaced-buffers '()))
      (eyebrowse--walk-window-config
       layout
       (lambda (item)
         (when (eq 'buffer (car item))
           (let ((buffer-name (cadr item)))
             (unless (get-buffer buffer-name)
                 (add-to-list 'replaced-buffers buffer-name)
                 (message "Replaced %s buffer with *scratch*" buffer-name)
                 (setf (cadr item) "*scratch*"))))))
      (when replaced-buffers
        (let ((n (length replaced-buffers)))
          (message "Unable to restore %d buffer%s: %s"
                   n
                   (if (> n 1) "s" "")
                   (s-join ", " replaced-buffers))))))
#+END_SRC

The next function will return a list of full paths for any visible buffer (i.e. it exists in the window state) that is visiting a file. We want to save these paths along with the window state so that we can restore the buffers upon loading.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--full-buffer-paths (layout)
    "Return a list of full paths for any visible buffer in LAYOUT
  visiting a file."
    (let ((full-paths '()))
      (eyebrowse--walk-window-config
       layout
       (lambda (item)
         (when (eq 'buffer (car item))
           (when-let ((buffer (get-buffer (cadr item))))
             (when-let ((path (buffer-file-name buffer)))
               (add-to-list 'full-paths path))))))
      full-paths))
#+END_SRC

A helper function to return the filename of where we should store the project's window state.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--get-filename ()
    "Return the filename for the active project."
    (let ((project (and projectile-mode
                        (projectile-project-name))))
      (concat ic/projectile-window-save-dir
              (or project ic/projectile-window-default-name))))
#+END_SRC

Finally the pair of function to save/restore the window state. Here we store a cons cell of the format =(<full paths of active buffers> . <window state>)= in the file specified by =ic/projectile-window--get-filename=. When loading, we ensure we visit any files listed and then restore the window state.
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window-save-layout ()
    "Save the active window's layout to disk. The filename is based
  on the active `projectile' project."
    (interactive)
    ;; make parent directory, if needed
    (unless (file-directory-p ic/projectile-window-save-dir)
      (make-directory ic/projectile-window-save-dir t))
    (let* ((layout (window-state-get nil t))
           (paths (ic/projectile-window--full-buffer-paths layout))
           (filename (ic/projectile-window--get-filename)))
      (with-temp-file filename
        (insert (prin1-to-string
                 (cons paths layout))))))

  (defun ic/projectile-window-load-layout ()
    "Restore the current `projectile' project's window layout from
  disk."
    (interactive)
    (let ((filename (ic/projectile-window--get-filename))
          (project (or (and projectile-mode (projectile-project-name))
                       ic/projectile-window-default-name)))
      (if (file-exists-p filename)
          (with-temp-buffer
            (insert-file-contents-literally filename)
            (let* ((data (read (current-buffer)))
                   (paths (car data))
                   (layout (cdr data)))
              ;; ensure known files are loaded
              (mapc #'find-file paths)
              ;; and any buffers not know are replaced with *scratch*
              (ic/projectile-window--replace-dead-buffers layout)
              ;; ensure we start from a single window
              (delete-other-windows)
              ;; and restore what we had
              (window-state-put layout (frame-root-window) 'safe)
              t))
        (message "No layout found for '%s' project" project)
        nil)))
#+END_SRC

When we open a new project =projectile= will call =projectile-switch-project-action=, by default it's bound to =projectile-find-file=. If we were able to load a saved layout then we already have open buffers. So we only need to prompt for a file if this is a new project (i.e. no layout found).
#+BEGIN_SRC emacs-lisp
  (defun ic/projectile-window--find-file-maybe ()
    "Call `projectile-find-file' if we couldn't load a window config,
  do nothing if we did."
    (interactive)
    (unless (ic/projectile-window-load-layout)
      (call-interactively 'projectile-find-file)
      (delete-other-windows)))

  (setq projectile-switch-project-action 'ic/projectile-window--find-file-maybe)
#+END_SRC

Now we can finally enable =projectile=.
#+BEGIN_SRC emacs-lisp
  (projectile-mode 1)
#+END_SRC

*** TODO save layout when =find-file='ing away 

** requests
=emacs-request= is a library for making HTTP requests easily.
#+BEGIN_SRC emacs-lisp
  (use-package request)
#+END_SRC

** smartparens
Keep my toe-nail clippings in balance.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :demand t
    :config
    (require 'smartparens-config)
    (smartparens-global-strict-mode 1)
    ;; don't run smartparens in the minibuffer
    (add-hook 'minibuffer-mode-hook 'turn-off-smartparens-strict-mode)

    :general
    (general-define-key
     :keymaps '(emacs-lisp-mode-map list-interaction-mode-map)
     :states '(normal motion)
     "^" #'sp-backward-up-sexp))
#+END_SRC

** spaceline
I want a pretty mode-line. Note: most of the configuration happens in the =spaceline-all-the-icons= package.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
      :config
      ;; use a custom mode-line while in helm
      (spaceline-helm-mode 1)

      ;; use pretty separators
      (setq powerline-default-separator 'contour)

      ;; change face based on evil state
      (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)

      ;; ensure the mode-line is re-compiled when switching themes
      (advice-add 'load-theme :after
                  (lambda (&rest args)
                    (spaceline-compile))))
#+END_SRC

** spaceline-all-the-icons
#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package spaceline-all-the-icons
      :after (all-the-icons spaceline)
      :config
      <<spaceline-ati-config>>
      )
#+END_SRC

*** spaceline-ati-config
:PROPERTIES:
:header-args: :noweb-ref spaceline-ati-config :tangle no
:END:

By default =all-the-icons= returns an object without an =:inherit= property. You can pass a face to inherit from, but can't specify a bare =:inherit=. This has the issue where an icon has the wrong background color based on which section of the modeline it occupies. So we need a function that will both apply a bare =:inherit= property along with some default scaling values.
#+BEGIN_SRC emacs-lisp
  (defun ic/icon (name &optional group)
    (setf group (or group 'alltheicon))
    (let* ((icon (funcall (intern (format "all-the-icons-%s" group))
                          name))
           (family (plist-get (plist-get (text-properties-at 0 icon)
                                         'face)
                              :family))
           (face `(:family ,family :inherit)))
      (propertize icon 'face face 'font-lock-face face 'display '(raise 0.1))))
#+END_SRC

For the version control segment I would like the see the git icon along with the current file's status if we're in the master branch. If we're in a non-master branch I want to see the git branch icon along with the branch name and current file's status.
#+BEGIN_SRC emacs-lisp
  (defun ic//vc-icon-git ()
    (let* ((branch (cadr (split-string vc-mode "Git[:-]")))
           ;; (project-name (second (nreverse (split-string (projectile-project-root) "/"))))
           (vc-state-icon (pcase (vc-state (buffer-file-name))
                            ('up-to-date "-")
                            ('edited "*")
                            ('added "^")
                            ('removed' "v")
                            ('conflict "!")
                            ('missing "m")
                            ('ignored "i")
                            ('unregistered "x")
                            (_ "?")))
           (branch-icon (if (string= branch "master")
                            (ic/icon "git")
                          (concat
                           (ic/icon "git-branch" 'octicon)
                           " "
                           branch))))
      (concat vc-state-icon " " branch-icon)))

  (spaceline-define-segment
      ic-vc-icon "A segment for the Version Control icon"
      (when vc-mode
        (cond ((string-match "Git[:-]" vc-mode) (ic//vc-icon-git))
              (t (propertize (format "%s" vc-mode))))))
#+END_SRC

I want to see when our current =projectile= differs from the active =persp-mode= perspective. This shouldn't happen, but I am seeing it when first getting the two to work together.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-project-name "A segment for the active projectile project."
      (let ((project (projectile-project-name))
            (persp (safe-persp-name (get-frame-persp))))
        (if (equal project persp)
            project
          (concat project "|" persp))))
#+END_SRC

Sometimes I use an older Surface Pro 4 tablet. This has a nasty habit of screen flickering when it gets hot. It seems to be alievated when the screen refreshes. So I hack around it by ensuring the modeline displays alternating =,= and =.= every second. I then need a timer to force the modeline to update, causing emacs to do a screen repaint, "fixing" the screen flickering. Simply calling =(redisplay t)= is not sufficient it seems.
#+BEGIN_SRC emacs-lisp
  (spaceline-define-segment
      ic-tablet-fix "A segment to hack around the screen flickering on the Surface
      Pro 4."
      (let ((seconds (% (floor (time-to-seconds)) 2)))
        (if (= seconds 0) "‚ò≥" "‚ò∑")))

  (when on-tablet
    (setq ic//tablet-fix-timer (run-at-time nil 1 #'force-mode-line-update))
    ;; (cancel-timer ic//tablet-fix-timer)
    )
#+END_SRC

Set the mode line.
#+BEGIN_SRC emacs-lisp
  ;; bring in bundled segments
  (require 'spaceline-segments)

  ;; and define our custom mode-line
  (spaceline-compile
    'main
    ;; left side
    '((window-number
       :priority 100
       :fallback evil-state
       :face highlight-face)
      ((buffer-modified
        all-the-icons-mode-icon
        remote-host)
       :priority 95)
      ((buffer-id)
       :priority 96)
      ((anzu
        selection-info)
       :priority 90)
      ((flycheck-error
        flycheck-warning
        flycheck-info)
       :priority 85)
      process)

    ;; right side
    '(((org-clock) :when active)
      ((ic-vc-icon)
       :priority 87)
      all-the-icons-git-status
      ;; XXX (projectile-root) is really slow outside a project
      ;; (projectile-root)
      ;; ((buffer-encoding-abbrev buffer-size
      ;;   input-method)
      ;;  :priority 5)
      (((ic-tablet-fix :when (and active on-tablet))
        buffer-position)
       :priority 91)))

  ;; and enable it
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main))))
#+END_SRC

=mode-line-format= is buffer-local and there are some buffers that have set it prior to us generating the mode-line, so we need to reset their values:
#+BEGIN_SRC emacs-lisp
  (save-excursion
    (dolist (name '("*Messages*" "*scratch*" "*straight-process*"))
      (if-let ((buffer (get-buffer name)))
          (with-current-buffer buffer
            (setq mode-line-format (default-toplevel-value 'mode-line-format))))))
#+END_SRC

** visual-fill-column
I want emacs to wrap long lines automatically and refill when modifying text. =visual-fill-column= does just that.
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :init (setq-default fill-column 80)
    :hook (visual-line-mode . visual-fill-column-mode))
#+END_SRC

** wgrep
=wgrep= is a package that let's us live edit a =helm-occur= buffer.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :init
    (add-hook 'helm-occur-mode-hook #'wgrep-change-to-wgrep-mode))
#+END_SRC

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
      :config
      (which-key-mode 1))
#+END_SRC

** winum
For numbering and jumping to windows.
#+BEGIN_SRC emacs-lisp
  (use-package winum
      :demand t
      :config
      ;; I want frames numbered only within a frame, not globally
      (setq winum-scope 'frame-local)
      ;; spaceline handles window numbers
      (setq winum-auto-setup-mode-line nil)
      (winum-mode)

      (defun ic/winum-delete-window-0-or-10 (&optional _arg)
        "Delete window 0 if assigned or 10 if exists."
        (interactive "P")
        (winum-select-window-0-or-10 '(4)))

      (defmacro defun-ic--winum-delete-window-num (n)
        "Create function for calling `winum-select-window-by-number'
  so that it kills window N."
        `(defun ,(intern (format "ic/winum-delete-window-%d" n)) (&optional _arg)
           ,(format "Delete window %d." n)
           (interactive "P")
           (winum-select-window-by-number ,(- n))))

      (defun-ic--winum-delete-window-num 1)
      (defun-ic--winum-delete-window-num 2)
      (defun-ic--winum-delete-window-num 3)
      (defun-ic--winum-delete-window-num 4)
      (defun-ic--winum-delete-window-num 5)
      (defun-ic--winum-delete-window-num 6)
      (defun-ic--winum-delete-window-num 7)
      (defun-ic--winum-delete-window-num 8)
      (defun-ic--winum-delete-window-num 9)

      :general
      (leader-keys
       "0" '(winum-select-window-0-or-10 :which-key ("0..9" . "winum-window 0..9"))
       "1" '(winum-select-window-1 :which-key t)
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t)
       "C-0" '(ic/winum-delete-window-0-or-10 :which-key ("C-0..9" . "ic/winum-delete-window 0..9"))
       "C-1" '(ic/winum-delete-window-1 :which-key t)
       "C-2" '(ic/winum-delete-window-2 :which-key t)
       "C-3" '(ic/winum-delete-window-3 :which-key t)
       "C-4" '(ic/winum-delete-window-4 :which-key t)
       "C-5" '(ic/winum-delete-window-5 :which-key t)
       "C-6" '(ic/winum-delete-window-6 :which-key t)
       "C-7" '(ic/winum-delete-window-7 :which-key t)
       "C-8" '(ic/winum-delete-window-8 :which-key t)
       "C-9" '(ic/winum-delete-window-9 :which-key t)
       )
      )
#+END_SRC

** yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :demand t
    )
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
      :init
      (setq yas-snippet-dirs (list (concat user-data-directory "snippets")))
      (yas-global-mode 1))
#+END_SRC

* Modes
** info-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'Info-mode-hook 'variable-pitch-mode)
#+END_SRC

** lisp-mode
Setup tab width.
#+BEGIN_SRC emacs-lisp
  (defun ic/lisp-mode-setup ()
    (setq indent-tabs-mode nil)
    (setq tab-width 8)
    (setq lisp-indent-function 'common-lisp-indent-function))

  (add-hook 'lisp-mode-hook #'ic/lisp-mode-setup)
#+END_SRC

Some useful functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/eval-outer-sexp-dwim ()
    "Evaluate the outermost sexp at POINT, stopping at any (def*) found."
    (interactive)
    (save-excursion
      (condition-case nil
          ;; move up as much as possible
          (while (not (looking-at "(def"))
            (up-list -1 t))
        (error nil))
      ;; are we on a left paren?
      (if (eq ?\( (following-char))
          (progn
            ;; move to the end
            (forward-sexp)
            ;; and evaluate
            (call-interactively 'eval-last-sexp))
        (message "Cannot evaluate: not inside an sexp"))))

  (defun ic/eval-enclosing-sexp ()
    "Evaluate the sexp enclosing POINT."
    (interactive)
    (save-excursion
      (condition-case nil
          (progn
            (up-list -1 t)
            (forward-sexp)
            (backward-char))
        (error
         (message "Cannot evaluate: not inside an sexp"))
        (:success
         (call-interactively 'eval-last-sexp)))))
#+END_SRC

Setup keybinds
#+BEGIN_SRC emacs-lisp
  (local-leader-keys
    :keymaps '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "e" '(ic/eval-enclosing-sexp :which-key "ic/eval-enclosing-sexp")
    "E" 'ic/eval-outer-sexp-dwim
    "B" 'eval-buffer
    "M" 'emacs-lisp-macroexpand
    )
#+END_SRC

** prog-mode
#+BEGIN_SRC emacs-lisp
  (defun ic/prog-mode-setup ()
    (flyspell-prog-mode)
    (auto-fill-mode)
    (company-mode 1)
    (setq indent-tabs-mode nil)
    (setq tab-width 4))
  (add-hook 'prog-mode-hook #'ic/prog-mode-setup)
#+END_SRC

** python-mode
#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (require 'python))

  (defun ic/python-mode-setup ()
    (setq python-indent-offset tab-width)
    (lsp))

  (add-hook 'python-mode-hook #'ic/python-mode-setup)
#+END_SRC

** text-mode
Let's have automatic spell checking for text heavy buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'flyspell-mode)
#+END_SRC

** winner-mode
I like being able to undo/redo window changes.
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

* Misc
** Misc cruft
Turn off some default emacs settings I don't like, such as the menu bar, scroll
bar, etc.

#+BEGIN_SRC emacs-lisp
  ;; disable unwanted UI elements
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)

  ;; static cursor
  (blink-cursor-mode -1)

  ;; don't show the initial emacs screen
  (setq inhibit-startup-screen t)
  ;; start in the *Messages* buffer
  (setq initial-buffer-choice (lambda () (get-buffer "*Messages*")))
  ;; let me use y/n in prompts
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** user-emacs-directory
Try and keep the =user-emacs-directory= somewhat clean.
#+BEGIN_SRC emacs-lisp
  ;; cache/ directory
  (setq recentf-save-file (concat user-cache-directory "recentf"))
  (setq transient-history-file (concat user-cache-directory "transient-history.el"))
  (setq bookmark-default-file (concat user-cache-directory "bookmarks"))
  (setq tramp-persistency-file-name (concat user-cache-directory "tramp"))

  ;; cache/{backups,auto-saves}
  (let ((backup-dir (concat user-cache-directory "backups/"))
        (autosave-dir (concat user-cache-directory "auto-saves/")))
    ;; create directories if needed
    (dolist (path (list backup-dir autosave-dir))
      (unless (file-directory-p path)
        (make-directory path t)))
    (setq backup-directory-alist `((".*" . ,backup-dir)))
    (setq auto-save-file-name-transforms `((".*" ,autosave-dir t)))
    (setq auto-save-list-file-prefix (concat autosave-dir "saves-"))
    (setq tramp-backup-directory-alist `((".*" . ,backup-dir)))
    (setq tramp-auto-save-directory autosave-dir))

  ;; data/ directory
  (setq abbrev-file-name (concat user-data-directory "abbrev"))
#+END_SRC

** Buffers
Some useful buffer related functions.
#+BEGIN_SRC emacs-lisp
  (defun ic/yank-buffer-to-clipboard ()
    "Yank contents of current buffer to the clipboard."
    (interactive)
    (clipboard-kill-ring-save (point-min) (point-max)))

  (defun ic/paste-clipboard-to-buffer ()
    "Overwrite the current buffer with the clipboard contents."
    (interactive)
    (when (yes-or-no-p "Overwrite current buffer with clipboard?")
      (widen)
      (erase-buffer)
      (clipboard-yank)))

  (defun ic/yank-current-filename ()
    "Yank the full filename of the currently active buffer. Return
  `nil' if no underlying file."
    (interactive)
    (let ((filename (or (buffer-file-name) "nil")))
      (kill-new filename)
      (message filename)))

  (defun ic/switch-to-scratch-buffer ()
    "Switch to the `*scratch*' buffer."
    (interactive)
    (switch-to-buffer (startup--get-buffer-create-scratch)))
#+END_SRC

** Files
Some useful file related functions.

First, some shortcuts to my configuration files.
#+BEGIN_SRC emacs-lisp
  (defun ic/edit-init-file ()
    "Open the `init. l' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))

  (defun ic/edit-early-init-file ()
    "Open the `early-init.el' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "early-init.el")))

  (defun ic/edit-org-config-file ()
    "Open the `README.org' file for editing."
    (interactive)
    (find-file (concat user-emacs-directory "README.org")))
#+END_SRC

Some functions to manipulate underlying files.
#+BEGIN_SRC emacs-lisp
  (defun ic/delete-current-buffer-file ()
    "Delete the currently visited file."
    (interactive)
    (if-let (filename (buffer-file-name))
        (when (yes-or-no-p (format "Delete file %S? " filename))
          (delete-file filename)
          (kill-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache filename))
          (message (format "Deleted file %S." filename)))))


  (defun ic/rename-current-buffer-file ()
    "Rename the currently visited file."
    (interactive)
    (if-let (cur-filename (buffer-file-name))
        (let ((new-filename (read-file-name
                             (format "Rename %S to: "
                                     (file-name-nondirectory cur-filename))))
              (cur-buffer (buffer-name)))
          (rename-file cur-filename new-filename)
          (find-file new-filename)
          (kill-buffer cur-buffer)
          (when (and (fboundp 'projectile-project-p)
                     (projectile-project-p))
            (delete-file-projectile-remove-from-cache cur-filename)
            (call-interactively 'projectile-cache-current-file))
          (message (format "Renamed %S to %S." cur-filename new-filename)))))
#+END_SRC

** display-buffer configuration
#+BEGIN_SRC emacs-lisp
  (setq display-buffer-alist
        '(
          ;; display help windows on the right
          ("^\\*\\(Help\\|info\\)"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . right)
           (slot . 1)
           (window-width . 80)
           (reusable-frames . nil))

          ;; display compile errors on the bottom
          ("^\\*\\(Compile\\|Backtrace\\)"
           (display-buffer-reuse-window display-buffer-at-bottom)
           (window-width . 0.5)
           (window-height . 15)
           (reusable-frames . nil))

          ;; display magit windows on the left
          ("^magit:"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (side . left)
           (slot . 1)
           (window-width . 80)
           (window-height . 1.0)
           (reusable-frames . nil))
          ))
#+END_SRC

** Secrets
I keep certain information out of source control: email addresses, account information, etc. I have a small python program called =secret= that I use to retrieve these secrets, let's expose that to emacs.

#+BEGIN_SRC emacs-lisp
  (defvar ic/secret-cmd "secret")

  (defun ic/get-secret (secret)
    "Retrieve `secret' using the `ic/secret-cmd' program."
    (nth 0 (process-lines ic/secret-cmd secret)))
#+END_SRC

** Customize
I don't like =customize= so discard all settings.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat (temporary-file-directory) "emacs-customize-settings"))
#+END_SRC

** Tab Width
Use 4 spaces by default for tabs. Note: these are commonly overwritten in mode hooks.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)
#+END_SRC

** Quitting
I want emacs to continue to run as a server whenever I "quit". I should have to use an infrequent key sequence to fully kill emacs. Taken from [[https://www.reddit.com/r/spacemacs/comments/6p3w0l/making_q_not_kill_emacs/][here]].

#+BEGIN_SRC emacs-lisp
  (defun ic/save-and-kill-buffer-and-window ()
    "Save current buffer and kill it along with current window."
    (interactive)
    (save-buffer)
    (ic/kill-buffer-and-window))

  (defun ic/maybe-kill-emacs ()
    "Prompt to quit emacs, then save and quit."
    (interactive)
    (when (yes-or-no-p "Really quit emacs?")
      (save-buffers-kill-emacs)))

  (defun ic/kill-buffer-and-window ()
    "Destroy the current buffer and window, if it was the sole window also delete
  the frame."
    (interactive)
    (condition-case-unless-debug nil
        (kill-buffer-and-window)
      (error
       (spacemacs/frame-killer))))

  ;; from spacemacs
  (defun spacemacs/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error
       (make-frame-invisible nil 1))))
#+END_SRC

Set evil ex commands:
#+BEGIN_SRC emacs-lisp
  (evil-ex-define-cmd "q[uit]" 'ic/kill-buffer-and-window)
  (evil-ex-define-cmd "wq" 'ic/save-and-kill-buffer-and-window)
#+END_SRC

And some =leader-key= bindings:
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "q"
   "" '(nil :which-key "quit")
   "q" 'spacemacs/frame-killer
   "Q" 'ic/maybe-kill-emacs)
#+END_SRC

** Frame title
Set the frame title to something meaningful.

#+BEGIN_SRC emacs-lisp
  (defun ic/short-persp-name ()
    "Return a shortened name for currently active perspective. Returns `nil'
  when `persp-mode' not enabled."
    ;; we guard calls to `get-frame-persp' and `safe-persp-name' behind a
    ;; check for `\'persp-mode' so shutup the compiler about unknown functions.
    (eval-when-compile
      (unless (fboundp 'get-frame-persp)
        (defun get-frame-persp ()))
      (unless (fboundp 'safe-persp-name)
        (defun safe-persp-name (_))))
    (when (and (boundp 'persp-mode) (get-frame-persp))
      (let ((name (safe-persp-name (get-frame-persp))))
        (concat " <"
                (if (file-directory-p name)
                    (file-name-nondirectory (directory-file-name name))
                  name)
                "> "))))

  (setq frame-title-format
        '((:eval (buffer-name (window-buffer (minibuffer-selected-window))))
          (:eval (ic/short-persp-name))))
#+END_SRC

** Spelling
When typing in insert mode I want to hit =C-e= to automatically correct the previous misspelled word.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(insert normal)
   "C-e" #'flyspell-auto-correct-previous-word)
#+END_SRC

** Line Numbers
Use =display-line-numbers= to show line numbers as it's written in C and part of the re-display code so can run only when needed. Lisp implementations such as =linum= and =nlinum= have to run over an entire window as they can't know which part of the screen changed.

Disable other line number modes and only enable =display-line-numbers= in certain text-heavy modes.
#+BEGIN_SRC emacs-lisp
  (global-linum-mode -1)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

I want relative line numbers that count only what's seen on the screen. I also want to minimize any changing of the screen width.
#+BEGIN_SRC emacs-lisp
  ;; use lines displayed on screen rather than new line characters; so folds work
  (setq-default display-line-numbers-type 'visual)
  ;; show the current line as absolute
  (setq-default display-line-numbers-current-absolute t)
  ;; ignore folding when determining relative lines
  (setq-default display-line-numbers-widen t)
  ;; start with a width of 3 ...
  (setq-default display-line-numbers-width 3)
  ;; ... and allow it to shrink :(
  (setq-default display-line-numbers-grow-only nil)
#+END_SRC

I would really like to set =display-line-numbers-grow-only= to =t= so that it only grows and prevents shrinkage, but it seems there is a significant performance cost associated with it. I've increased the default width slightly to offset it, but that will waste a bit more space on small files.

*** Note on fringe
=display-line-numbers= doesn't use the =display-margin= to show line numbers like =linum-mode=, instead it uses the =text-area= where the main buffer text is. This means that anything in the fringe (=display-margin=) now shows up to the left of the line numbers. I'm not a fan of that, but I guess I'll live with it as there's no way around it currently. See [[https://www.reddit.com/r/emacs/comments/aa9rg7/how_to_make_line_numbers_in/ecq7nub/][this]] reddit post from the author of =display-line-numbers= for more info.

** Web Browser
=firefox=, duh.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic)
  (setq browse-url-generic-program
        (cond
         (on-tablet
          "c:/Program Files/Mozilla Firefox/firefox.exe")
         (on-old-imac
          "/Applications/Firefox.app/Contents/MacOS/firefox")
         (t
          "firefox")))
#+END_SRC

** Minibuffer / completion testing (disabled)
:PROPERTIES:
:header-args: :tangle no
:END:

*** Marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :demand t
    :config
    (defun ic/ignore-marginalia-annotate-binding (&_))
    (advice-add 'marginalia-annotate-binding :override 'ic/ignore-marginalia-annotate-binding)
    (marginalia-mode 1)
    )

#+END_SRC

*** Embark
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :demand t

    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    ;; (add-to-list 'display-buffer-alist
    ;;              '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
    ;;                nil
    ;;                (window-parameters (mode-line-format . none))))

    (add-hook 'embark-post-action-hook #'embark-collect--update-linked)
    ;; (remove-hook 'embark-post-action-hook #'embark-collect--update-linked)

    (add-hook 'minibuffer-setup-hook #'embark-collect-completions)
    ;; (remove-hook 'minibuffer-setup-hook #'embark-collect-completions)

    (defun ic/embark-act-noexit ()
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'embark-act)))

    :general
    (leader-keys
      "hdb" 'embark-bindings)

    (general-define-key
     :keymaps 'minibuffer-local-map
     "C-," 'embark-act
     "C-<" 'ic/embark-act-noexit
     "C-." 'embark-become)
    )

#+END_SRC

*** Minibuffer
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'minibuffer-local-map
   "C-w" 'evil-delete-backward-word)

#+END_SRC

*** Consult
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :demand t
    :config
    ;; use TAB for previewing
    (setq consult-preview-key (kbd "<tab>"))
    (setq consult-narrow-key "<")

    (defun ic/consult-unfocus-lines ()
      "Reset any current focus from `consult-focus-lines'."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'consult-focus-lines)))

    :general
    (leader-keys
      "bb" 'consult-buffer
      "fb" 'consult-bookmark
      "pi" 'consult-project-imenu
      "ha" 'consult-apropos
      "sf" 'consult-find
      "sL" 'consult-locate
      "sg" 'consult-grep
      "sG" 'consult-git-grep
      "sm" 'consult-multi-occur
      "sr" 'consult-ripgrep
      "su" 'consult-focus-lines
      "sU" 'ic/consult-unfocus-lines
      )

    (general-define-key
     :states '(normal)
     "go" 'consult-outline
     "gh" 'consult-org-heading
     "gi" 'consult-imenu
     "gl" 'consult-line
     )

    )

#+END_SRC

*** Selectrum (not used)
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand nil
    :after (orderless embark)
    :config
    (selectrum-mode 1)

    ;; window should be exactly 20 lines always
    (setq selectrum-max-window-height 20)
    (setq selectrum-fix-vertical-window-height selectrum-max-window-height)

    ;; Optional performance optimization
    ;; by highlighting only the visible candidates.
    (setq orderless-skip-highlighting (lambda () selectrum-is-active))
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (setq selectrum-refine-candidates-function #'orderless-filter)

    ;; when we have an embark collect: only show the current selectrum item
    (defun ic/single-line-selectrum ()
      (when (eq embark-collect--kind :live)
        (with-selected-window (active-minibuffer-window)
          (setq-local selectrum-num-candidates-displayed 1)
          (setq-local selectrum-display-style
                      '(horizontal :before-candidates "[" :after-candidates "]"
                                   :more-candidates "" :candidates-separator "")))))
    (add-hook 'embark-collect-mode-hook #'ic/single-line-selectrum)

    ;; selectrum should have a decoration-less window on the bottom
    (setq selectrum-display-action '(display-buffer-in-side-window
                                     (side . bottom)
                                     (slot . -1)
                                     (window-parameters (mode-line-format . none))))
    )
#+END_SRC

*** embark-consult
#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :ensure t
    :demand t
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))

#+END_SRC

*** orderless
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :demand t
    :config
    (defun ic/orderless-bang-prefix (pattern _index _total)
      (when (string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))

    (defun ic/orderless-bang-suffix (pattern _index _total)
      (when (string-suffix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 0 -1))))

    (defun ic/orderless-carrot-suffix (pattern _index _total)
      (when (string-suffix-p "^" pattern)
        `(orderless-regexp . ,(concat "^" (substring pattern 0 -1)))))

    (setq completion-styles '(orderless))
    (setq orderless-matching-styles '(orderless-regexp))
    (setq orderless-style-dispatchers '(ic/orderless-bang-prefix
                                        ic/orderless-bang-suffix
                                        ic/orderless-carrot-suffix))
    )
#+END_SRC

** Movement
Some misc functions to support moving around.

#+BEGIN_SRC emacs-lisp
  (defun ic/move-to-outline-dwim ()
    "Prompt for, and move to, an outline heading."
    (interactive)
    (cond ((eq major-mode 'org-mode)
           (ic/org-jump-in-buffer))
          (t
           (message (format "No outline command found for mode `%s'" major-mode)))))
#+END_SRC

** Garbage Collection
I have problems typing in =org-mode= documents with the default garbage collector settings. So let's give the GC 100mb to work with and call it when emacs is idle.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 100 (expt 2 20)))
  (setq gc-cons-percentage 0.5)
  (run-with-idle-timer 5 t #'garbage-collect)
  (setq garbage-collection-messages nil)
#+END_SRC

** Shell replace
I'd like a way to call =shell-command-on-region= and have it replace the current region without using a prefix arg.

#+BEGIN_SRC emacs-lisp
  (defun ic/shell-command-on-region-replace ()
    "Call `shell-command-on-region' with prefix arg set."
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively 'shell-command-on-region)))
#+END_SRC

** Windows fixes
For some reason on windows emacs doesn't associate =FontAwesome= code points with the font, so specifiy that manually. Taken from [[https://www.reddit.com/r/emacs/comments/34ttb8/get_fontawesome_to_display_correctly_under_windows/?][here]].

Note: =f2b4= was chosen as the ending codepoint by inspecting =data-faicons.el= from =all-the-icons= package. This might change on updates.
#+BEGIN_SRC emacs-lisp
  (when on-windows
    (set-fontset-font "fontset-default" '(#xf000 . #xf2b4) "FontAwesome"))
#+END_SRC

** Mac Fixes
For some (stupid) reason =/usr/local/bin= isn't included in the =PATH= on mac. I've ensured it's loaded in =~/.bashrc=, =~/.bash_profile= and =~/.profile=. I've also added it under =/etc/paths.d/= as well as ensured it's part of =/etc/paths=. I've checked permissions (I can run programs from it) and since I know it's added correctly in a shell (with code I've been using for a decade now) let's just add it manually for emacs. Ugh
#+BEGIN_SRC emacs-lisp
  (when on-old-imac
    (setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    (add-to-list 'exec-path "/usr/local/bin"))
#+END_SRC

Ensure =emacs= takes up as much of the screen as possible when maximizing.
#+BEGIN_SRC emacs-lisp
  (when on-mac
    (setq frame-resize-pixelwise t))
#+END_SRC

When we're on a mac and we have GNU =ls= installed (=gls=): use that as our =dired= listing program. Both because it supports  the =--dired= flag, but we can also get some marginally better collating from the GNU version.
#+BEGIN_SRC emacs-lisp
  (when (and on-mac
             (executable-find "gls"))
    (setq insert-directory-program "gls")
    (setq dired-listing-switches "-alU"))
#+END_SRC

** Start maximized
I want every frame to start maximized by default.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+END_SRC

* Keybindings
Here we copy the spacemacs keybindings, more or less.

** main
#+BEGIN_SRC emacs-lisp
  (leader-keys
    "|" 'ic/shell-command-on-region-replace
    "C-|" 'shell-command-on-region
    "TAB" 'evil-switch-to-windows-last-buffer
    "u" 'universal-argument)
#+END_SRC

** normal mode
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(normal)
   :keymaps 'general-override-mode-map
   "go" 'ic/move-to-outline-dwim
   "gl" 'helm-occur)
#+END_SRC

** Escape Key
Make  =<escape>= quit as much as possible.

XXX should these go in an override map?

#+BEGIN_SRC emacs-lisp
  (general-define-key
      :keymaps '(minibuffer-local-map
                 minibuffer-local-ns-map
                 minibuffer-local-completion-map
                 minibuffer-local-must-match-map
                 minibuffer-local-isearch-map)
      "<escape>" 'keyboard-escape-quit)
#+END_SRC

** a :: applications
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "a"
   "" '(nil :which-key "applications")
   "d" 'dired
   "s" 'ansi-term
   "i" 'ielm
   )
#+END_SRC

** b :: buffers
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "b"
   "" '(nil :which-key "buffers")
   "b" 'ic/helm-buffers
   "B" 'helm-mini
   "d" 'kill-this-buffer
   "i" 'ic/projectile-ibuffer
   "I" 'ibuffer
   "P" 'ic/paste-clipboard-to-buffer
   "R" 'revert-buffer
   "s" 'ic/switch-to-scratch-buffer
   "w" 'read-only-mode
   "Y" 'ic/yank-buffer-to-clipboard)
#+END_SRC

** B :: build

** e :: errors

** E :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "E"
    "" '(nil :which-key "emacs")
    "d" 'toggle-debug-on-error
    "f" 'toggle-frame-fullscreen
    "F" 'make-frame
    "m" 'toggle-frame-maximized)
#+END_SRC

** Ep :: Emacs profiler
Profiler bindings.
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "Ep"
   "" '(nil :which-key "emacs profiler")
   "c" #'ic/start-cpu-profiler
   "m" #'ic/start-mem-profiler
   "p" #'ic/start-cpu-mem-profiler
   "s" #'profiler-stop
   "r" #'profiler-report)
#+END_SRC

** f :: Files
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "f"
   "" '(nil :which-key "files")
   "b" 'helm-bookmarks
   "c" 'copy-file
   "D" 'ic/delete-current-buffer-file
   "E" 'sudo-edit
   "f" 'ic/helm-find-files
   "F" 'helm-find-files
   "L" 'helm-locate-library
   "M" 'ic/rename-current-buffer-file
   "r" 'ic/helm-recentf
   "R" 'helm-recentf
   "y" 'ic/yank-current-filename)
#+END_SRC

** fC :: Convert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fC"
   "" '(nil :which-key "convert")
   "d" 'unix-to-dos
   "u" 'dos-to-unix)
#+END_SRC

** fe :: Emacs
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "fe"
   "" '(nil :which-key "emacs")
   "i" 'ic/edit-init-file
   "I" 'ic/edit-early-init-file
   "o" 'ic/edit-org-config-file
   "l" 'helm-locate-library)
#+END_SRC

** g :: git/vc
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "g"
    "" '(nil :which-key "git")
    "i" 'magit-gitignore
    "s" 'magit-status
    "S" 'magit-stage-file
    "U" 'magit-unstage-file
    )
#+END_SRC

** h :: help
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "h"
   "" '(nil :which-key "help")
   "a" 'apropos
   "k" 'which-key-show-top-level
   "i" 'info
   "I" 'helm-info
   "m" 'helm-man-woman)
#+END_SRC

** hd :: help describe
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "hd"
   "" '(nil :which-key "describe")
   "b" 'describe-bindings
   "c" 'describe-char
   "f" 'describe-function
   "F" 'describe-face
   "K" 'describe-keymap
   "k" 'describe-key
   "l" 'describe-last-keys
   "m" 'describe-mode
   "p" 'describe-package
   "s" 'describe-system-info
   "t" 'describe-theme
   "v" 'describe-variable)
#+END_SRC

** i :: insert
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "i"
   "" '(nil :which-key "insert")
   "8" 'helm-ucs
   "c" 'insert-char
   )
#+END_SRC
** l :: layouts

** m :: major mode

** p :: projects

** r :: registers

** s :: search

** S :: snippets
#+BEGIN_SRC emacs-lisp
  (leader-keys
    :infix "S"
    "" '(nil :which-key "snippets")
    "e" #'yas-visit-snippet-file
    "i" #'yas-insert-snippet
    "n" #'yas-new-snippet)
#+END_SRC

** t :: toggle
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "t"
   "" '(nil :which-key "toggle")
   "C" 'flycheck-mode
   "S" 'flyspell-mode
   "T" 'load-theme
   "w" 'whitespace-mode
   )
#+END_SRC

** w :: windows
#+BEGIN_SRC emacs-lisp
  (leader-keys
   :infix "w"
   "" '(nil :which-key "windows")
   "=" 'balance-windows
   "d" 'delete-window
   "f" 'follow-mode
   "H" 'evil-window-move-far-left
   "h" 'evil-window-left
   "J" 'evil-window-move-very-bottom
   "j" 'evil-window-down
   "K" 'evil-window-move-very-top
   "k" 'evil-window-up
   "L" 'evil-window-move-far-right
   "l" 'evil-window-right
   "m" 'delete-other-windows
   "S" 'split-window-below-and-focus
   "s" 'split-window-below
   "U" 'winner-redo
   "u" 'winner-undo
   "V" 'split-window-right-and-focus
   "v" 'split-window-right
   )
#+END_SRC

** x :: text

